---
title: "P390 Treg Engineered and Tconv study"
author: "Analyst: Alex Hu"
output: pdf_document
editor_options: 
  chunk_output_type: console
---


```{r setup, echo=FALSE, message=FALSE, warning=FALSE}

library(mongolite)
library(apird)
library(stringr)

# Download data from in-house database
if(FALSE){
  libs <- getProjectLibs("P390", searchType = "regex")
  anno <- getAnno(libs)
  rownames(anno) <- anno$libid
  
  anno$sort[ anno$project == "P390-29"] <- "CD154+CD69+ CD4 T cells"
  anno$cellType[ anno$project == "P390-29"] <- "Tconventional"

  #metrics <- getMetrics(libs, returnLibsWithIssues = TRUE)
  metrics <- getMetrics(libs)
  
  rownames(metrics) <- metrics$libid
  #design <- merge(design, anno[!is.na(anno$dateUpdated),], by.x = "libid", by.y="libid")
  design <- merge(metrics, anno, by.x = "libid", by.y="libid")

  projs <- unique(anno$project)
  
  countlibs <- metrics$libid[!is.na(metrics$fastq_total_reads)]
  liblist <- list()
  countslist <- list()
  i <- 1
  k <- 1
  while( i <= length(countlibs) ){
    print( paste(k,i))
    liblist[[k]] <- countlibs[i:min(i+500-1,length(countlibs))]
    countslist[[k]] <- getGeneCounts( liblist[[k]] )
    i <- i+500
    k <- k+1
  }
  
  design <- design[!is.na(design$fastq_total_reads),]
  colnames(counts) <- str_extract(colnames(counts), "lib[0-9]+")
  rownames(design) <- design$libid

}

demo <- data.frame(read_xlsx("../../data/GenLIMS Samples_P390_demographics.xlsx"))
rownames(demo) <- demo$Proj.Sub
design$donorID <- demo[design$project, "Donor.ID"]


library(knitr)
library(dplyr)
library(Seurat)
library(ggrepel)
library(circlize)
library(ComplexHeatmap)
# library(ggplot2); theme_set(theme_bw(20) + theme(panel.grid.major = element_blank(), 
#                                                  panel.grid.minor = element_blank()) +
#                               theme(legend.key = element_blank()))

library(ggplot2);theme_set(theme_bw(20) + theme(panel.grid.major = element_blank(),
                                panel.grid.minor = element_blank(),
                                panel.border = element_rect(colour="black", fill=NA, size=1),
                                axis.text=element_text(colour="black"),
                                axis.ticks=element_line(colour="black"))+
  theme(legend.key = element_blank()))

library(edgeR)
library(limma)
library(gplots)
library(RColorBrewer) 
library(ggthemes)
library(ggbeeswarm)
library(viridis)
library(stringr)
library(readxl)
library(tcrGraph)
#library(ggforce)
#Load Matt's library which includes a function for making barcode plots
#library(geneSetTools)
library(umap)
library(scran)
library(ggbeeswarm)
library(monocle3)

datadir = "../../data/2023-03-29/"

plotdir = paste0(datadir,"plots/")
options(stringsAsFactors = FALSE)

pgrep <- function(s,l){
  return( l[grep(s,l)])
}
```

```{r Push note for the duplicating libraries in P390-28 }

if(TRUE){
  oldlibs28 <- design$libid[ design$project == "P390-28" & design$libnum <= 85622  ]
  newlibs28 <- design$libid[ design$project == "P390-28" & design$libnum > 85622  ]
}
```

```{r get and annotate TCRs}

# get TCRs
tcrsRaw <- getTcrs( design$libid)
tcrsRaw$libnum <- as.numeric(gsub("lib","",tcrsRaw$libid))

tcrs <- tcrsRaw
# Filter out the duplicated data for P390-28
design$libnum <- as.numeric( gsub("lib","",design$libid))
oldlibs28 <- design$libid[ design$project == "P390-28" & design$libnum <= 85622  ]
tcrs <- tcrs[ !tcrs$libid %in% oldlibs28,]

tcrs$donorID <- design[ tcrs$libid, "donorID"]
tcrs$DonorNuc <- paste( tcrs$donorID, tcrs$full_nt_sequence)
expandedDonorNucs <- tcrs$DonorNuc[ duplicated( tcrs$DonorNuc)]
sharedJunctions <- unique( tcrs$junction[ duplicated( tcrs$junction)] )

tcrs$expanded <- tcrs$DonorNuc %in% (expandedDonorNucs)
expandedlibs <- unique(tcrs$libid[ tcrs$expanded] )

# assign chain type
tcrs$chain <- rep(" ",nrow(tcrs))
tcrs$chain[ grepl("TRA",tcrs$v_gene)] <- "TRA"
tcrs$chain[ grepl("TRB",tcrs$v_gene)] <- "TRB"
tcrs$chain[ grepl("TRG",tcrs$v_gene)] <- "TRG"
tcrs$chain[ grepl("TRD",tcrs$v_gene)] <- "TRG"

tcrs$donorID <- anno[tcrs$libid, "donorID"]

### Identify possible doublets and put them in the tcrs
betaDoublets <- tcrs[ tcrs$chain == "TRB",]
betaDoublets <- unique( betaDoublets$libid[ duplicated(betaDoublets$libid)])
# Identify alpha triplets
alphaTab <- table( tcrs[ tcrs$chain == "TRA", "libid"] )
alphaTriplets <- names(alphaTab)[ alphaTab > 2]

```

```{r 10/24/09 Bubble Plot of Treg Flow Markers}

# In the short term I’m hoping to provide more context on the annotation of the Tregs; I was wondering about the index sort markers CD45RA and CD45RO, as well as CD38, CD69, CD137, CD25, PD-1 and TIGIT.

flow9 <- data.frame( read_xlsx("../../data/2024-10-24/P390 index sort Treg cell types_Final.xlsx") )
markerCols <- colnames(flow9)[ grepl("Geometric.Mean..", colnames(flow9))]

newflow <- flow9
newflow$project <- newflow$Proj.Sub
### Read in the latest iteration of flow data
projects <- unique(newflow$Proj.Sub)
# Convert plate location to plate index from 1 to N
plateToIndex <- function(s){
  vals <- as.numeric( strsplit(s,",")[[1]] )
  return( sum(vals*c(12,1))+1)
}
newflow$index <- sapply(newflow$plate_location, plateToIndex)
newflow$projectIndex <- paste0(newflow$Proj.Sub, "_", newflow$index)

## For some reason, a few cells in P390-56 are duplicated. I will remove those rows.
newflow <- newflow[ ! rownames(newflow) %in% c(659,660), ] # remove those rows
rownames(newflow) <- newflow$projectIndex
newflow <- newflow[order(newflow$project, newflow$index),]

subanno <- anno[ anno$project %in% newflow$project,]
subanno$stimPool <- "NA"
subanno <- subanno[ order(subanno$libid),]
subanno$libnum <- as.numeric( gsub("lib","", subanno$libid))
subanno$TNaive <- 0
for( proj in unique(newflow$project) ){
  flown <- sum(newflow$project == proj)
  projn <- sum(subanno$project == proj)
  print( paste(proj,flown == projn,flown,projn) )
  if( flown == projn ){
    subanno[ subanno$project == proj, markerCols] <- newflow[ newflow$project == proj, markerCols ]
  }
  # The first cell in P390-31 was not collected in the flow data but it was in the other data.
  if( proj == "P390-31" ){
    subanno[ subanno$libid != "lib87188" & subanno$project == proj, markerCols] <- newflow[ newflow$project == proj, markerCols]
  }
  if( proj == "P390-28" ){
    subanno[ subanno$libnum <= 85622 & subanno$project == proj, markerCols] <- "NA"
    subanno[ subanno$libnum > 85622 & subanno$project == proj, markerCols] <- newflow[ newflow$project == proj, markerCols]
  }
}

subanno$cluster <- treg_coords[ subanno$libid, "cluster"]
subanno <- subanno[ subanno$libid %in% rownames(treg_coords),]
subanno[,c("x","y")] <- treg_coords[subanno$libid,c("x","y")]

write.table(subanno,"MatchedTregFlowData.txt",quote=FALSE,sep="\t",col.names=NA)

tp <- t(apply(subanno[,markerCols],2, function(col) (col-mean(col[!is.na(col)]))/sd( col[!is.na(col)]) ))
tp[is.na(tp)] <- 0
Heatmap( tp, column_split = subanno$cluster, show_column_names=FALSE)

marker <- "Geometric.Mean..CD25."
marker <- "IL2RA"
subanno$m <- subanno[,marker]
subanno <- subanno[order(subanno$m),]
ggplot(subanno, aes(x=x,y=y,color=m)) + geom_point() + scale_color_viridis(option="B") + labs(x="UMAP 1",y="UMAP 2", color="gMFI", title=gsub("\\.","",gsub("Geometric.Mean..","",marker)))

# z-score before getting the mean
# subanno[,markerCols] <- apply(subanno[,markerCols],2, function(vals) (vals-mean(vals[!is.na(vals)]))/sd(vals[!is.na(vals)]))

meanNoNa <- function(vals){
  return( mean(vals[!is.na(vals)]))
}
# Don't z-score
clusterMfiMeans <- aggregate( subanno[,markerCols], by=list(subanno$cluster), FUN=meanNoNa)
# z-score
clusterMfiMeans <- aggregate( scale(subanno[,markerCols]), by=list(subanno$cluster), FUN=meanNoNa)

rownames(clusterMfiMeans) <- clusterMfiMeans[,1]; clusterMfiMeans <- clusterMfiMeans[,2:ncol(clusterMfiMeans)]
if( FALSE ){ # z-score
  clusterMfiMeans <- t(scale(clusterMfiMeans))
} else{ # don't z-score
  clusterMfiMeans <- t(clusterMfiMeans)
}
clusterMfiMeansLong <- reshape2::melt(clusterMfiMeans); colnames(clusterMfiMeansLong) <- c("marker","cluster","value")

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

tp <- clusterMfiMeans
rownames(tp) <- gsub("\\.","",gsub("Geometric.Mean..","",rownames(tp)))
rownames(tp) <- gsub("CD452","CD45-2",rownames(tp))
clustercols <- gg_color_hue( ncol(tp)); names(clustercols) <- 1:ncol(tp)
#png("../../data/2024-10-24/TregFlowMarkerHeatmapByCluster.png",width=400,height=400)
ha <- HeatmapAnnotation(df=data.frame(cluster=colnames(tp)), col=list(cluster=clustercols))
Heatmap(tp,name="mean\ngMFI",column_names_rot = 0,column_title="Treg Clusters\nMean Geometric Mean of Flow Markers",top_annotation=ha)
#dev.off()


ggplot(clusterMfiMeansLong , aes(x=marker,y=cluster,color=value)) + geom_point(size=3) + scale_color_viridis(option=3)

ggplot(flow9,aes(x=Geometric.Mean..CD45RA.,y=Geometric.Mean..CD45RO.)) + geom_point()

ggplot(flow9,aes(x=x,y=y,color=Geometric.Mean..CD45RO.)) 

### Make plot of CD45RA and CD45RO
ptab <- table(flow9$Proj.Sub)
proj <- names(ptab)[ptab>=15]
ggplot(flow9[ flow9$Proj.Sub %in% proj,],aes(x=Geometric.Mean..CD45RA.,y=Geometric.Mean..CD45RO.)) + geom_point() + facet_wrap(~Proj.Sub)

# Plot CD25 marker expression and IL2RA RNA
subanno$IL2RA <- as.numeric( log2(1+counts_pc_norm["ENSG00000134460" , subanno$libid]) )
ggplot( subanno, aes(x=IL2RA,y=Geometric.Mean..CD25.,color=cluster)) + geom_point(size=0.5) + labs(x="log IL2RA mRNA expression",y="Geometric Mean CD25") + scale_color_manual( values=clustercols)

```


```{r look at flow data}
design$pnum <- as.numeric(sapply(design$project, function(s) strsplit(s,"-")[[1]][2]))

### 10/31/23 Add in missing flow data for projects P390-18, P390-28, and P390-31
flow7 <- data.frame( read_xlsx("../../data/2023-10-23/20231027_Treg_IndexSort_Final.xlsx") )
flow8 <- data.frame( read_xlsx("../../data/2023-10-23/20231031_Tconv_IndexSort_Final.xlsx") )
flow8$TNaive <- flow8$Naive

projectToDonor <- dplyr::bind_rows(flow7, flow8)
projectToDonor <- projectToDonor[!duplicated(projectToDonor$Proj.Sub),]
projs <- projectToDonor$Proj.Sub
projectToDonor <- projectToDonor$Donor.ID; names(projectToDonor) <- projs


flow9 <- data.frame( read_xlsx("../../data/2024-10-24/P390 index sort Treg cell types_Final.xlsx") )

commoncols <- intersect( colnames(flow7), colnames(flow8))
newflow <- rbind(flow7[,commoncols],flow8[commoncols])
newflow$project <- newflow$Proj.Sub
### Read in the latest iteration of flow data
projects <- unique(newflow$Proj.Sub)
# Convert plate location to plate index from 1 to N
plateToIndex <- function(s){
  vals <- as.numeric( strsplit(s,",")[[1]] )
  return( sum(vals*c(12,1))+1)
}
newflow$index <- sapply(newflow$plate_location, plateToIndex)
newflow$projectIndex <- paste0(newflow$Proj.Sub, "_", newflow$index)
rownames(newflow) <- newflow$projectIndex
newflow <- newflow[order(newflow$project, newflow$index),]

projects <- unique(flow6$Proj.Sub)
flow6list <- lapply(projects, function(proj) flow6[ flow6$Proj.Sub == proj,])
names(flow6list) <- projects

subanno <- anno[ anno$project %in% newflow$project,]
subanno$stimPool <- "NA"
subanno <- subanno[ order(subanno$libid),]
subanno$libnum <- as.numeric( gsub("lib","", subanno$libid))
subanno$TNaive <- 0
newflow$libid <- NA
markerCols <- colnames(newflow)[ grepl("Geometric",colnames(newflow))]
subanno[,markerCols] <- NA
for( proj in unique(newflow$project) ){
  flown <- sum(newflow$project == proj)
  projn <- sum(subanno$project == proj)
  print( paste(proj,flown == projn,flown,projn) )
  if( flown == projn ){
    subanno$stimPool[ subanno$project == proj] <- newflow$Stim_pool[ newflow$project == proj]
    subanno$TNaive[ subanno$project == proj] <- newflow$TNaive[ newflow$project == proj]
    subanno[ subanno$project == proj, markerCols] <- newflow[ newflow$project == proj,markerCols]
    newflow$libid[ newflow$project == proj ] <- subanno$libid[ subanno$project == proj]
  }
  # The first cell in P390-31 was not collected in the flow data but it was in the other data.
  if( proj == "P390-31" ){
    subanno$stimPool[ subanno$libid != "lib87188" & subanno$project == proj] <- newflow$Stim_pool[ newflow$project == proj]
    subanno[ subanno$libid != "lib87188" & subanno$project == proj, markerCols] <- newflow[ newflow$project == proj,markerCols]

    newflow$libid[ newflow$project == proj ] <- subanno$libid[ subanno$libid != "lib87188" & subanno$project == proj]
  }
  if( proj == "P390-28" ){
    subanno$stimPool[ subanno$libnum <= 85622 & subanno$project == proj] <- "NA"
    subanno$stimPool[ subanno$libnum > 85622 & subanno$project == proj] <- newflow$Stim_pool[ newflow$project == proj]
    subanno[ subanno$libnum <= 85622 & subanno$project == proj, markerCols] <- "NA"
    subanno[ subanno$libnum > 85622 & subanno$project == proj, markerCols] <- newflow[ newflow$project == proj,markerCols]

    newflow$libid[ newflow$project == proj ] <- subanno$libid[ subanno$libnum > 85622 & subanno$project == proj]
  }
}
saveRDS(newflow,"TregTconvFlowDataCombined.RDS")
design[subanno$libid[ subanno$libid %in% design$libid],"stimPool"] <- subanno$stimPool[ subanno$libid %in% design$libid]
design[subanno$libid[ subanno$libid %in% design$libid],"TNaive"] <- subanno$TNaive[ subanno$libid %in% design$libid]
design$TNaive[ is.na(design$TNaive) ] <- 1

flowtab <- table( newflow$Proj.Sub )
rnatab <- table(anno$project)
projs <- intersect( names(flowtab), names(rnatab) )
diffprojs <- projs[ flowtab[projs] != rnatab[projs] ]
diffdf <- data.frame( project= diffprojs, flow=as.numeric(flowtab[diffprojs]), rna=as.numeric(rnatab[diffprojs]) )
print(diffdf)


stimBylibid <- design$stimPool
names( stimBylibid ) <- design$libid

```

```{r 02/20/24 More efficient way to get all pairs}

# TCRs is a dataframe that has a detected TCR chain for each row (alpha or beta or gamma, etc.) This is the output of mixcr, and maybe something analogous for 10x. But the columns might be named something different for 10x.
tcrs$trinity <- paste( tcrs$v_gene, tcrs$junction, tcrs$j_gene, sep="-")

combinePairs <- function( tcrDf ){
  a <- tcrDf[ tcrDf$chain %in% c("TRA","a"),]
  b <- tcrDf[ tcrDf$chain %in% c("TRB","b"),]
  commonlibs <- intersect( a$libid, b$libid ) # get libids that have both an alpha or beta chain
  a <- a[ a$libid %in% commonlibs,]; b <- b[ b$libid %in% commonlibs,]
  
  # Compute how many alpha/beta pairs there should be 
  atab <- table(a$libid)
  btab <- table(b$libid)
  nPairs <- sum( atab[commonlibs]*btab[commonlibs])
  
  # initialize the pairs data frame
  # here the column "sample" refers to libid, but it could refer to barcode in 10x data
  pairs <- data.frame( CDR3b = rep("",nPairs), CDR3bnt = rep("",nPairs), TRBV = rep("",nPairs), TRBJ = rep("",nPairs), CDR3a = rep("",nPairs), CDR3ant = rep("",nPairs), TRAV = rep("",nPairs), TRAJ = rep("",nPairs), sample = rep("",nPairs), trinitya=rep("",nPairs), trinityb = rep("",nPairs))
  
  # Iterate through the tcr alphas and betas and fill out the pair dataframe
  k=1
  for( lib in commonlibs ){
    arows = which( a$libid == lib )
    brows = which( b$libid == lib )
    for( i in arows ){
      for( j in brows ){
        pairs[k,] <- c( b$junction[j], b$full_nt_sequence[j], b$v_gene[j], b$j_gene[j], a$junction[i], a$full_nt_sequence[i], a$v_gene[i], a$j_gene[i],lib, a$trinity[i], b$trinity[j])
        k <- k+1
      }
    }
  }
  return(pairs)
}

pairs <- combinePairs( tcrs )
pairs$CDR3pair <- paste(pairs$CDR3ant,pairs$CDR3bnt)

```

```{r pair expansion}

sharedPairs <- pairs$CDR3pair[ duplicated(pairs$CDR3pair)]
sharedPairsAA <- paste( pairs$CDR3a[ pairs$CDR3pair %in% sharedPairs],pairs$CDR3b[ pairs$CDR3pair %in% sharedPairs])
sharedPairAlphas <- unique( pairs$CDR3a[ pairs$CDR3pair %in% sharedPairs])
sharedPairBetas <- unique( pairs$CDR3b[ pairs$CDR3pair %in% sharedPairs])

## get expanded pairs
pairs$sampleRepositoryID <- design[ pairs$sample, "sampleRepositoryID"]
pairs$pairDonor <- paste( pairs$CDR3ant, pairs$CDR3bnt, pairs$sampleRepositoryID )
expandedPairs <- unique( pairs$pairDonor[ duplicated( pairs$pairDonor)] )
expandedLibs <- pairs$sample[ pairs$pairDonor %in% expandedPairs]

design_qc$expanded <- design_qc$libid %in% expandedLibs

table(design_qc$sampleRepositoryID[design_qc$expanded], design_qc$studyGroup[design_qc$expanded])


pairs$shared <- pairs$CDR3pair %in% sharedPairs
pairs$StimPool <- stimBylibid[ pairs$sample]
pairs$project <- design[pairs$sample,"project"]

table(design[pairs$sample[pairs$shared],"project"])
expandedPairList <- list()
for(pp in sharedPairs){
  print(pp)
  print( table(design[pairs$sample[pairs$CDR3pair == pp],"project"]))
  
  rows <- pairs$sample[pairs$CDR3pair == pp]
  libs <- paste( unique(rows), collapse=",")
  stimPools <- paste( unique(stimBylibid[unique(rows)]),collapse=",")
  
  expandedPairList[[pp]] <- c(pair=pp,project=design[pairs$sample[pairs$CDR3pair == pp],"project"][1],numCells=sum(pairs$CDR3pair == pp), CDR3a = pairs[pairs$CDR3pair == pp,"CDR3a"][1], CDR3b = pairs[pairs$CDR3pair == pp,"CDR3b"][1], CDR3a_nt = pairs[pairs$CDR3pair == pp,"CDR3ant"][1], CDR3b_nt = pairs[pairs$CDR3pair == pp,"CDR3bnt"][1], libids = libs, StimPools = stimPools )
}
expandedPairList <- data.frame(do.call(rbind,expandedPairList))
rownames(expandedPairList) <- 1:nrow(expandedPairList)
write.table(expandedPairList[,c("project","numCells","libids","StimPools","CDR3a","CDR3b","CDR3a_nt","CDR3b_nt")],paste0("../../data/2021-09-02/expandedByNT.txt"),sep="\t",quote=FALSE,col.names=NA)




sharedList <- unique(pairs$sample[pairs$shared])
expandedList <- tcrs[tcrs$libid %in% sharedList,]
expandedList <- expandedList[ order(expandedList$full_nt_sequence),]

expandedList <- expandedList[ order(expandedList$junction,expandedList$full_nt_sequence),]

### Here the same thing but by V-CDR3-J
pairs$trinityPair <- paste(pairs$trinitya, pairs$trinityb, sep=" ")
sharedTrinities <- unique(pairs$trinityPair[ duplicated(pairs$trinityPair) ])
pairs$shared <- pairs$trinityPair %in% sharedTrinities

table(design[pairs$sample[pairs$shared],"project"])
sharedTrinityList <- list()
for(pp in sharedTrinities ){
  print(pp)
  print( table(design[pairs$sample[pairs$trinityPair == pp],"project"]))
  
  rows <- pairs$trinityPair %in% pp
  libs <- paste( unique(pairs[rows,"sample"]), collapse=",")
  sharedTrinityList[[pp]] <- c(pair=pp,project=design[pairs$sample[rows],"project"][1],numCells=sum(rows), CDR3a = pairs[rows,"CDR3a"][1], CDR3b = pairs[rows,"CDR3b"][1], CDR3a_nt = pairs[rows,"CDR3ant"][1], CDR3b_nt = pairs[rows,"CDR3bnt"][1], trinitya = pairs[rows,"trinitya"][1], trinityb = pairs[rows,"trinityb"][1],libids = libs )

}

sharedTrinityList <- data.frame(do.call(rbind,sharedTrinityList))
rownames(sharedTrinityList) <- 1:nrow(sharedTrinityList)

write.table(sharedTrinityList[,c("project","numCells","CDR3a","CDR3b","CDR3a_nt","CDR3b_nt", "trinitya","trinityb","libids")],paste0("../../data/2021-06-09/expandedByTrinity.txt"),sep="\t",quote=FALSE,col.names=NA)

### Here the same thing but by cdr3 only
pairs$junctionPair <- paste(pairs$CDR3a, pairs$CDR3b, sep=" ")
sharedJunctions <- unique(pairs$junctionPair[ duplicated(pairs$junctionPair) ])
pairs$shared <- pairs$junctionPair %in% sharedJunctions

table(design[pairs$sample[pairs$shared],"project"])
sharedJunctionList <- list()
for(pp in sharedJunctions ){
  print(pp)
  print( table(design[pairs$sample[pairs$junctionPair == pp],"project"]))
  
  rows <- pairs$junctionPair %in% pp
  libs <- paste( unique(pairs[rows,"sample"]), collapse=",")
  sharedJunctionList[[pp]] <- c(pair=pp,project=design[pairs$sample[rows],"project"][1],numCells=sum(rows), CDR3a = pairs[rows,"CDR3a"][1], CDR3b = pairs[rows,"CDR3b"][1],libids = libs )

}

sharedJunctionList <- data.frame(do.call(rbind,sharedJunctionList))
rownames(sharedJunctionList) <- 1:nrow(sharedJunctionList)


write.table(sharedJunctionList[,c("project","numCells","CDR3a","CDR3b","libids")],paste0("../../data/2021-06-09/expandedByAA.txt"),sep="\t",quote=FALSE,col.names=NA)

tcrs$StimPool <- stimBylibid[ tcrs$libid]
weirdlist <- sharedJunctionList$libids[ !grepl(",",sharedJunctionList$libids)]
weird <- tcrs[ tcrs$libid %in% weirdlist,]
weird <- weird[ order(weird$libid),]
```

```{r pair expansion circos plot to show treg and tconv sharing}


```

```{r sharing and circos plots, alpha and beta individually}

# Email from Karen with requests 11/14/21: 
# 3. Analysis: P390 TRA and TRB sharing circos plots showing Treg/Tconv and HC/T1D as the ring colors (not individual donors).
 
# 4. Analysis: circos plot of the P390 sharing with other projects.

tcrs$sampleRepositoryID[ tcrs$project == "P390-28"] <- "wb629062020"

make_colors <- function(values){
  cb_pal <- colorblind_pal()(8)
  numvals <- length(values)
  my_cb_pal <- colorRampPalette(cb_pal)(numvals)
  colorlist = c()
  for( i in 1:numvals ){
    colorlist[values[i]] <- my_cb_pal[i]
  }
  return(colorlist)
}

tcrs <- cbind( tcrs, anno[tcrs$libid, ! colnames(anno) %in% colnames(tcrs), ])
tcrs$CD4Type <- ifelse( grepl("CD25", tcrs$sort), "Treg", "Tconv")
tcrs <- tcrs[ order(tcrs$sort,tcrs$chain, tcrs$junction),]

assignClonotypeNumbers <- function( full_nts, prefix="c" ){
  tab <- table(full_nts)
  singletons <- names(tab)[ tab == 1 ]
  duplicates <- names(tab)[ tab > 1]
  
  dupclonotypes <- paste0(prefix,1:length(duplicates))
  names(dupclonotypes) <- duplicates
  singclonotypes <- rep("singleton",length(singletons))
  names(singclonotypes) <- singletons
  clonotypes <- c(singclonotypes,dupclonotypes)
  return( as.character(clonotypes[full_nts]))
}

tcrs$sampleRepositoryID[ is.na(tcrs$sampleRepositoryID)] <- tcrs$project[ is.na(tcrs$sampleRepositoryID)]
tcrs$studyGroup[ tcrs$studyGroup == "single cells "] <- "T1D"

tcrs <- tcrs[,!duplicated(colnames(tcrs))]

a <- tcrs[tcrs$chain == "TRA" & tcrs$libid %in% design$libid,]
b <- tcrs[tcrs$chain == "TRB" & tcrs$libid %in% design$libid,]
b$clonotypes <- assignClonotypeNumbers(b$full_nt_sequence,"b")
a$clonotypes <- assignClonotypeNumbers(a$full_nt_sequence,"a")

acloncols <- make_colors(a$clonotypes)
bcloncols <- make_colors(b$clonotypes)
sridcols <- make_colors(unique(tcrs$sampleRepositoryID))
t1dcols <- c("Control"="lightblue","T1D"="orange")

plotdir <- "../../data/2023-06-05/"

a <- a[order(a$sampleRepositoryID),]
#myGrapha <- makeTcrGraph(a[!a$libid %in% toFilter & a$clonotypes != "singleton",])
myGrapha <- makeTcrGraph(a[!a$libid %in% c(toFilter,iNKTMaitLibids),])
#myGrapha <- makeTcrGraph(a[!a$libid %in% toFilter,])
pdf(paste0(plotdir,"alpha_circos_t1dcontrol_mismatchesRemoved_byCD4Type_singletonsIncluded.pdf"),width=5,height=3)
makeCircos(
  myGrapha,
  annoFields = c("CD4Type","studyGroup","clonotypes"),
  #annoFields = c("CD4Type","sampleRepositoryID","clonotypes"),
  annoPalettes = list(
    # unnamed vectors of colors with the right length are allowed
    # named vectors of colors are also allowed
    CD4Type = c(Treg="blue",Tconv="red"),
    sampleRepositoryID=t1dcols,
    studyGroup= t1dcols,
    #project = c("P390-2"="grey","P390-1"="black","P390-3"="orange","P390-4"="brown","P390-5"="green","P390-6"="purple"),
    clonotypes = acloncols
  ),
  #sortField = "studyGroup",
  sortField = "CD4Type",

  title="Alpha Chains"
)
dev.off();

b <- b[order(b$sampleRepositoryID),]
#myGraphb <- makeTcrGraph(b[!b$libid %in% toFilter & b$clonotypes != "singleton",])
myGraphb <- makeTcrGraph(b[!b$libid %in% c(iNKTMaitLibids,toFilter),])
pdf(paste0(plotdir,"beta_circos_t1dcontrol_mismatchesRemoved_byCD4Type_singletonsIncluded.pdf"),width=5,height=3)
makeCircos(
  myGraphb,
  annoFields = c("CD4Type","studyGroup","clonotypes"),
  #annoFields = c("CD4Type","sampleRepositoryID","clonotypes"),
  annoPalettes = list(
    # unnamed vectors of colors with the right length are allowed
    # named vectors of colors are also allowed
    CD4Type = c(Treg="blue",Tconv="red"),
    sampleRepositoryID=t1dcols,
    studyGroup= t1dcols,
    #project = c("P390-2"="grey","P390-1"="black","P390-3"="orange","P390-4"="brown","P390-5"="green","P390-6"="purple"),
    clonotypes = bcloncols
  ),
  #sortField = "studyGroup",
  sortField = "CD4Type",
  title="Beta Chains"
)
dev.off()

myGrapha <- makeTcrGraph(a)
pdf(paste0(plotdir,"alpha_circos_t1dcontrol_mismatchesIncluded_byCD4Type.pdf"),width=5,height=3)
makeCircos(
  myGrapha,
  annoFields = c("CD4Type","studyGroup","clonotypes"),
  #annoFields = c("CD4Type","sampleRepositoryID","clonotypes"),
  annoPalettes = list(
    # unnamed vectors of colors with the right length are allowed
    # named vectors of colors are also allowed
    CD4Type = c(Treg="blue",Tconv="red"),
    sampleRepositoryID=t1dcols,
    studyGroup= t1dcols,
    #project = c("P390-2"="grey","P390-1"="black","P390-3"="orange","P390-4"="brown","P390-5"="green","P390-6"="purple"),
    clonotypes = acloncols
  ),
  #sortField = "studyGroup",
  sortField = "CD4Type",

  title="Alpha Chains"
)
dev.off(); 

b <- b[order(b$sampleRepositoryID),]
myGraphb <- makeTcrGraph(b)
pdf(paste0(plotdir,"beta_circos_t1dcontrol_mismatchesIncluded_byCD4Type.pdf"),width=5,height=3)
makeCircos(
  myGraphb,
  annoFields = c("CD4Type","studyGroup","clonotypes"),
  #annoFields = c("CD4Type","sampleRepositoryID","clonotypes"),
  annoPalettes = list(
    # unnamed vectors of colors with the right length are allowed
    # named vectors of colors are also allowed
    CD4Type = c(Treg="blue",Tconv="red"),
    sampleRepositoryID=t1dcols,
    studyGroup= t1dcols,
    #project = c("P390-2"="grey","P390-1"="black","P390-3"="orange","P390-4"="brown","P390-5"="green","P390-6"="purple"),
    clonotypes = acloncols
  ),
  #sortField = "studyGroup",
  sortField = "CD4Type",
  title="Beta Chains"
)
dev.off()

### Make circos plots
plotdir <- "../../data/2025-04-10/"
t1dcols <- c("Control"="lightblue","T1D"="orange")
for( chain in c("TRA","TRB") ){
  for( cd4type in c("Treg","Tconventional") ){
    libs <- soTconvs$libid
    if( cd4type == "Treg" ){ libs <- soTregs$libid}
    subtcrs <- tcrs[ tcrs$chain == chain & tcrs$libid %in% libs,]
    dups <- subtcrs$trinity[duplicated(subtcrs$trinity)]
    subtcrs <- subtcrs[subtcrs$trinity %in% dups,]
    print(paste(chain,cd4type,nrow(subtcrs)))

    pGraph <- makeTcrGraph( subtcrs, link="trinity" )
    # pdf(paste0(plotdir,chain,"Circos_",cd4type,"Sharing.pdf"),width=7,height=7)
    png(paste0(plotdir,chain,"Circos_",cd4type,"Sharing.png"),width=700,height=700)

    p <- makeCircos(
      pGraph,
      annoFields = c("studyGroup","donorID"),
      #annoFields = c("CD4Type","sampleRepositoryID","clonotypes"),
      annoPalettes = list(
        # unnamed vectors of colors with the right length are allowed
        # named vectors of colors are also allowed
        donorID=donorCols,
        studyGroup= t1dcols
        #project = c("P390-2"="grey","P390-1"="black","P390-3"="orange","P390-4"="brown","P390-5"="green","P390-6"="purple"),
        #clonotypes = pcloncols
      ),
      #sortField = "CD4Type",
      sortField = "studyGroup",
      arcColorField = "studyGroup",
      showLegend=FALSE,
      title= paste0( chain, " ", cd4type)
    )
    print(p)
    dev.off();
    
  }
}

pdf("../../data/2022-11-15/UMAP_colorBy_srid.pdf",width=7.5,height=5)
ggplot(cds_coords,aes(x=x,y=y, color=sampleRepositoryID)) + geom_point(size=0.7) + labs(x="UMAP 1",y="UMAP 2",color="Sample\nRepository\nID")
dev.off()

expandedNts <- tcrs$full_nt_sequence[ duplicated(tcrs$full_nt_sequence)]
tcrs$expanded <- ifelse( tcrs$full_nt_sequence %in% expandedNts, "expanded","singleton")

table(tcrs$expanded, tcrs$CD4Type)
expandedlibs <- unique(tcrs$libid[ tcrs$expanded == "expanded"])
tcrs$mismatchedRNAAndSort <- ifelse( tcrs$libid %in% mismatchedlibs, "mismatched","consistent")

# Find shared tcrs
tcrs$donorJunction <- paste0( tcrs$sampleRepositoryID, "_", tcrs$junction )
z <- tcrs[ ! tcrs$libid %in% iNKTMaitLibids, ]
z$mismatched <- z$libid %in% toFilter
z <- z[!duplicated(z$donorJunction),]
sharedJunctions <- z$junction[ duplicated(z$junction)]
tcrs$sharedJunction <- ifelse( tcrs$junction %in% sharedJunctions , "shared","unshared")

a <- tcrs[tcrs$chain == "TRA" & tcrs$libid %in% design$libid,]
b <- tcrs[tcrs$chain == "TRB" & tcrs$libid %in% design$libid,]
write.table(a,paste0(plotdir,"alphaTCRs.txt"),col.names=NA,quote=FALSE,sep="\t")
write.table(b,paste0(plotdir,"betaTCRs.txt"),col.names=NA,quote=FALSE,sep="\t")

tcrs$CD4Type <- design[ tcrs$libid,"cellType"]
tcrs$cellType <- design[ tcrs$libid,"cellType"]
tcrs$sort <- design[ tcrs$libid,"sort"]

sharedTCRs <- do.call(rbind, lapply( sharedJunctions, function(j) aggregateLibs( tcrs[tcrs$junction == j ,c("libid","project","chain","junction","v_gene","j_gene","CD4Type","sampleRepositoryID")] ) ))
write.table(sharedTCRs,paste0("../../results/sharedTCRs.txt"),col.names=NA,quote=FALSE,sep="\t")
#write.table(tcrs[ tcrs$expanded == "expanded",],paste0(plotdir,"expandedTCRs.txt"),col.names=NA,quote=FALSE,sep="\t")


collapseCols <- function(d){
  vals <- apply(d,2, function(v) paste(unique(v),collapse=","))
  return(vals)
}
aggregateLibs <- function( df ){
  subdf <- df[,colnames(df) != "full_nt_sequence"]
  n <- nrow(subdf)
  vals <- collapseCols( subdf )
  df <- df[1,]
  df[, names(vals)] <- vals
  df$count <- n
  return(df)
}

iNKTMaitLibids <- unique(c( MAIT_summary$libid, iNKT_summary$libid))
subtcrs <- tcrs[ tcrs$expanded == "expanded" & ! tcrs$libid %in% c(toFilter,iNKTMaitLibids), c("full_nt_sequence","CD4Type","junction","project","studyGroup","libid","sampleRepositoryID")]
subtcrs$donorNt <- paste( subtcrs$sampleRepositoryID, subtcrs$full_nt_sequence)
dnts <- unique(subtcrs$donorNt)
z <- do.call(rbind,lapply(dnts, function(nt) aggregateLibs(subtcrs[ subtcrs$donorNt == nt,] ) ))
z <- z[ z$count > 1,]
write.table(z,paste0("../../results/expandedTCRs.txt"),col.names=NA,quote=FALSE,sep="\t")



df <- tcrs[ !duplicated(tcrs$full_nt_sequence),]
df$anno <- paste( df$shared, df$expanded)
df <- df[ !df$anno == "unshared singleton",]
df$anno <- gsub(" singleton","",gsub("unshared ","",df$anno))
ggplot(df, aes(x=anno,fill=anno)) + geom_bar( stat="count") + scale_fill_manual( values=c("shared expanded"="purple","shared"="blue","expanded"="red")) + labs(x="",title="shared and expanded TCRs", fill="") + facet_wrap(~chain)  + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


### Find sharing between Treg and Tconv
tregTconvSharing <- function(d, mismatchedlibs = c()){
  d <- d[ ! d$libid %in% mismatchedlibs,]
  clons <- unique(d$clonotypes[d$clonotypes != "singleton"])
  tregtconv <- unique(clons[sapply(clons, function(clon) length(unique(d$CD4Type[ d$clonotypes == clon ]))>1)])
  return(tregtconv)
}

### Find sharing between Treg and Tconv
tregTconvSharingNt <- function(d, mismatchedlibs = c(), sameDonor=TRUE){
  d <- d[!d$libid %in% mismatchedlibs,]
  print(length(unique(mismatchedlibs)))
  if(sameDonor){
    d$full_nt_sequence <- paste(d$full_nt_sequence, d$sampleRepositoryID)
  }
  nts <- unique(d$full_nt_sequence[ duplicated(d$full_nt_sequence)])
  tregtconv <- unique(nts[sapply(nts, function(nt) length(unique(d$CD4Type[ d$full_nt_sequence == nt ]))>1)])
  return(tregtconv)
}

seuratMismatchedLibs <- unique( so$libid[ so$mismatched == "mismatched"] )
ashared <- tregTconvSharing(a,seuratMismatchedLibs)
bshared <- tregTconvSharing(b,seuratMismatchedLibs)
a <- a[order(a$clonotypes),]
b <- b[order(b$clonotypes),]
rownames(design) <- design$libid
a$stimPool <- design[a$libid,"stimPool"]
b$stimPool <- design[b$libid,"stimPool"]

plotdir <- "../../data/2025-01-10/"
write.table(a[a$clonotypes %in% ashared,],paste0(plotdir,"alphaJunctions_tregTconvShared.txt"),col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")
write.table(b[ b$clonotypes %in% bshared,],paste0(plotdir,"betaJunctions_tregTconvShared.txt"),col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")

ashared <- tregTconvSharingNt(a,c(iNKTMaitLibids,toFilter), sameDonor=TRUE)
bshared <- tregTconvSharingNt(b,c(iNKTMaitLibids,toFilter), sameDonor=TRUE)
ashared <- tregTconvSharingNt(a,c(iNKTMaitLibids,toFilter), sameDonor=FALSE)
bshared <- tregTconvSharingNt(b,c(iNKTMaitLibids,toFilter), sameDonor=FALSE)

### Are these TCRs in cells whose phenotypes don't match their supposed sort assignment?
#cds_coords <- readRDS("../2021-03-16/P390_cds_coords.RDS")


cds_coords$miscluster <- FALSE
cds_coords$miscluster[ cds_coords$cellType == "Treg" & ! cds_coords$cluster %in% tregClusters] <- TRUE
cds_coords$miscluster[ cds_coords$cellType %in% c("Tconventional","Tscm") & cds_coords$cluster %in% tregClusters ] <- TRUE
mismatchedlibs <- cds_coords$libid[ cds_coords$miscluster]



asharedlibs <- unique( a$libid[ a$clonotypes %in% ashared ] )
bsharedlibs <- unique( b$libid[ b$clonotypes %in% bshared ] )
mismatchedlibs <- cds_coords$libid[ cds_coords$miscluster]
problemlibs <- unique( mismatchedlibs[ mismatchedlibs %in% c(asharedlibs,bsharedlibs)] )

###
df <- data.frame( libid = unique(tcrs$libid))
df$detected <- rep( "neither", nrow(df) )
df$detected[ df$libid %in% a$libid ] <- "alpha only"
df$detected[ df$libid %in% b$libid ] <- "beta only"
df$detected[ df$libid %in% b$libid & df$libid %in% a$libid] <- "both"
df <- cbind(df, design[ df$libid, ! colnames(design) %in% colnames(df)])

tcrTab <- table(df$detected, df$CD4Type)
write.table(tcrTab, paste0(plotdir,"tcrDetectionTable.txt"),quote=FALSE,col.names=NA,sep="\t")


ggplot(df,aes(x=CD4Type,fill=detected) ) + geom_bar(stat="count") + scale_fill_manual(values=c("both"="purple","alpha only"="red","beta only"="blue"))

```

```{r within patient sharing by AA "expansion"}
tcrs$projAa <- paste0(tcrs$project, ".", tcrs$junction)
exJunction <- tcrs$projAa [ duplicated(tcrs$projAa )]
tcrs$expandedAa <- tcrs$projAa  %in% exJunction

tcrs <- tcrs[order(tcrs$projAa ),]
exAa <- tcrs[ tcrs$expandedAa,]


# By projAa
combineInfo <- function(pa){
  sub <- exAa[ exAa$projAa == pa,]
  r <- data.frame(sub[1,])
  r$libid <- paste( sub$libid, collapse=",")
  r$sampleLocation <- paste( sub$sampleLocation, collapse=",")
  r$sampleWell <- paste( sub$sampleWell, collapse=",")
  r$stimPool <- paste( unique(sub$stimPool), collapse=",")
  r$numberDetected <- nrow(sub)
  return(r)
}

z <- do.call(rbind,lapply(unique(exAa$projAa),combineInfo))

write.table(z,"../../data/2021-09-02/expandedWithinProjectsByAa.txt",sep="\t",quote=FALSE,col.names=NA)

```

```{r Sharing between donors in Tregs}
# From Karen 06/18/23 I’m wondering if there is sharing between donors of TRA or TRB chains amongst Treg cells in the Circos plots. I ask because it looks like the donors are intermixed (I’m assuming the inner ring is donor, correct)? Can you clarify please.

tcrs$donorNuc <- paste0( tcrs$sampleRepositoryID, "_", tcrs$full_nt_sequence)
tcrs$donorJunction<- paste0( tcrs$sampleRepositoryID, "_", tcrs$junction)

tregTcrs <- tcrs[ ! tcrs$libid %in% c(toFilter, iNKTMaitLibids) & tcrs$CD4Type == "Treg",]
subt <- tregTcrs[ ! duplicated(tregTcrs$donorJunction),]
sharedJunctions <- unique( subt$junction[ duplicated( subt$junction)] )

collapseCols <- function(d){
  vals <- apply(d,2, function(v) paste(unique(v),collapse=","))
  return(vals)
}
aggregateLibs <- function( df ){
  subdf <- df[,colnames(df) != "junction"]
  n <- nrow(subdf)
  vals <- collapseCols( subdf )
  df <- df[1,]
  df[, names(vals)] <- vals
  df$count <- n
  return(df)
}
sharedDf <- do.call(rbind, lapply( sharedJunctions, function(j) aggregateLibs( tcrs[tcrs$junction == j ,c("libid","project","chain","junction","v_gene","j_gene","CD4Type","sampleRepositoryID","studyGroup")] ) ))
write.table(sharedDf,"../../results/sharedTregJunctions.txt",quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)

```

```{r Is inter-project sharing different between disease states? Cell type? }

subtcrs <- tcrs[ !tcrs$libid %in% c(toFilter, iNKTMaitLibids), ]

getDonorSharingProp <- function( srid ){
  l <- list()
  l[["Treg_TRA"]] <- subtcrs[ subtcrs$CD4Type == "Treg" & subtcrs$chain == "TRA" & subtcrs$sampleRepositoryID == srid,]
  l[["Treg_TRB"]] <- subtcrs[ subtcrs$CD4Type == "Treg" & subtcrs$chain == "TRB" & subtcrs$sampleRepositoryID == srid,]
  l[["Tconv_TRA"]] <- subtcrs[ subtcrs$CD4Type == "Tconv" & subtcrs$chain == "TRA" & subtcrs$sampleRepositoryID == srid,]
  l[["Tconv_TRB"]] <- subtcrs[ subtcrs$CD4Type == "Tconv" & subtcrs$chain == "TRB" & subtcrs$sampleRepositoryID == srid,]
  props <- sapply(l, function(s) mean( s$junction %in% commonJunctions))
  return(props)
}

srids <- unique(subtcrs$sampleRepositoryID)
sharedProps <- data.frame( t(sapply( srids, getDonorSharingProp)) )
sharedProps$srid <- rownames(sharedProps)
sharedProps$studyGroup <- designBySrid[ sharedProps$srid,"studyGroup"]

sharedPropsLong <- reshape2::melt(sharedProps, id.vars=c("srid","studyGroup"))
colnames(sharedPropsLong) <- c("srid","studyGroup","variable","proportion")
sharedPropsLong[,c("CD4Type","chain")] <- t(sapply( as.character(sharedPropsLong$variable), function(s) strsplit(s,"_")[[1]]))

ggplot(sharedPropsLong, aes(x=CD4Type,y=proportion, color=studyGroup, group=srid)) + geom_boxplot(aes(group=CD4Type),color="black") + geom_line() + geom_point() + facet_wrap(~chain)

### Here do it subsampled

getSharingSubsampled <- function( srid, chain="TRA", N=500, trinity=FALSE){
  print( paste(srid,chain,N))
  # Is there more within-Treg sharing the within-T-conventional Sharing?
  tconva <- tcrs[ tcrs$CD4Type == "Tconv" & tcrs$chain == chain & tcrs$sampleRepositoryID==srid & ! tcrs$libid %in% c(toFilter,iNKTMaitLibids),] 
  trega <- tcrs[ tcrs$CD4Type == "Treg" & tcrs$chain == chain & tcrs$sampleRepositoryID==srid & ! tcrs$libid %in% c(toFilter,iNKTMaitLibids),]

  if(trinity){
    convashared <- commonTrinitys
    regashared <- commonTrinitys
    tconva$junction <- tconva$trinity
    trega$junction <- trega$trinity
  } else{
    convashared <- commonJunctions
    regashared <- commonJunctions
    convshared <- sum(tconva$junction %in% convashared)/nrow(tconva)
    regshared <- sum(trega$junction %in% regashared)/nrow(trega)
  }

  convshared <- sum(tconva$junction %in% convashared)/nrow(tconva)
  regshared <- sum(trega$junction %in% regashared)/nrow(trega)
  
  if( nrow(tconva) > nrow(trega ) ){
    n1 <- nrow(trega)
    n2 <- nrow(tconva)
    samples <- lapply( 1:N, function(i) tconva[sample(1:n2,n1),] )
    #convashared <- sapply( samples, function(l) unique( l$junction[ duplicated(l$junction)]))
    convshared <- mean(sapply( 1:N, function(i) sum( samples[[i]]$junction %in% convashared)/nrow( samples[[i]]) ))
  }
    if( nrow(trega) > nrow(tconva) ){
    n1 <- nrow(tconva)
    n2 <- nrow(trega)
    samples <- lapply( 1:N, function(i) trega[sample(1:n2,n1),] )
    regashared <- sapply( samples, function(l) unique( l$junction[ duplicated(l$junction)]))
    regshared <- mean(sapply( 1:N, function(i) sum( samples[[i]]$junction %in% regashared)/nrow( samples[[i]]) ))
  }
  v <- c(sharedTconventionalProportion=convshared, sharedTregProportion=regshared)
  return(v)
}
sharedStatsA <-  data.frame(t(sapply( srids, function(srid) getSharingSubsampled(srid,"TRA",trinity=TRUE)  )))
sharedStatsA$chain <- "TRA"
sharedStatsB <-  data.frame(t(sapply( srids, function(srid) getSharingSubsampled(srid,"TRB",trinity=TRUE)  )))
sharedStatsB$chain <- "TRB"
sharedStats <- rbind(sharedStatsA, sharedStatsB)
sharedStats$srid <- c(srids,srids)


sharedStats$studyGroup <- sridDf[srids,"studyGroup"]
sharedStats$studyGroup[ sharedStats$srid == "P390-34"] <- "T1D"
sharedStats$log2FoldDifference <- log2((sharedStats$sharedTregProportion+0.01)/ (sharedStats$sharedTconventionalProportion+0.01))

diffs <- sharedStats$sharedTconventionalProportion-sharedStats$sharedTregProportion
diffs <- diffs[!is.na(diffs)]

ix <- sharedStats$chain == "TRA"
diffs <- sharedStats$sharedTconventionalProportion[ix]-sharedStats$sharedTregProportion[ix]
diffs <- diffs[!is.na(diffs)]
pvala <- t.test(diffs)$p.value

print( "paired")
print( t.test(diffs)$p.value )
print("unpaired")
print( t.test(sharedStats$sharedTconventionalProportion[ix],sharedStats$sharedTregProportion[ix])$p.value)

ix <- sharedStats$chain == "TRB"
diffs <- sharedStats$sharedTconventionalProportion[ix]-sharedStats$sharedTregProportion[ix]
diffs <- diffs[!is.na(diffs)]
pvalb <- t.test(diffs)$p.value

print( "paired")
print( t.test(diffs)$p.value )
print("unpaired")
print( t.test(sharedStats$sharedTconventionalProportion[ix],sharedStats$sharedTregProportion[ix])$p.value)

sharedStatsLong <- reshape2::melt(sharedStats[,c("srid","studyGroup","chain","sharedTconventionalProportion","sharedTregProportion")], id.vars=c("srid","studyGroup","chain"))
colnames(sharedStatsLong) <- c("srid","studyGroup","chain","CD4Type","proportion")
sharedStatsLong$CD4Type <- ifelse(sharedStatsLong$CD4Type == "sharedTconventionalProportion","Tconv","Treg")
png("../../data/2023-06-05/sharedTrinityProportion_P390P91P168P474_Subsampled_boxplots.png",width=800,height=800)
sharedStatsLong$chainAnno <- ifelse(sharedStatsLong$chain == "TRA", paste0("TRA\np-value: ",round(pvala,4)), paste0("TRB\np-value: ",round(pvalb,4)))
ggplot(sharedStatsLong,aes(x=CD4Type,y=proportion,color=studyGroup)) + geom_boxplot(color="grey",outlier.color=NA) + geom_point() + geom_line( aes(group=srid)) + labs(x="CD4 Type",y="proportion with shared V-junction-J", color="",title="Shared V-junction-J Proportions\nSubsampled to match Tconv and\nTreg numbers per donor") + facet_wrap(~chainAnno)
dev.off()


t.test(sharedStatsLong$proportion[])

```

```{r set_up_qc_parameters, fig.width=4, fig.height=3}
#Set QC cuts
align_cut = 80
total_reads_cut = 1
median_cv_cut = 1


#Get a colorblind palette
cb_pal <- colorblind_pal()(8)
cb_pal <- cb_pal[2:8]
my_cb_pal <- colorRampPalette(cb_pal)(length(unique(design$Sample.Id)))
```

RNA-seq Quality Metrics
------

In performing quality control, the following three metrics are examined:

1. The total number of reads in each library (libraries with less than 1 million reads are suspect for bulk). For single cell, we expect: ????   
2. The percent alignment of each library (higher is better)   
3. Median CV coverage. This is the the median coefficient of variation of coverage of the 1000 most highly expressed transcripts. It measures read bias along the transcript. Ideally, this value would be 0.

A histogram plotting the number of reads in P143 libraries is follows. The target number of reads for a bulk library is ~5 million. Many of these libraries have fewer than 1 million reads, which is unfortunate and may be too small to analyze properly. 

```{r qcplots_total_reads, fig.width=4, fig.height=3}
liborder <- design$libid[ order( design$fastq_total_reads, decreasing=TRUE ) ]

design$CD4Type <- ifelse( grepl("CD25", design$sort), "Treg", "Tconv")
design$pnum <- as.numeric( sapply( design$project, function(s) strsplit(s,"-")[[1]][2]))

pdf( paste0(plotdir,"coverage.pdf"),width=5,height=4)
ggplot(design, aes(x=libid, y=fastq_total_reads/10^6, fill=CD4Type)) + 
      geom_col() +
      labs(y = "millions of reads", title="Coverage") +
      geom_hline(yintercept = total_reads_cut, linetype = 4) +
      theme(text = element_text(size=16)) + 
      theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) + 
      scale_x_discrete(limits = liborder) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) 
invisible(dev.off())

ggplot(design, aes(x=libid, y=fastq_total_reads/10^6, fill=project)) + 
      geom_col() +
      labs(y = "millions of reads", title="Coverage") +
      geom_hline(yintercept = total_reads_cut, linetype = 4) +
      theme(text = element_text(size=16)) + 
      theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) + 
      scale_x_discrete(limits = liborder) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) + scale_fill_manual(values=c("grey","red","blue","orange"))

```

The following plots compare the median CV of coverage and the percent alignment of reads in each library. High quality libraries will fall in the upper left quadrant of the box (high percent alignment and low median CV coverage). 

There is a large number of low-quality samples defined by low percent alignment and high median cv coverage, and most of these samples come from patient 31. However, there is a cluster of patient 33 cells that also have high median cv coverage and low percent alignment. Plotting the same libraries with total reads on the Y-axis shows that the patient 33 cells with low alignment are the same cells that have very low read counts.

```{r qcplots_coverage_vs_alignment, fig.width=4, fig.height=3, results='hide'}

design$CD4Type <- ifelse( grepl("CD25", design$sort), "Treg","Tconv")
g <- ggplot(design, aes(x=median_cv_coverage, y=pct_aligned, color=CD4Type) ) + 
  geom_point(size=1, alpha=1.0) + 
  labs(x = "median cv coverage", y = "percent alignment", color ="sort")+
  geom_hline(yintercept =  align_cut)+
  geom_vline(xintercept =  median_cv_cut)+
  theme(text = element_text(size=12)) 

print(g+facet_wrap(~project))

ggplot(design[design$donorID == "CerosalettiLab839987",], aes(x=as.numeric(median_cv_coverage), y=pct_aligned, color=project) ) + 
  geom_point(size=1, alpha=1.0) + 
  labs(x = "median cv coverage", y = "percent alignment", color ="project", title="CerosalettiLab839987 Percent Alignment\nAnd Median CV Coverage")+
  geom_hline(yintercept =  align_cut,linetype="dashed")+
  geom_vline(xintercept =  median_cv_cut,linetype="dashed")+
  theme(text = element_text(size=12)) 

pdf(paste(plotdir,"QC_coverage_vs_alignment3.pdf",sep=""), height =4, width = 5)
print(g+facet_wrap(~project))
invisible(dev.off())

```

```{r make_qc_cuts}
design$qc_pass <- design$fastq_total_reads > total_reads_cut &
                  design$pct_aligned > align_cut &
                  design$median_cv_coverage < median_cv_cut
                  

design_qc <- design[design$qc_pass == TRUE,]
rownames(design_qc) <- design_qc$libid
counts_qc <- counts[,colnames(counts) %in% design_qc$libid]

```

```{r geneFiltering}
#Get protein coding genes with HGNC symbols
gene_key <- read.table("../../../data/EnsemblToHGNC_GRCh38.txt", header = TRUE,sep = "\t",na.strings = "") 
genes_hgnc <- gene_key[!is.na(gene_key$HGNC.symbol),]

counts_hgnc <- counts_qc[rownames(counts_qc) %in% genes_hgnc$Ensembl.Gene.ID,]

genes_pc <- subset(genes_hgnc, genes_hgnc$Gene.type == "protein_coding") #21119
genes_pc <- genes_pc[!duplicated(genes_pc$Ensembl.Gene.ID),] #remove duplicated ensembl genes #21117
counts_pc <- merge(genes_pc, counts_qc, by.x="Ensembl.Gene.ID", by.y ="row.names")
gene_key_pc <- counts_pc[,1:3] #First three columns contain annotation information
#counts_pc <- counts_pc[,4:97] #The remaining columns contain counts information 
counts_pc <- counts_pc[,4:ncol(counts_pc),] #The remaining columns contain counts information \
rownames(counts_pc) <- gene_key_pc[,1]

ens2hgnc <- gene_key[!duplicated(gene_key$Ensembl.Gene.ID),"HGNC.symbol"]
names(ens2hgnc) <- gene_key[!duplicated(gene_key$Ensembl.Gene.ID),"Ensembl.Gene.ID"]
ens2hgnc <- ens2hgnc[ !is.na(ens2hgnc)]

#Define a function to filter out lowly expressed genes
gene_filter <- function(counts_in, per_cutoff){
  #Keep genes with cpm of at least one in at least per_cutoff fraction of libraries
  #CPM normalize
  counts_cpm_norm <- as.data.frame(t(t(counts_in*10^6)/colSums(counts_in)))
  
  #Filter out lowly expressed genes
  keepRows <- rowSums((counts_cpm_norm) >= 1) >= per_cutoff*ncol(counts_cpm_norm)
  counts_filtered <- counts_in[keepRows,]
  
  return(counts_filtered)
  
}

#Run function to filter lowly expressed genes
counts_pc_filtered <- gene_filter(counts_pc, 0.10)

normalize_counts <- function(counts_in, method){
  #normalize using tmm or deconvolution
  #tmm is good for bulk RNAseq
  #deconvolution is best for large datasets of single cell RNAseq
  #deconvolution is NOT recommended for smaller datasets (less than a few hundred cells)
  
  if(method == "decon"){
  #Normalize using the deconvolution algorithm
  decon_norm_factors <- calculateSumFactors(as.matrix(counts_in))
  counts_norm <- as.data.frame(t(t(counts_in)/decon_norm_factors))
  }
  
  if(method == "tmm"){
  #Normalize using the TMM algorithm 
  dge <- DGEList(counts_in)
  dge <- calcNormFactors(dge)
  counts_norm <- cpm(dge, normalized.lib.sizes=TRUE)
  }
  
  return(counts_norm)
  
}

#counts_pc_norm <- normalize_counts(counts_pc_filtered, "decon")
counts_pc_norm <- normalize_counts(counts_pc[rowSums(counts_pc)>0,], "decon")
counts_pc_norm_filtered <- normalize_counts(counts_pc_filtered, "decon")


dge <- DGEList(counts=counts_pc_norm, genes=ens2hgnc[rownames(counts_pc_norm)])

```


Gene Filtering
------
A filter is applied to keep only genes with HGNC symbols that have been annotated as protein coding. This keeps `r nrow(genes_pc)` of 64345 genes. A second filter that selects genes with a count of at least one in 10% of libraries is also applied. This keeps `r nrow(counts_pc_filtered)` of the `r nrow(genes_pc)` genes from the first filter. The selected genes are normalized using the TMM (trimmed mean of M values) algorithm.


Principal Component Analysis
------
Principal component analysis (PCA) looks for broad trends in gene expression across libraries in an unsupervised manner. There is no obviously apparent structure in PCA space, and the amount of variation described by the first two principal components is low, suggesting that there may be no single major overwhelming source of variation (like a batch effect) in the data. 

```{r pca, fig.width=4, fig.height=3}
#Run PCA on the normalized log2 transformed counts data

dat <- log2(as.data.frame(t(dge$counts))+0.5)
pca = prcomp(dat, center=TRUE, scale=FALSE)
#Get PCA resutls and merge with sample information stored in metrics
sum_pca = summary(pca)
pca_scores= as.data.frame(pca$x)
pdatscores <- merge(design_qc, pca_scores, by.x = "libid", by.y="row.names")
pc1_lab = paste("PC1 (", round(100*sum_pca$importance[2, 1], 1),  "%)", sep="")
pc2_lab = paste("PC2 (", round(100*sum_pca$importance[2, 2], 1),  "%)", sep="")
pc3_lab = paste("PC3 (", round(100*sum_pca$importance[2, 3], 1),  "%)", sep="")
pc4_lab = paste("PC4 (", round(100*sum_pca$importance[2, 4], 1),  "%)", sep="")
pc5_lab = paste("PC5 (", round(100*sum_pca$importance[2, 5], 1),  "%)", sep="")
pc6_lab = paste("PC6 (", round(100*sum_pca$importance[2, 6], 1),  "%)", sep="")
pc3genes <- colnames(dat)[order( -1*abs(pca$rotation[,3]) )[1:75]] 

png(paste0(plotdir,"pca_sort.png"),width=600,height=400)
ggplot(pdatscores,aes(x=PC1,y=PC2,color=CD4Type)) + geom_point() 
dev.off()

make_colors <- function(values,ncols=8){
  cb_pal <- colorblind_pal()(ncols)
  numvals <- length(values)
  my_cb_pal <- colorRampPalette(cb_pal)(numvals)
  colorlist = c()
  for( i in 1:numvals ){
    colorlist[values[i]] <- my_cb_pal[i]
  }
  return(colorlist)
}

png(paste(plotdir,"PCA_PC1_PC2_stimulation.png",sep=""), height=400, width=600)
ggplot() + 
  geom_point(data=pdatscores, aes(x=PC1, y=PC2, color = sample.stimulation, shape= as.factor(Visit.Number.Descriptor) ), size=1.5)+
  labs(x = pc1_lab, y = pc2_lab)+
  theme(text = element_text(size=12))
dev.off()

png(paste(plotdir,"PCA_PC1_PC2_timepoint.png",sep=""), height=400, width=600)
ggplot() + 
  geom_point(data=pdatscores, aes(x=PC1, y=PC2, color = as.factor(Visit.Number.Descriptor), shape= sample.stimulation), size=1.5)+
  labs(x = pc1_lab, y = pc2_lab)+
  theme(text = element_text(size=12))
dev.off()


p1 <- ggplot() + 
  geom_point(data=pdatscores, aes(x=PC1, y=PC2, color = sample.stimulation ), size=1.5)+
  labs(x = pc1_lab, y = pc2_lab, color="Stimulant")+
  theme(text = element_text(size=12))

p2 <- ggplot() + 
  geom_point(data=pdatscores, aes(x=PC3, y=PC4, color = sample.stimulation ), size=1.5)+
  labs(x = pc3_lab, y = pc4_lab, color="Stimulant")+
  theme(text = element_text(size=12))

p3 <- ggplot() + 
  geom_point(data=pdatscores, aes(x=PC1, y=PC2, color = as.factor(Visit.Number.Descriptor)  ), size=1.5)+
  labs(x = pc1_lab, y = pc2_lab, color="Study Group")+
  theme(text = element_text(size=12))

p4 <- ggplot() + 
  geom_point(data=pdatscores, aes(x=PC3, y=PC4, color = as.factor(Visit.Number.Descriptor) ), size=1.5)+
  labs(x = pc3_lab, y = pc4_lab, color="Study Group")+
  theme(text = element_text(size=12))

pushViewport(viewport(layout = grid.layout(2 , 2)))
vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)
print(p1, vp = vplayout(1,1)) 
print(p2, vp = vplayout(1,2))
print(p3, vp = vplayout(2,1)) 
print(p4, vp = vplayout(2,2))

ggplot() + 
  geom_point(data=pdatscores, aes(x=PC1, y=PC3, color = sample.stimulation ), size=1.5)+
  labs(x = pc1_lab, y = pc3_lab, color="Study Group")+
  theme(text = element_text(size=12))

ggplot() + 
  geom_point(data=pdatscores, aes(x=PC1, y=PC2, color = MEDIAN_CV_COVERAGE), size=1.5)+
  labs(x = pc1_lab, y = pc2_lab)+
  theme(text = element_text(size=12))

ggplot() + 
  geom_point(data=pdatscores, aes(x=PC1, y=PC2, color = fastq_total_reads), size=1.5)+
  labs(x = pc1_lab, y = pc2_lab)+
  theme(text = element_text(size=12))

ggplot() + 
  geom_point(data=pdatscores, aes(x=PC1, y=PC2, color = mapped_reads_w_dups), size=1.5)+
  labs(x = pc1_lab, y = pc2_lab)+
  theme(text = element_text(size=12))


```

```{r volcano}

limma_volcano <- function( gtable, outfile=""  ){
  p_cutoff = 0.05
  fc_cutoff = 1.0
  #png(outfile, height = 600, width = 900)
  p <- ggplot(data = gtable, aes(x=logFC, y=-log10(adj.P.Val), color = logFC>0)) +
    geom_point(size=1.5, shape = 19) + scale_color_manual(values = c("orange", "red"))+
    theme(legend.position = "none") + xlab("logFC") + ylab("-log10 FDR")+
    geom_hline(yintercept=-log10(p_cutoff), color="black",linetype="dotted",size=1.0)+
    geom_vline(xintercept=-fc_cutoff, color="black",linetype="dotted",size=1.0)+
    geom_vline(xintercept=fc_cutoff, color="black",linetype="dotted",size=1.0)+
    theme(text = element_text(size=16)) + 
    geom_text_repel(data=gtable[1:50,], aes(logFC, -log10(adj.P.Val), fontface="bold", label=HGNC.symbol), size=4, color="black") 
  print(p)
  #dev.off()
  return(p)
}

p <- limma_volcano( comparisons_ageseason[[1]])
p <- limma_volcano( comparisons_ageseason[[2]])
```

```{r Pseudobulk for Treg vs Tconv}

### Plot bar graph of cell counts
design_qc$x <- paste0(design_qc$donorId, "_", design_qc$CD4Type)
ggplot(design_qc, aes(x=x,fill=CD4Type)) + geom_histogram(stat='count') + facet_wrap(~studyGroup, scales="free_x") + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),legend.position="bottom") + labs(title="High Quality Cell Counts\nby Donor and Sort")


# Heat map of DEGs between Treg and Tconv with the new Seurat clustering
commoncols <- intersect( colnames(soTregs@meta.data ), colnames(soTconvs@meta.data)  )
combinedDf <- rbind( soTregs@meta.data[,commoncols], soTconvs@meta.data[,commoncols])
combinedDf$cluster <- paste0( ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"), "_", as.character( combinedDf$seurat_clusters ) )
combinedDf$donorId <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$donorID <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$donorType <- paste0( combinedDf$donorID, "_",combinedDf$cellType)
df <- combinedDf; df$group <- df$donorType
groups <- unique(df$group)

# libsByGroup <- lapply( groups, function(g) df$libid[ df$ donorType==g & ! df$libid %in% c(toFilter,iNKTMaitLibids)])
libsByGroup <- lapply( groups, function(g) df$libid[ df$ donorType==g ])
names(libsByGroup) <- groups

libs <- unique( do.call(c,libsByGroup))

bulk <- data.frame(sapply( libsByGroup, function(libs) rowSums(counts_pc[,libs]) ))
g <- rownames(counts_pc)[ rowMeans(counts_pc[,df$libid]>0) >= 0.3]
# g <- rownames(bulk_pc_norm)[rowMeans(bulk_pc_norm > 0) >= 0.1]
bulk_pc_norm <- bulk_pc_norm[g,]
bulk <- bulk[g,]
# Combine project P214-24 into project P214-17


normalize_counts <- function(counts_in, method){
  #normalize using tmm or deconvolution
  #tmm is good for bulk RNAseq
  #deconvolution is best for large datasets of single cell RNAseq
  #deconvolution is NOT recommended for smaller datasets (less than a few hundred cells)
  
  if(method == "decon"){
  #Normalize using the deconvolution algorithm
  decon_norm_factors <- computeSumFactors(as.matrix(counts_in))
  counts_norm <- as.data.frame(t(t(counts_in)/decon_norm_factors))
  }
  
  if(method == "tmm"){
  #Normalize using the TMM algorithm 
  dge <- DGEList(counts_in)
  dge <- calcNormFactors(dge)
  counts_norm <- edgeR::cpm(dge, normalized.lib.sizes=TRUE)
  }
  return(counts_norm)
}

idByProj <- design$sampleRepositoryID[ !duplicated( design$project)]
names(idByProj) <- design$project[ !duplicated( design$project)]


bulk_pc_norm <- normalize_counts(bulk[g,],"tmm")
designBulk <- data.frame( t(sapply(colnames(bulk_pc_norm), function(s) strsplit(s,"_")[[1]])) )
colnames(designBulk) <- c("srid","type")

#design_mat <- model.matrix(~0+id+FOXP3+cdr+group,data=designByProject)
design_mat <- model.matrix(~srid+type,data=designBulk)
colnames(design_mat) <- gsub("srid","",gsub("type","",colnames(design_mat)))
vwts <- voomWithQualityWeights(bulk_pc_norm[ ,rownames(design_mat)], design= design_mat, plot=T, span=0.1)
vfit <- lmFit(vwts, design = design_mat)
vfit_eb <- eBayes(vfit)

tregDE <- topTable (vfit_eb, coef = which(colnames(design_mat) == "Treg"), number=Inf, sort.by="P")
tregDE$HGNC.symbol <- ens2hgnc[ rownames(tregDE)]
sigs <- rownames(tregDE)[1:60]

tab <- table( ifelse( tregDE$logFC[ tregDE$adj.P.Val <= 0.05] > 0, "Treg","Tconv"))
title <- paste0( "Treg vs. Tconv DE\n",tab["Treg"], " up in Treg, ", tab["Tconv"], " up in Tconv at 5% FDR")
pdf("../../data/2025-02-10/PaperFigures/TregVTconv_volcano.pdf",width=5,height=5)
ggplot(tregDE, aes(x=logFC,y=-log10(adj.P.Val))) + geom_point() + geom_hline( yintercept = -log10(0.05), color="grey",linetype="dashed") + labs(y="-log10 FDR",title=title) +  theme( text = element_text(size=11))
dev.off()

donorCols <- make_colors( gsub("-",".",unique(df$donorId)) )

designBulk$studyGroup <- designByDonor[ designBulk$srid,"studyGroup"]
ens <- sigs
libs <- rownames(designBulk); libs <- libs[order(designBulk$type)]
tp <- t(scale(t(log2(1+bulk_pc_norm[ens,libs]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
ha <- HeatmapAnnotation(df=designBulk[libs,c("type","studyGroup")], col=list("type"=c("Tconventional"="red","Treg"="blue"),"studyGroup"=groupCols))
# pdf("../../data/2025-02-10/PaperFigures/SeuratFiltered_TregVTconv_Top60_heatmap.pdf", width=9,height =9.3)
png("../../data/2025-02-10/PaperFigures/SeuratFiltered_TregVTconv_Top60_heatmap.png", width=800,height =830)

Heatmap(tp,show_column_names=FALSE,cluster_columns=FALSE,name="scaled\nlog2\nexpression", top_annotation=ha, cluster_rows=TRUE,column_title="Top 60 genes DE between Treg and Tconv, Seurat Filtered" )
dev.off()

write.table( tregDE, "../../data/2025-02-10/PaperFigures/tregDE.txt",quote=FALSE,sep="\t",col.names=NA)


```

```{r 2025-02-25 Pseudobulk for HC vs. T1D}

# Heat map of DEGs between Treg and Tconv with the new Seurat clustering
commoncols <- intersect( colnames(soTregs@meta.data ), colnames(soTconvs@meta.data)  )
combinedDf <- rbind( soTregs@meta.data[,commoncols], soTconvs@meta.data[,commoncols])
combinedDf$donorId <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$donorID <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$cluster <- paste0( ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"), "_", ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"),as.character( combinedDf$seurat_clusters ) )
combinedDf$donorType <- paste0( combinedDf$donorID, "_",combinedDf$cluster)
df <- combinedDf; df$group <- df$donorType
groups <- unique(df$group)

# libsByGroup <- lapply( groups, function(g) df$libid[ df$ donorType==g & ! df$libid %in% c(toFilter,iNKTMaitLibids)])
libsByGroup <- lapply( groups, function(g) df$libid[ df$ donorType==g ])
names(libsByGroup) <- groups

libs <- unique( do.call(c,libsByGroup))

bulk <- data.frame(sapply( libsByGroup, function(libs) rowSums(counts_pc[,c(libs,libs)])/2 ))
g <- rownames(bulk)[ rowSums(bulk>0) >= (ncol(bulk)/10) ]
bulk <- bulk[g,]
# Combine project P214-24 into project P214-17


normalize_counts <- function(counts_in, method){
  #normalize using tmm or deconvolution
  #tmm is good for bulk RNAseq
  #deconvolution is best for large datasets of single cell RNAseq
  #deconvolution is NOT recommended for smaller datasets (less than a few hundred cells)
  
  if(method == "decon"){
  #Normalize using the deconvolution algorithm
  decon_norm_factors <- computeSumFactors(as.matrix(counts_in))
  counts_norm <- as.data.frame(t(t(counts_in)/decon_norm_factors))
  }
  
  if(method == "tmm"){
  #Normalize using the TMM algorithm 
  dge <- DGEList(counts_in)
  dge <- calcNormFactors(dge)
  counts_norm <- edgeR::cpm(dge, normalized.lib.sizes=TRUE)
  }
  return(counts_norm)
}

bulk_pc_norm <- normalize_counts(bulk[g,],"tmm")
designBulk <- data.frame( t(sapply(colnames(bulk_pc_norm), function(s) strsplit(s,"_")[[1]])) )
colnames(designBulk) <- c("donorID","type","cluster")
designBulk$studyGroup <- designByDonor[ designBulk$donorID,"studyGroup"]

#design_mat <- model.matrix(~0+id+FOXP3+cdr+group,data=designByProject)
design_mat <- model.matrix(~0+studyGroup:type,data=designBulk)
colnames(design_mat) <- gsub("studyGroup","",gsub("type","",colnames(design_mat)))
colnames(design_mat) <- gsub("\\:","_", colnames(design_mat))

vwts <- voomWithQualityWeights(bulk_pc_norm[ ,rownames(design_mat)], design= design_mat, plot=T, span=0.1)
vfit <- lmFit(vwts, design = design_mat)

tregDE <- topTable (vfit_eb, coef = which(colnames(design_mat) == "Treg"), number=Inf, sort.by="P")
tregDE$HGNC.symbol <- ens2hgnc[ rownames(tregDE)]
sigs <- rownames(tregDE)[1:60]

tab <- table( ifelse( tregDE$logFC[ tregDE$adj.P.Val <= 0.05] > 0, "Treg","Tconv"))
title <- paste0( "Treg vs. Tconv DE\n",tab["Treg"], " up in Treg, ", tab["Tconv"], " up in Tconv at 5% FDR")
pdf("../../data/2025-01-10/TregVTconv_volcano.pdf",width=5,height=5)
ggplot(tregDE, aes(x=logFC,y=-log10(adj.P.Val))) + geom_point() + geom_hline( yintercept = -log10(0.05), color="grey",linetype="dashed") + labs(y="-log10 FDR",title=title) +  theme( text = element_text(size=11))
dev.off()

donorCols <- make_colors( gsub("-",".",unique(df$sampleRepositoryID)) )

ens <- sigs
libs <- rownames(designBulk); libs <- libs[order(designBulk$type)]
tp <- t(scale(t(log2(1+bulk_pc_norm[ens,libs]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
ha <- HeatmapAnnotation(df=designBulk[libs,c("type","srid")], col=list("type"=c("Tconventional"="red","Treg"="blue"),"srid"=donorCols))
pdf("../../data/2025-01-10/SeuratFiltered_TregVTconv_Top60_heatmap.pdf", width=9,height =9.3)
Heatmap(tp,show_column_names=FALSE,cluster_columns=FALSE,name="scaled\nlog2\nexpression", top_annotation=ha, cluster_rows=TRUE,column_title="Top 60 genes DE between Treg and Tconv,Seurat Filtered" )
dev.off()



```

```{r Pseudobulk for FOXP3}

design_qc$group <- ifelse(design_qc$FOXP3.2 > 0, "exon2PosTreg","exon2NegTreg")
design_qc$group[ design_qc$CD4Type == "Tconv"] <- "Tconv"
design_qc$g <- design_qc$group
design_qc$group <- paste0( design_qc$project, ".", design_qc$group)
groups <- unique(design_qc$group)
libsByGroup <- lapply(groups, function(g) design_qc$libid[ design_qc$group == g])
names(libsByGroup) <- groups

libs <- unique( do.call(c,libsByGroup))

bulk <- data.frame(sapply( libsByGroup, function(libs) rowSums(counts_pc[,libs]) ))
g <- rownames(bulk)[ rowSums(bulk>0) >= (ncol(bulk)/10) ]
bulk <- bulk[g,]
# Combine project P214-24 into project P214-17


normalize_counts <- function(counts_in, method){
  #normalize using tmm or deconvolution
  #tmm is good for bulk RNAseq
  #deconvolution is best for large datasets of single cell RNAseq
  #deconvolution is NOT recommended for smaller datasets (less than a few hundred cells)
  
  if(method == "decon"){
  #Normalize using the deconvolution algorithm
  decon_norm_factors <- computeSumFactors(as.matrix(counts_in))
  counts_norm <- as.data.frame(t(t(counts_in)/decon_norm_factors))
  }
  
  if(method == "tmm"){
  #Normalize using the TMM algorithm 
  dge <- DGEList(counts_in)
  dge <- calcNormFactors(dge)
  counts_norm <- edgeR::cpm(dge, normalized.lib.sizes=TRUE)
  }
  return(counts_norm)
}

idByProj <- design$sampleRepositoryID[ !duplicated( design$project)]
names(idByProj) <- design$project[ !duplicated( design$project)]


bulk_pc_norm <- normalize_counts(bulk[g,],"tmm")
designByProject <- data.frame(group = sapply(colnames(bulk_pc_norm), function(s) strsplit(s,"\\.")[[1]][3]))
designByProject$cdr <- as.numeric(apply(bulk_pc_norm,2,function(col) sum(col>0)))
designByProject$group <- relevel( as.factor(designByProject$group), "Tconv")
designByProject$FOXP3 <- as.numeric(log2(1+bulk_pc_norm["ENSG00000049768",rownames(designByProject)]))
designByProject$project <- gsub("P390\\.","P390-",rownames(designByProject))
designByProject$project <- sapply(designByProject$project, function(s) strsplit(s,"\\.")[[1]][1])
designByProject$id <- idByProj[ designByProject$project]

#design_mat <- model.matrix(~0+id+FOXP3+cdr+group,data=designByProject)
design_mat <- model.matrix(~0+FOXP3+cdr+group,data=designByProject)


cont.matrix <- makeContrasts(
     exon2PosvNeg = groupexon2PosTreg - groupexon2NegTreg,
     levels=design_mat)


vwts <- voomWithQualityWeights(bulk_pc_norm[ ,rownames(design_mat)], design= design_mat, plot=T, span=0.1)
vfit <- lmFit(vwts, design = design_mat)
vfit_eb <- eBayes(vfit)
vfit_c <- contrasts.fit(vfit, cont.matrix)
vfit_c_eb <- eBayes(vfit_c)

exon2PosDE <- topTable (vfit_c_eb, coef = 1, number=Inf, sort.by="P")
table( exon2PosDE$adj.P.Val <= 0.05)
exon2PosDE$HGNC.symbol <- ens2hgnc[ rownames(exon2PosDE)]

## Filter out significant genes so that they are present in either all of the
# exon pos cells or all of the exon neg cells
poslibs <- rownames(designByProject)[ designByProject$group == "exon2PosTreg"]
neglibs <- rownames(designByProject)[ designByProject$group == "exon2NegTreg"]
sigs <- rownames(exon2PosDE)[exon2PosDE$adj.P.Val <= 0.05]
sigs <- sigs[ sapply(sigs, function(g) all(bulk_pc_norm[g,poslibs]>0) | all(bulk_pc_norm[g,neglibs]>0)   )]
print( length(sigs))

for( ens in sigs ){
  g <- exon2PosDE[ens,"HGNC.symbol"]
  print(g)
  df <- designByProject
  df$g <- as.numeric( log2(1+bulk_pc_norm[ens,rownames(df)]) )
  #ggplot(df, aes(x=group,y=g)) + geom_boxplot() + geom_quasirandom() + labs(y=g)
  p <- ggplot(df,aes(x=FOXP3,y=g,color=group ))+ geom_point(size=2) + scale_color_manual(values=c("Tconv"="grey","exon2NegTreg"="blue","exon2PosTreg"="red")) + labs(y=g) 
  png(paste0("../../data/2022-01-26/Exon2DE_scatterplots/",g,".png"),width=450,height=300)
  print(p)
  dev.off()
}

ens <- sigs
libs <- rownames(designByProject); libs <- libs[order(designByProject$group)]
tp <- t(scale(t(log2(1+bulk_pc_norm[ens,libs]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
ha <- HeatmapAnnotation(df=list(group=designByProject[libs,"group"]), col=list("group"=c("Tconv"="grey","exon2NegTreg"="blue","exon2PosTreg"="purple")))
col_fun = colorRamp2(c(-3, 0, 3), c("blue", "white", "red"))
#pdf(paste0(plotdir,"genesetHeatmap_unclustered.pdf"), width=6,height =5)
Heatmap(tp,show_column_names=FALSE,cluster_columns=FALSE,name="scaled\nlog2\nexpression", top_annotation=ha, col=col_fun, cluster_rows=FALSE )
#dev.off()


```

```{r 05/16/23 Search against vdjdb }

# These sequences were downloaded from this website: https://vdjdb.cdr3.net/search
vdjdb <- read.table( "../../../data/SearchTable-2023-05-16_16_23_38.755_vdjdb.tsv",header=TRUE,sep="\t", comment.char = "")
table(tcrs$junction %in% vdjdb$CDR3)
tcrs$cellType <- design[ tcrs$libid, "cellType"]

matches <- vdjdb[vdjdb$CDR3 %in% tcrs$junction,]
jToESpecies <- matches$Epitope.species; names(jToESpecies) <- matches$CDR3

subtcrs <- tcrs[ tcrs$junction %in% names(jToESpecies),]
subtcrs$Epitope.species <- jToESpecies[ subtcrs$junction]
subtcrs$idType <- paste( subtcrs$cellType, subtcrs$sampleRepositoryID, sep="_")

tab <- table(subtcrs$Epitope.species)
subtcrs$Epitope.species <- factor(subtcrs$Epitope.species, levels=names(tab)[rev(order(tab))])
pdf("../../data/2023-04-17/VDJDB_matches.pdf",width=8,height=4.5)
ggplot(subtcrs, aes(x=Epitope.species, fill=sampleRepositoryID)) + geom_histogram(stat="count") + facet_wrap(~cellType) +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), text = element_text(size=11)) + labs(title="Number of TCRs matching VDJDB annotations (duplicates counted)")
dev.off()
```

```{r 2025-02-06 Pseudobulk T1D vs HC, within each cluster}


# Heat map of DEGs between Treg and Tconv with the new Seurat clustering
commoncols <- intersect( colnames(soTregs@meta.data ), colnames(soTconvs@meta.data)  )
combinedDf <- rbind( soTregs@meta.data[,commoncols], soTconvs@meta.data[,commoncols])
combinedDf$donorId <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$donorID <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$cluster <- paste0( ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"), "_", ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"),as.character( combinedDf$seurat_clusters ) )
combinedDf$donorType <- paste0( combinedDf$donorID, "_",combinedDf$CD4Type)
combinedDf$donorCluster <- paste0( combinedDf$donorID, "_",combinedDf$cluster)

df <- combinedDf; df$group <- df$donorCluster
groups <- unique(df$group)

# libsByGroup <- lapply( groups, function(g) df$libid[ df$ donorType==g & ! df$libid %in% c(toFilter,iNKTMaitLibids)])
libsByGroup <- lapply( groups, function(g) df$libid[ df$group==g ])
names(libsByGroup) <- groups

libs <- unique( do.call(c,libsByGroup))

bulk <- data.frame(sapply( libsByGroup, function(libs) rowSums(counts_pc[,c(libs,libs)])/2 ))
nCells <- sapply(libsByGroup,length)

#g <- rownames(counts_pc)[ rowMeans(counts_pc[,libs]>0) >= 0.3 ]
g <- rownames(bulk)[ rowMeans(bulk>0) >= 0.1 ]

bulk <- bulk[g,]
# Combine project P214-24 into project P214-17

normalize_counts <- function(counts_in, method){
  #normalize using tmm or deconvolution
  #tmm is good for bulk RNAseq
  #deconvolution is best for large datasets of single cell RNAseq
  #deconvolution is NOT recommended for smaller datasets (less than a few hundred cells)
  
  if(method == "decon"){
  #Normalize using the deconvolution algorithm
  decon_norm_factors <- computeSumFactors(as.matrix(counts_in))
  counts_norm <- as.data.frame(t(t(counts_in)/decon_norm_factors))
  }
  
  if(method == "tmm"){
  #Normalize using the TMM algorithm 
  dge <- DGEList(counts_in)
  dge <- calcNormFactors(dge)
  counts_norm <- edgeR::cpm(dge, normalized.lib.sizes=TRUE)
  }
  return(counts_norm)
}

bulk_pc_norm <- normalize_counts(bulk[g,],"tmm")
designBulk <- data.frame( t(sapply(colnames(bulk_pc_norm), function(s) strsplit(s,"_")[[1]])) )
colnames(designBulk) <- c("donorID","type","cluster")
designBulk$studyGroup <- designByDonor[ designBulk$donorID,"studyGroup"]
designBulk$nCells <- nCells

design_mat <- model.matrix(~0+studyGroup:cluster+nCells,data=designBulk)
colnames(design_mat) <- gsub("studyGroup","",colnames(design_mat))
colnames(design_mat) <- gsub("cluster","",colnames(design_mat))
colnames(design_mat) <- gsub("\\:","_",colnames(design_mat))

design_mat2 <- model.matrix(~0+studyGroup:type+cluster+nCells,data=designBulk)
colnames(design_mat2) <- gsub("studyGroup","",colnames(design_mat2))
colnames(design_mat2) <- gsub("cluster","",colnames(design_mat2))
colnames(design_mat2) <- gsub("\\:","_",colnames(design_mat2))

# vwts2 <- voomWithQualityWeights(bulk_pc_norm[ ,rownames(design_mat2)], design= design_mat2, plot=T, span=0.1)
#t1dDEclusterAware<- lapply( 1:ncol(cont.matrix), function(i) topTable (vfit_c_eb, coef = i, number=Inf, sort.by="P") ); names(t1dDEByCluster) <- colnames( cont.matrix )


### Do a design matrix that

# Generate cont matrix
t1dcols <- colnames(design_mat)[ grepl("T1D_", colnames(design_mat)) ]
cont.matrix <- matrix(0,ncol(design_mat),length(t1dcols)); rownames( cont.matrix) <- colnames(design_mat); colnames(cont.matrix) <- t1dcols
designMatCols <- colnames(design_mat)
cont.matrix <- sapply(t1dcols, function(t1dcol) ifelse(  designMatCols == t1dcol, 1, ifelse( designMatCols == gsub("T1D_","Control_", t1dcol) , -1, 0) ) )
rownames(cont.matrix) <- designMatCols

vwts <- voomWithQualityWeights(bulk_pc_norm[ ,rownames(design_mat)], design= design_mat, plot=T, span=0.1)
vfit <- lmFit(vwts, design = design_mat)
vfit_eb <- eBayes(vfit)
vfit_c <- contrasts.fit(vfit, cont.matrix)
vfit_c_eb <- eBayes(vfit_c)

t1dDEByCluster <- lapply( 1:ncol(cont.matrix), function(i) topTable (vfit_c_eb, coef = i, number=Inf, sort.by="P") ); names(t1dDEByCluster) <- colnames( cont.matrix )
for( i in 1:length(t1dDEByCluster) ){ t1dDEByCluster[[i]]$HGNC.symbol <- ens2hgnc[ rownames(t1dDEByCluster[[i]])]}
sapply(t1dDEByCluster, function(l) table( l$adj.P.Val <= 0.05))
saveRDS(t1dDEByCluster,"t1dDEByCluster_limma_Cell0.3.RDS")

for( nam in names(t1dDEByCluster) ){ 
  print(nam)
  de <- t1dDEByCluster[[nam]]
  de <- de[order(de$P.Value),]
  if(FALSE){
    write.table( rownames(de)[ de$logFC > 0][1:50], paste0("../../data/2025-02-10/T1DDE/GeneLists/",nam,"_Top50Pos.txt"),quote=FALSE,sep="\t",col.names=FALSE,row.names=FALSE )
    write.table( rownames(de)[ de$logFC < 0][1:50], paste0("../../data/2025-02-10/T1DDE/GeneLists/",nam,"_Top50Neg.txt"),quote=FALSE,sep="\t",col.names=FALSE,row.names=FALSE )
  }
}

## Here do significant ones
sigDf <- data.frame()
for( ctype in names(t1dDEByCluster) ){
  clust <- gsub("T1D_","",ctype)
  de <- t1dDEByCluster[[ctype]]
  df <- designBulk[ designBulk$cluster == clust ,]
  
  sigs <- rownames(de)[de$adj.P.Val <= 0.05]
  df <- df[ order(df$studyGroup,df$donorID),]
  cols <- list(studyGroup=groupCols)
  cols[["donorID"]] <- make_colors( unique(df$donorID))
  tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,rownames(df)]))))
  rownames(tp) <- ens2hgnc[ rownames(tp)]
  tp <- tp[ !apply(tp,1,function(r) any(is.na(r))),]
  
  tp <- tp[apply(tp,1, function(r) length(unique(r)) > 5),]
  ha <- HeatmapAnnotation( df=df[colnames(tp),c("studyGroup","donorID")], col=cols[c("studyGroup","donorID")])
  
  height <- 550 + (nrow(tp)-31)*12
  if(FALSE){
    pdf( paste0("../../data/2025-02-10/T1DDE/",ctype,"_T1DvHC_heatmap.pdf"), width=6.5,height=height/100)
    # png( paste0("../../data/2025-02-10/T1DDE/",ctype,"_T1DvHC_heatmap.png"), width=550,height=height)
  
    p <- Heatmap(tp,show_column_names=FALSE,top_annotation=ha, name="scaled\nlog\nexpression", column_title=paste0(gsub("T1D_","",ctype)," T1D vs. Control, ", nrow(tp)," genes"), column_split = df$studyGroup)
    print(p)
    dev.off()
  }
  
  ## Output the DE genes
  sigDE <- de[ de$adj.P.Val <= 0.05,]
  sigDE$MoreThan5Samples <- sigDE$HGNC.symbol %in% rownames(tp) 
  sigDE$comparison <- ctype
  sigDf <- rbind(sigDf,sigDE)
}
write.table( sigDf, paste0("../../data/2025-02-10/T1DDE/GeneLists/T1DDE_byCluster_FDR0.05.txt"),quote=FALSE,sep="\t",col.names=NA)



### Now to hallmark
h = data.frame( msigdbr(species = "Homo sapiens", category = "H") )
hallmark <- unique(h$gs_name)
hallmark_list <- lapply(hallmark, function(hname) h$human_gene_symbol[ h$gs_name == hname])
names(hallmark_list) <- hallmark

coeffs <- colnames(cont.matrix)
clusterT1DRoast_h <- lapply( coeffs, function(coeff) roast(
      y=vwts,
      index=ids2indices(hallmark_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,coeff],
      nrot = 8000) )
names(clusterT1DRoast_h) <- coeffs


keggnames <- unique(keggs$gs_name)
kegg_list <- lapply(keggnames, function(hname) keggs$human_gene_symbol[ keggs$gs_name == hname])
names(kegg_list) <- keggnames
clusterT1DRoast_kegg <- lapply( coeffs, function(coeff) roast(
      y=vwts,
      index=ids2indices(kegg_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,coeff],
      nrot = 8000) )
names(clusterT1DRoast_kegg) <- coeffs

```

```{r 2025-02-06 Pseudobulk T1D vs HC by cluster, using Deseq}

soFiltered$donorID <- donorTable[ soFiltered$project, "Donor.ID"]
soFiltered$donorId <- soFiltered$donorID
soFiltered@meta.data$combinedClusters <- sapply( combinedDf[ soFiltered$libid, "cluster"], function(s) strsplit(s,"_")[[1]][2])
ae <- AggregateExpression(soFiltered, 
                                  assays = "RNA", 
                                  return.seurat = T, 
                                  group.by = c("donorID", "studyGroup", "combinedClusters"))


pseudoCounts <- ae@assays$RNA$counts
pseudoMetadata <- ae@meta.data
clusters <- sort(unique(pseudoMetadata$combinedClusters))

DESeqTables <- list()

for(i in 1:length(clusters)){
  print( clusters[i])
  selMetadata <- pseudoMetadata[pseudoMetadata$combinedClusters == clusters[i],]
  selCounts <- pseudoCounts[,selMetadata$orig.ident]
  
  dds <- DESeqDataSetFromMatrix(countData = selCounts,
                                colData = selMetadata,
                                design = ~studyGroup)

dds <- DESeq(dds)

res <- results(dds,
               name = "studyGroup_T1D_vs_Control",
               pAdjustMethod = "fdr")

res$gene <- rownames(res)
res$cluster <- clusters[i]

res <- res %>%
  as.data.frame() %>%
  dplyr::arrange(padj)

DESeqTables[[i]] <- res
}

names(DESeqTables) <- clusters
for( i in length(DESeqTables) ){ DESeqTables[[i]] <- DESeqTables[[i]][ order(DESeqTables[[i]]$pvalue),]}
print( sapply(DESeqTables, function(l) table(l$padj <= 0.05)))

## Here do significant ones
for( clust in names(DESeqTables) ){
  de <- DESeqTables[[clust]]
  de$padj[ is.na(de$padj)] <- 1
  de$pvalue[ is.na(de$pvalue) ] <- 1
  if(sum(de$padj <= 0.05) <= 1 ){
    next
  }
  print( paste(clust, sum(de$padj <= 0.05)) )
  df <- pseudoMetadata[pseudoMetadata$combinedClusters == clust,]
  tp <- pseudoCounts[,df$orig.ident]
  
  sigs <- rownames(de)[de$padj <= 0.05]
  df <- df[ order(df$studyGroup,df$donorID),]
  cols <- list(studyGroup=groupCols)
  cols[["donorID"]] <- make_colors( unique(df$donorID))
  tp <- t(scale(t(log2(1+tp[sigs,rownames(df)]))))
  tp <- tp[ !apply(tp,1,function(r) any(is.na(r))),]
  
  #tp <- tp[apply(tp,1, function(r) length(unique(r)) > 5),]
  ha <- HeatmapAnnotation( df=df[colnames(tp),c("studyGroup","donorID")], col=cols[c("studyGroup","donorID")])
  
  height <- 550 + (nrow(tp)-31)*12
  #pdf( paste0("../../data/2025-02-10/T1DDE/",ctype,"_T1DvHC_heatmap.pdf"), width=6.5,height=8)
  png( paste0("../../data/2025-02-10/T1DDE/",clust,"_T1DvHC_heatmap_DESeq2.png"), width=550,height=height)

  p <- Heatmap(tp,show_column_names=FALSE,top_annotation=ha, name="scaled\nlog\nexpression", column_title=paste0(gsub("T1D_","",clust)," T1D vs. Control, ", nrow(tp)," genes"), column_split = df$studyGroup)
  print(p)
  dev.off()
}

```

```{r 2025-02-06 Pseudobulk T1D vs HC}

# Heat map of DEGs between Treg and Tconv with the new Seurat clustering
commoncols <- intersect( colnames(soTregs@meta.data ), colnames(soTconvs@meta.data)  )
combinedDf <- rbind( soTregs@meta.data[,commoncols], soTconvs@meta.data[,commoncols])
combinedDf$donorId <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$donorID <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$cluster <- paste0( ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"), "_", ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"),as.character( combinedDf$seurat_clusters ) )
combinedDf$donorType <- paste0( combinedDf$donorID, "_",combinedDf$CD4Type)
df <- combinedDf; df$group <- df$donorType
groups <- unique(df$group)

# libsByGroup <- lapply( groups, function(g) df$libid[ df$ donorType==g & ! df$libid %in% c(toFilter,iNKTMaitLibids)])
libsByGroup <- lapply( groups, function(g) df$libid[ df$ donorType==g ])
names(libsByGroup) <- groups

libs <- unique( do.call(c,libsByGroup))

bulk <- data.frame(sapply( libsByGroup, function(libs) rowSums(counts_pc[,c(libs,libs)])/2 ))
nCells <- sapply(libsByGroup,length)
g <- rownames(bulk)[ rowSums(bulk>0) >= (ncol(bulk)/10) ]
bulk <- bulk[g,]
# Combine project P214-24 into project P214-17

normalize_counts <- function(counts_in, method){
  #normalize using tmm or deconvolution
  #tmm is good for bulk RNAseq
  #deconvolution is best for large datasets of single cell RNAseq
  #deconvolution is NOT recommended for smaller datasets (less than a few hundred cells)
  
  if(method == "decon"){
  #Normalize using the deconvolution algorithm
  decon_norm_factors <- computeSumFactors(as.matrix(counts_in))
  counts_norm <- as.data.frame(t(t(counts_in)/decon_norm_factors))
  }
  
  if(method == "tmm"){
  #Normalize using the TMM algorithm 
  dge <- DGEList(counts_in)
  dge <- calcNormFactors(dge)
  counts_norm <- edgeR::cpm(dge, normalized.lib.sizes=TRUE)
  }
  return(counts_norm)
}

bulk_pc_norm <- normalize_counts(bulk[g,],"tmm")
designBulk <- data.frame( t(sapply(colnames(bulk_pc_norm), function(s) strsplit(s,"_")[[1]])) )
colnames(designBulk) <- c("donorID","type")
designBulk$studyGroup <- designByDonor[ designBulk$donorID,"studyGroup"]
designBulk$nCells <- nCells

design_mat <- model.matrix(~0+studyGroup:type+nCells,data=designBulk)
colnames(design_mat) <- gsub("studyGroup","",colnames(design_mat))
colnames(design_mat) <- gsub("type","",colnames(design_mat))
colnames(design_mat) <- gsub("\\:","_",colnames(design_mat))


cont.matrix <- makeContrasts(
     T1D_treg = T1D_Treg-Control_Treg,
     T1D_tconv = T1D_Tconventional-Control_Tconventional,
  levels=design_mat)

vwts <- voomWithQualityWeights(bulk_pc_norm[ ,rownames(design_mat)], design= design_mat, plot=T, span=0.1)
vfit <- lmFit(vwts, design = design_mat)
vfit_eb <- eBayes(vfit)
vfit_c <- contrasts.fit(vfit, cont.matrix)
vfit_c_eb <- eBayes(vfit_c)

t1dDE <- list()
t1dDE[["Treg"]] <- topTable (vfit_c_eb, coef = 1, number=Inf, sort.by="P")
t1dDE[["Tconv"]] <- topTable (vfit_c_eb, coef = 2, number=Inf, sort.by="P")

lapply(t1dDE, function(l) table( l$adj.P.Val <= 0.05))
for( i in 1:length(t1dDE) ){
  t1dDE[[i]]$HGNC.symbol <- ens2hgnc[ rownames(t1dDE[[i]])]
}

tregDE <- t1dDE[["Treg"]]
up <- rownames(tregDE)[ tregDE$adj.P.Val <= 0.05 & tregDE$logFC > 0]
down <- rownames(tregDE)[ tregDE$adj.P.Val <= 0.05 & tregDE$logFC < 0]
write.table(up,"../../data/2024-11-19/tregT1D_up.txt",quote=FALSE,sep="\t",col.names=FALSE,row.names=FALSE)
write.table(down,"../../data/2024-11-19/tregT1D_down.txt",quote=FALSE,sep="\t",col.names=FALSE,row.names=FALSE)


## Here do significant ones
for( ctype in c("Treg","Tconv") ){
  de <- t1dDE[[ctype]]
  df <- designBulk[ grepl(ctype,designBulk$type) ,]
  
  sigs <- rownames(de)[de$adj.P.Val <= 0.05]
  df <- df[ order(df$studyGroup,df$donorID),]
  cols <- list(studyGroup=groupCols)
  cols[["donorID"]] <- make_colors( unique(df$donorID))
  tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,rownames(df)]))))
  rownames(tp) <- ens2hgnc[ rownames(tp)]
  tp <- tp[ !apply(tp,1,function(r) any(is.na(r))),]
  ha <- HeatmapAnnotation( df=df[colnames(tp),c("studyGroup","donorID")], col=cols[c("studyGroup","donorID")])
  pdf( paste0("../../data/2025-01-10/",ctype,"_T1DvHC_heatmap.pdf"), width=6.5,height=8)
  p <- Heatmap(tp,show_column_names=FALSE,top_annotation=ha, name="scaled\nlog\nexpression", column_title=paste0("T1D vs. Control, ", length(sigs)," genes\n",ctype), column_split = df$studyGroup)
  print(p)
  dev.off()
}



library(msigdbr)
c2 = data.frame( msigdbr(species = "Homo sapiens", category = "C2") )
c7 = data.frame( msigdbr(species = "Homo sapiens", category = "C7") )
h = data.frame( msigdbr(species = "Homo sapiens", category = "H") )

sets <- unique(c7$gs_name)
sets[grepl("CD4_",toupper(sets))]

sets <- unique(c2$gs_name)
sets <- sets[ grepl("IL[0-9]+",sets) | grepl("PROSTAG",sets) | grepl("CYTOK",sets) | grepl("TNFRSF9",sets) | grepl("CD",sets) ]
c2_list <- lapply( sets, function(set)  as.character(c2[ c2$gs_name == set,"human_gene_symbol"] ) )
names(c2_list) <- sets

tregT1DRoast_c2 <- roast(
      y=vwts,
      index=ids2indices(c2_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,1],
      nrot = 8000)

tconvT1DRoast_c2 <- roast(
      y=vwts,
      index=ids2indices(c2_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,2],
      nrot = 8000)

h = data.frame( msigdbr(species = "Homo sapiens", category = "H") )
hallmark <- unique(h$gs_name)
hallmark_list <- lapply(hallmark, function(hname) h$human_gene_symbol[ h$gs_name == hname])
names(hallmark_list) <- hallmark
tconvT1DRoast_h <- roast(
      y=vwts,
      index=ids2indices(hallmark_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,2],
      nrot = 8000)

## FGSEA
library(fgsea)

getFgsea <- function(de, gsets = kegggenes){
  de <- de[ rev(order(de$logFC)),]
  logFC <- de$logFC
  names(logFC) <- de$HGNC.symbol
  fgseaRes <- fgsea(pathways = gsets, 
                    stats    = logFC,
                    minSize  = 1,
                    maxSize  = 5000)
  fgseaRes <- fgseaRes[ order(fgseaRes$padj),]
  print(head(fgseaRes[,1:7]))
  fgseaRes <- data.frame(fgseaRes)
  rownames(fgseaRes) <- fgseaRes$pathway
  return(fgseaRes)
}

tregDE <- t1dDE[["Treg"]]
tconvDE <- t1dDE[["Tconv"]]

tregDEFGSEA_c2 <- getFgsea(tregDE, c2_list) 
tconvDEFGSEA_c2 <- getFgsea(tconvDE, c2_list) 



### Make Heatmap
tregDE$anno <- tregDE$HGNC.symbol %in% c2_list[["AUJLA_IL22_AND_IL17A_SIGNALING"]]
tregDE <- tregDE[order(tregDE$anno),]
ggplot( tregDE, aes(x=logFC,y=-log10(adj.P.Val),color=anno)) + geom_point()

tregDE <- t1dDE[["Treg"]]
gset <- "KEGG_CYTOKINE_CYTOKINE_RECEPTOR_INTERACTION"
sigs <- rownames(tregDE)[ tregDE$HGNC.symbol %in% c2_list[[gset]]]
df <- design_bulk[ design_bulk$type == "Treg",]
df <- df[ order(df$studyGroup,df$srid),]
cols <- lapply( df, function(col) make_colors(unique(col)) )
tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,rownames(df)]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
tp <- tp[ !apply(tp,1,function(r) any(is.na(r))),]
ha <- HeatmapAnnotation( df=df[colnames(tp),c("studyGroup","srid")], col=cols[c("studyGroup","srid")])
pdf( paste0("../../data/2022-11-15/Hallmark/T1D_DE_",gset,"_Treg_heatmap.pdf"), width=6.5,height=7)
p <- Heatmap(tp,show_column_names=FALSE,top_annotation=ha, name="scaled\nlog\nexpression", column_title=paste0(gset,"\nT1D vs. Control\nTreg"), cluster_columns=FALSE)
print(p)
dev.off()

### Plot DE genes for T1D vs Tconv
de <- t1dDE[["Tconv"]]
g <- "FAM110B"
for( ens in rownames(de)[ de$adj.P.Val <= 0.05] ){
  g <- de[ens,"HGNC.symbol"]
  print(g)
  design_bulk$g <- as.numeric( log2(1+bulk_pc_norm[ ens, rownames(design_bulk) ]))
  p <- ggplot( design_bulk, aes(x=studyGroup, y=g, color=nCells)) + geom_boxplot(color="black",aes(x=studyGroup), outlier.color =NA) + geom_quasirandom(size=2) + labs(title=g, y="log2 normalized expression",x="",color="cell\ncount") + facet_wrap(~type)  + scale_color_viridis(option="B")
  pdf( paste0("../../data/2023-06-05/T1DvHC_Tconventional_boxplots/",g,".pdf"), width=6,height=5)
  print(p)
  dev.off()
}

de$anno <- ifelse( de$logFC>0, "T1D","Control"); de$anno[de$adj.P.Val > 0.05] <- "n.s."
de$anno <- factor(de$anno, c("T1D","Control","n.s."))
p <- ggplot(de, aes(x=logFC,y=-log10(adj.P.Val), color=anno)) + geom_point(size=2) + geom_hline(yintercept = -log10(0.05),color="grey",linetype="dashed") +  geom_text_repel(data=de[de$adj.P.Val <= 0.05,], aes(logFC, -log10(adj.P.Val), label=HGNC.symbol), size=4, color="black", max.overlaps = 20) + geom_vline(xintercept = -1,color="grey",linetype="dashed") + geom_vline(xintercept = 1,color="grey",linetype="dashed") + labs(x="log2 fold-change",y="-log10 FDR",title="T1D vs. Control\nT-conventional", color="<= 5% FDR\nhigher in") + scale_color_manual( values=c("n.s."="grey","T1D"="red","Control"="blue"))
pdf("../../data/2023-06-05/T1D_v_Control_Tconv_volcano.pdf",width=8,height=8) 
print(p)
dev.off()

### Show the cytokine cytokine interaction genes
de <- t1dExpandedDE[["Tconv"]]
de$anno <- de$HGNC.symbol %in% c2_list[["KEGG_CYTOKINE_CYTOKINE_RECEPTOR_INTERACTION"]]
de <- de[order(de$anno),]
p <- ggplot(de, aes(x=logFC,y=-log10(adj.P.Val), color=anno)) + geom_point(size=2) + geom_hline(yintercept = -log10(0.05),color="grey",linetype="dashed") +  geom_text_repel(data=de[de$adj.P.Val <= 0.05,], aes(logFC, -log10(adj.P.Val), label=HGNC.symbol), size=4, color="black", max.overlaps = 20) + geom_vline(xintercept = -1,color="grey",linetype="dashed") + geom_vline(xintercept = 1,color="grey",linetype="dashed") + labs(x="log2 fold-change",y="-log10 FDR",title="T1D vs. Control\nT-conventional", color="<= 5% FDR\nhigher in") + scale_color_manual( values=c("FALSE"="grey","TRUE"="red"))
pdf("../../data/2023-06-05/T1D_v_Control_Tconv_volcano_KEGG_CYTOKINE_CYTOKINE_RECEPTOR_INTERACTION.pdf",width=8,height=8) 
print(p)
dev.off()



sigs <- rownames(de)[de$adj.P.Val <= 0.05]
design_bulk <- design_bulk[ order(design_bulk$type, design_bulk$studyGroup),]
libs <- rownames(design_bulk)[ design_bulk$type == "Tconventional"]
tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,libs]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
typeCols <- c(Tconventional="blue",Treg="red")
groupCols <- c("Control"="lightblue","T1D"="orange")
ha <- HeatmapAnnotation(df=data.frame(studyGroup=design_bulk[libs,"studyGroup"]), col=list(studyGroup=groupCols))
pdf("../../data/2023-06-05/T1D_v_Control_Tconv_heatmap.pdf",width=8,height=4.5) 
Heatmap(tp,top_annotation=ha,cluster_columns=FALSE,show_column_names=FALSE, name="scaled\nlog\nexpression", column_title="T1D vs. Control\n16 genes DE at 5% FDR\nT-conventional")
dev.off()

de <- t1dDE[["Treg"]]
sigs <- rownames(de)[de$adj.P.Val <= 0.1]
design_bulk <- design_bulk[ order(design_bulk$type, design_bulk$studyGroup),]
libs <- rownames(design_bulk)[ design_bulk$type == "Treg"]
tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,libs]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
typeCols <- c(Tconventional="blue",Treg="red")
groupCols <- c("Control"="lightblue","T1D"="orange")
ha <- HeatmapAnnotation(df=data.frame(studyGroup=design_bulk[libs,"studyGroup"]), col=list(studyGroup=groupCols))
pdf("../../data/2023-06-05/T1D_v_Control_Treg_heatmap.pdf",width=8,height=4.5) 
Heatmap(tp,top_annotation=ha,cluster_columns=FALSE,show_column_names=FALSE, name="scaled\nlog\nexpression", column_title="T1D vs. Control\n7 genes DE at 10% FDR\nTreg")
dev.off()
```

```{r 2025-02-06 Pseudobulk T1D vs HC, both singletons and expanded modeled together}

# Heat map of DEGs between Treg and Tconv with the new Seurat clustering
commoncols <- intersect( colnames(soTregs@meta.data ), colnames(soTconvs@meta.data)  )
combinedDf <- rbind( soTregs@meta.data[,commoncols], soTconvs@meta.data[,commoncols])
combinedDf$donorId <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$donorID <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$cluster <- paste0( ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"), "_", ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"),as.character( combinedDf$seurat_clusters ) )
combinedDf$donorTypeExpanded <- paste0( combinedDf$donorID, "_",combinedDf$CD4Type, "_", ifelse(combinedDf$libid %in% expandedPairLibs, "Expanded","Singleton"))
df <- combinedDf; df$group <- df$donorTypeExpanded
groups <- unique(df$group)

# libsByGroup <- lapply( groups, function(g) df$libid[ df$ donorType==g & ! df$libid %in% c(toFilter,iNKTMaitLibids)])
libsByGroup <- lapply( groups, function(g) df$libid[ df$ donorTypeExpanded==g ])
names(libsByGroup) <- groups
libsByGroup <- libsByGroup[ sapply(libsByGroup,length) > 0]

libs <- unique( do.call(c,libsByGroup))

bulk <- data.frame(sapply( libsByGroup, function(libs) rowSums(counts_pc[,c(libs,libs)])/2 ))
nCells <- sapply(libsByGroup,length)
g <- rownames(bulk)[ rowSums(bulk>0) >= (ncol(bulk)/10) ]
bulk <- bulk[g,]
# Combine project P214-24 into project P214-17

normalize_counts <- function(counts_in, method){
  #normalize using tmm or deconvolution
  #tmm is good for bulk RNAseq
  #deconvolution is best for large datasets of single cell RNAseq
  #deconvolution is NOT recommended for smaller datasets (less than a few hundred cells)
  
  if(method == "decon"){
  #Normalize using the deconvolution algorithm
  decon_norm_factors <- computeSumFactors(as.matrix(counts_in))
  counts_norm <- as.data.frame(t(t(counts_in)/decon_norm_factors))
  }
  
  if(method == "tmm"){
  #Normalize using the TMM algorithm 
  dge <- DGEList(counts_in)
  dge <- calcNormFactors(dge)
  counts_norm <- edgeR::cpm(dge, normalized.lib.sizes=TRUE)
  }
  return(counts_norm)
}

bulk_pc_norm <- normalize_counts(bulk[g,],"tmm")
designBulk <- data.frame( t(sapply(colnames(bulk_pc_norm), function(s) strsplit(s,"_")[[1]])) )
colnames(designBulk) <- c("donorID","type","expanded")
designBulk$studyGroup <- designByDonor[ designBulk$donorID,"studyGroup"]
designBulk$nCells <- nCells

design_mat <- model.matrix(~0+studyGroup:type:expanded+nCells,data=designBulk)
colnames(design_mat) <- gsub("studyGroup","",colnames(design_mat))
colnames(design_mat) <- gsub("type","",colnames(design_mat))
colnames(design_mat) <- gsub("\\:","_",colnames(design_mat))
colnames(design_mat) <- gsub("expanded","",colnames(design_mat))

cont.matrix <- makeContrasts(
     T1D_Treg_Singleton = T1D_Treg_Singleton-Control_Treg_Singleton,
     T1D_Tconv_Singleton = T1D_Tconventional_Singleton-Control_Tconventional_Singleton,
     T1D_Treg_Expanded = T1D_Treg_Expanded-Control_Treg_Expanded,
     T1D_Tconv_Expanded = T1D_Tconventional_Expanded-Control_Tconventional_Expanded,
     levels=design_mat)

vwts <- voomWithQualityWeights(bulk_pc_norm[ ,rownames(design_mat)], design= design_mat, plot=T, span=0.1)
vfit <- lmFit(vwts, design = design_mat)
vfit_eb <- eBayes(vfit)
vfit_c <- contrasts.fit(vfit, cont.matrix)
vfit_c_eb <- eBayes(vfit_c)

t1dComboDE <- lapply( 1:ncol(cont.matrix), function(i) topTable (vfit_c_eb, coef = i, number=Inf, sort.by="P") ); names(t1dComboDE) <- colnames(cont.matrix)

lapply(t1dComboDE, function(l) table( l$adj.P.Val <= 0.05))
for( i in 1:length(t1dComboDE) ){
  t1dComboDE[[i]]$HGNC.symbol <- ens2hgnc[ rownames(t1dComboDE[[i]])]
}

## Here do significant ones
for( comp in names(t1dComboDE) ){
  ctype <- gsub("Tconv","Tconventional",gsub("T1D","",gsub("Control","",comp)))
  sort <- ifelse( grepl("Treg",ctype),"Treg","Tconventional")
  
  de <- t1dComboDE[[comp]]
  df <- designBulk[ grepl(ctype,rownames(designBulk)) ,]

  de <- de[order(de$P.Value),]
  sigs <- rownames(de)[1:50]
  df <- df[ order(df$studyGroup,df$donorID),]
  cols <- list(studyGroup=groupCols)
  cols[["donorID"]] <- make_colors( unique(df$donorID))
  tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,rownames(df)]))))
  rownames(tp) <- ens2hgnc[ rownames(tp)]
  tp <- tp[ !apply(tp,1,function(r) any(is.na(r))),]
  ha <- HeatmapAnnotation( df=df[colnames(tp),c("studyGroup","donorID")], col=cols[c("studyGroup","donorID")])
  pdf( paste0("../../data/2025-01-10/",comp,"_T1DvHC_heatmap.pdf"), width=6.5,height=8)
  p <- Heatmap(tp,show_column_names=FALSE,top_annotation=ha, name="scaled\nlog\nexpression", column_title=paste0("T1D vs. Control, ", "Top 50 genes\n",comp), column_split = df$studyGroup)
  print(p)
  dev.off()
}
```

```{r Pseudobulk T1D vs HC, expanded cells only}

expandedPairLibs <- unique( pairs$sample[ pairs$expanded] )

# Heat map of DEGs between Treg and Tconv with the new Seurat clustering
commoncols <- intersect( colnames(soTregs@meta.data ), colnames(soTconvs@meta.data)  )
combinedDf <- rbind( soTregs@meta.data[,commoncols], soTconvs@meta.data[,commoncols])
combinedDf$donorId <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$donorID <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$cluster <- paste0( ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"), "_", ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"),as.character( combinedDf$seurat_clusters ) )
combinedDf$donorType <- paste0( combinedDf$donorID, "_",combinedDf$CD4Type)
df <- combinedDf; df$group <- df$donorType
groups <- unique(df$group)

# libsByGroup <- lapply( groups, function(g) df$libid[ df$ donorType==g & ! df$libid %in% c(toFilter,iNKTMaitLibids)])
libsByGroup <- lapply( groups, function(g) df$libid[ df$ donorType==g & df$libid %in% expandedPairLibs ])
names(libsByGroup) <- groups
libsByGroup <- libsByGroup[ sapply(libsByGroup, length) > 0]

libs <- unique( do.call(c,libsByGroup))

bulk <- data.frame(sapply( libsByGroup, function(libs) rowSums(counts_pc[,c(libs,libs)])/2 ))
nCells <- sapply(libsByGroup,length)
g <- rownames(bulk)[ rowSums(bulk>0) >= (ncol(bulk)/10) ]
bulk <- bulk[g,]
# Combine project P214-24 into project P214-17

normalize_counts <- function(counts_in, method){
  #normalize using tmm or deconvolution
  #tmm is good for bulk RNAseq
  #deconvolution is best for large datasets of single cell RNAseq
  #deconvolution is NOT recommended for smaller datasets (less than a few hundred cells)
  
  if(method == "decon"){
  #Normalize using the deconvolution algorithm
  decon_norm_factors <- computeSumFactors(as.matrix(counts_in))
  counts_norm <- as.data.frame(t(t(counts_in)/decon_norm_factors))
  }
  
  if(method == "tmm"){
  #Normalize using the TMM algorithm 
  dge <- DGEList(counts_in)
  dge <- calcNormFactors(dge)
  counts_norm <- edgeR::cpm(dge, normalized.lib.sizes=TRUE)
  }
  return(counts_norm)
}

bulk_pc_norm <- normalize_counts(bulk[g,],"tmm")
designBulk <- data.frame( t(sapply(colnames(bulk_pc_norm), function(s) strsplit(s,"_")[[1]])) )
colnames(designBulk) <- c("donorID","type")
designBulk$studyGroup <- designByDonor[ designBulk$donorID,"studyGroup"]
designBulk$nCells <- nCells

design_mat <- model.matrix(~0+studyGroup:type+nCells,data=designBulk)
colnames(design_mat) <- gsub("studyGroup","",colnames(design_mat))
colnames(design_mat) <- gsub("type","",colnames(design_mat))
colnames(design_mat) <- gsub("\\:","_",colnames(design_mat))

cont.matrix <- makeContrasts(
     T1D_treg = T1D_Treg-Control_Treg,
     T1D_tconv = T1D_Tconventional-Control_Tconventional,
     levels=design_mat)

vwts <- voomWithQualityWeights(bulk_pc_norm[ ,rownames(design_mat)], design= design_mat, plot=T, span=0.1)
vfit <- lmFit(vwts, design = design_mat)
vfit_eb <- eBayes(vfit)
vfit_c <- contrasts.fit(vfit, cont.matrix)
vfit_c_eb <- eBayes(vfit_c)
t1dExpandedDE <- list()
t1dExpandedDE[["Treg"]] <- topTable (vfit_c_eb, coef = 1, number=Inf, sort.by="P")
t1dExpandedDE[["Tconv"]] <- topTable (vfit_c_eb, coef = 2, number=Inf, sort.by="P")
sapply(t1dExpandedDE, function(l) table(l$adj.P.Val <= 0.05))
lapply(t1dExpandedDE, function(l) table( l$adj.P.Val <= 0.05))
for( i in 1:length(t1dExpandedDE) ){
  t1dExpandedDE[[i]]$HGNC.symbol <- ens2hgnc[ rownames(t1dExpandedDE[[i]])]
}


for( comp in names(t1dExpandedDE) ){
  print(comp)
  de <- t1dExpandedDE[[comp]]
  up <- rownames(de)[ de$adj.P.Val <= 0.05 & de$logFC > 0]
  down <- rownames(de)[ de$adj.P.Val <= 0.05 & de$logFC < 0]
  print(table(de$logFC[de$adj.P.Val <= 0.05] > 0))
  write.table(up, paste0("../../data/2023-10-23/",comp,"_T1DupExpanded_FDR0.05.txt"), quote=FALSE,col.names=FALSE,row.names=FALSE)
  write.table(down, paste0("../../data/2023-10-23/",comp,"_HCupExpanded_FDR0.05.txt"), quote=FALSE,col.names=FALSE,row.names=FALSE)
  
  de <- t1dDE[[comp]]
  up <- rownames(de)[ de$adj.P.Val <= 0.05 & de$logFC > 0]
  down <- rownames(de)[ de$adj.P.Val <= 0.05 & de$logFC < 0]
  print(table(de$logFC[de$adj.P.Val <= 0.05] > 0))
  write.table(up, paste0("../../data/2023-10-23/",comp,"_T1Dup_FDR0.05.txt"), quote=FALSE,col.names=FALSE,row.names=FALSE)
  write.table(down, paste0("../../data/2023-10-23/",comp,"_HCup_FDR0.05.txt"), quote=FALSE,col.names=FALSE,row.names=FALSE)
}






if(FALSE){
  saveRDS(t1dExpandedDE,"../../data/2023-07-13/t1dExpandedDE.RDS")
  saveRDS(design_bulk,"../../data/2023-07-13/t1dExpanded_metadata.RDS")
  saveRDS(bulk_pc_norm,"../../data/2023-07-13/t1dExpanded_expression.RDS")
} else{
  t1dExpandedDE <- readRDS("../../data/2023-07-13/t1dExpandedDE.RDS")
  design_bulk <- readRDS("../../data/2023-07-13/t1dExpanded_metadata.RDS")
  bulk_pc_norm <-"../../data/2023-07-13/t1dExpanded_expression.RDS"
}


### Here do roast for these:

library(msigdbr)
c2 = data.frame( msigdbr(species = "Homo sapiens", category = "C2") )
c7 = data.frame( msigdbr(species = "Homo sapiens", category = "C7") )
h = data.frame( msigdbr(species = "Homo sapiens", category = "H") )

sets <- unique(c7$gs_name)
z <- sets[grepl("CD4_",toupper(sets))]

sets <- unique(c2$gs_name)
sets <- sets[ grepl("IL[0-9]+",sets) | grepl("PROSTAG",sets) | grepl("CYTOK",sets) | grepl("TNFRSF9",sets) | grepl("CD",sets) ]
c2_list <- lapply( sets, function(set)  as.character(c2[ c2$gs_name == set,"human_gene_symbol"] ) )
names(c2_list) <- sets

tregT1DRoast_c2 <- roast(
      y=vwts,
      index=ids2indices(c2_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,1],
      nrot = 8000)

tconvT1DRoast_c2 <- roast(
      y=vwts,
      index=ids2indices(c2_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,2],
      nrot = 8000)

tconvT1DRoast_c7 <- roast(
      y=vwts,
      index=ids2indices(c7_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,2],
      nrot = 8000)


h = data.frame( msigdbr(species = "Homo sapiens", category = "H") )
hallmark <- unique(h$gs_name)
hallmark_list <- lapply(hallmark, function(hname) h$human_gene_symbol[ h$gs_name == hname])
names(hallmark_list) <- hallmark
tconvT1DRoast_h <- roast(
      y=vwts,
      index=ids2indices(hallmark_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,2],
      nrot = 8000)

tregT1DRoast_h <- roast(
      y=vwts,
      index=ids2indices(hallmark_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,1],
      nrot = 8000)

ThTregSets <- list(ThUp=thUp,TregUp=tregUp )
#ThTregSets <- list(ThUp=ens2hgnc[thUp],TregUp=ens2hgnc[tregUp] )

tconvT1DRoast_ThTregSets <- roast(
      y=vwts,
      index=ids2indices(ThTregSets, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,2],
      nrot = 8000)

tregT1DRoast_ThTregSets <- roast(
      y=vwts,
      index=ids2indices(ThTregSets, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,1],
      nrot = 8000)

limma_volcano_highlight <- function( gtable, outfile="", title="", gs=c(), p_cutoff = 0.05, fc_cutoff = 1.0, labp=0.05  ){
  
  gtable$highlight <- gtable$HGNC.symbol %in% gs
  gtable <- gtable[ order( gtable$highlight),]
  
  ixes = c(1)
  if( length(gs) == 0){
    ixes <-  which(gtable$adj.P.Val <= p_cutoff)
  }else{
    ixes <- which(gtable$adj.P.Val <= labp & gtable$HGNC.symbol %in% gs)
  }
  if( length(ixes) > 50 ){
    ixes <- ixes[1:50]
  }
  ixes <- 1:20
  #png(outfile, height = 600, width = 900)
  p <- ggplot(data = gtable, aes(x=logFC, y=-log10(adj.P.Val), color = highlight)) +
    geom_point(size=1.5, shape = 19) + scale_color_manual(values = c("FALSE"="grey", "TRUE"="red"))+
    theme(legend.position = "none") + labs(x="logFC",y="-log10 FDR",title=title)+
    geom_hline(yintercept=-log10(p_cutoff), color="black",linetype="dotted",size=1.0)+
    geom_vline(xintercept=-fc_cutoff, color="black",linetype="dotted",size=1.0)+
    geom_vline(xintercept=fc_cutoff, color="black",linetype="dotted",size=1.0)+
    theme(text = element_text(size=16)) 
    if(length(ixes)>0){
      p <- p + geom_text_repel(data=gtable[gtable$highlight,][ixes,], aes(logFC, -log10(adj.P.Val), fontface="bold", label=HGNC.symbol), size=4, color="black") 
    }
  print(p)
  #dev.off()
  return(p)
}

title <- "T1D vs. Control Expanded Conventional CD4\nHallmark TGF Beta Signaling\nFDR: 0.028"
png("../../data/2023-10-23/TconvExpanded_T1DvHC_TGFBetaSignaling_volcano.png",width=500,height=500)
limma_volcano_highlight( t1dExpandedDE[["Tconv"]], title=title,gs=hallmark_list[["HALLMARK_TGF_BETA_SIGNALING"]], fc_cutoff=abs(log2(sqrt(2))))
dev.off()

title <- "T1D vs. Control Conventional CD4\nHallmark TGF Beta Signaling\nFDR: 0.028"
png("../../data/2023-10-23/Tconv_T1DvHC_TGFBetaSignaling_volcano.png",width=500,height=500)
limma_volcano_highlight( t1dDE[["Tconv"]], title=title,gs=hallmark_list[["HALLMARK_TGF_BETA_SIGNALING"]], fc_cutoff=abs(log2(sqrt(2))))
dev.off()

title <- "T1D vs. Control Expanded Conventional CD4\nTh markers\nFDR: 0.04"
limma_volcano_highlight( t1dExpandedDE[["Tconv"]], title=title,gs=thUp, fc_cutoff=abs(log2(sqrt(2))))


de <- t1dExpandedDE[["Tconv"]]
de$anno <- de$HGNC.symbol %in% hallmark_list[["HALLMARK_TGF_BETA_SIGNALING"]]
de <- de[order(de$anno),]
## Here do significant ones
for( ctype in c("Treg","Tconv") ){
  de <- t1dExpandedDE[[ctype]]
  df <- designBulk[ grepl(ctype,designBulk$type) ,]
  
  sigs <- rownames(de)[de$adj.P.Val <= 0.05]
  df <- df[ order(df$studyGroup,df$donorID),]
  cols <- list(studyGroup=groupCols)
  cols[["donorID"]] <- make_colors( unique(df$donorID))
  tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,rownames(df)]))))
  rownames(tp) <- ens2hgnc[ rownames(tp)]
  tp <- tp[ !apply(tp,1,function(r) any(is.na(r))),]
  ha <- HeatmapAnnotation( df=df[colnames(tp),c("studyGroup","donorID","nCells")], col=cols[c("studyGroup","donorID")])
  pdf( paste0("../../data/2025-01-10/",ctype,"_Expanded_T1DvHC_heatmap.pdf"), width=7.5,height=6.5)
  p <- Heatmap(tp,show_column_names=FALSE,top_annotation=ha, name="scaled\nlog\nexpression", column_title=paste0("T1D vs. Control, ", length(sigs)," genes\nExpanded ",ctype), column_split = df$studyGroup)
  print(p)
  dev.off()
}




barcode <- function( comp, gs1, nam=" ", val = "logFC", gsname = " ", comps=comparisons ){
  if( nam == " " ){
    nam <- comp
  }
  de <- comps[[comp]]
  de$val <- -log10(de$adj.P.Val)*sign(de$logFC)
  idx <- de$HGNC.symbol %in% gs1
  p <- barcodeplot(de$logFC,idx, alpha=0.8,main=paste0(nam,"\n",gsname),xlab=expression(log[2]~'fold-change'), quantiles=c(-1,1))
  return(p)
}
png("../../data/2023-10-23/TconvExpanded_T1DvHC_TGFBetaSignaling_barcode.png",width=600,height=300)
barcode( "Tconv", hallmark_list[["HALLMARK_TGF_BETA_SIGNALING"]], gsname = "Hallmark TGF Beta Signaling, FDR=0.028", comps= t1dExpandedDE, nam="T1D vs. HC, Expanded T-conventional Cells")
dev.off()

barcode( "Tconv", c2_list[["KEGG_CYTOKINE_CYTOKINE_RECEPTOR_INTERACTION"]], gsname = "KEGG Cytokine-Cytokine Receptor Interaction, FDR=0.028", comps= t1dExpandedDE, nam="T1D vs. HC, Expanded T-conventional Cells")


barcode( "Treg", hallmark_list[["HALLMARK_TGF_BETA_SIGNALING"]], gsname = "Hallmark TGF Beta Signaling", comps= t1dExpandedDE, nam="T1D vs. HC, Tregs")

## Plot Heatmap of TGF Beta sigaling gene set Treg vs. Tconv
de <- t1dExpandedDE[["Tconv"]]
gset <- "HALLMARK_TGF_BETA_SIGNALING"
sigs <- rownames(de)[ de$HGNC.symbol %in% hallmark_list[[gset]]]
df <- design_bulk[ design_bulk$type == "Tconventional",]
df <- df[ order(df$studyGroup,df$srid),]
cols <- lapply( df, function(col) make_colors(unique(col)) )
tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,rownames(df)]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
tp <- tp[ !apply(tp,1,function(r) any(is.na(r))),]
ha <- HeatmapAnnotation( df=df[colnames(tp),c("studyGroup","srid")], col=cols[c("studyGroup","srid")])
pdf( "../../data/2023-10-23/TconvExpanded_T1DvHC_TGFBetaSignaling_heatmap.pdf", width=6.5,height=8.5)
p <- Heatmap(tp,show_column_names=FALSE,top_annotation=ha, name="scaled\nlog\nexpression", column_title=paste0(gset,"\nT1D vs. Control\nExpanded T-conventional Cells"), column_split = df$studyGroup)
print(p)
dev.off()



## Here do Cytokine-Cytokine receptor interaction
de <- t1dExpandedDE[["Tconv"]]
gset <- "KEGG_CYTOKINE_CYTOKINE_RECEPTOR_INTERACTION"
sigs <- rownames(de)[ de$HGNC.symbol %in% c2_list[[gset]]]
df <- design_bulk[ design_bulk$type == "Tconventional",]
df <- df[ order(df$studyGroup,df$srid),]
cols <- lapply( df, function(col) make_colors(unique(col)) )
tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,rownames(df)]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
tp <- tp[ !apply(tp,1,function(r) any(is.na(r))),]
ha <- HeatmapAnnotation( df=df[colnames(tp),c("studyGroup","srid")], col=cols[c("studyGroup","srid")])
pdf( "../../data/2023-10-23/TconvExpanded_T1DvHC_TGFBetaSignaling_heatmap.pdf", width=6.5,height=8.5)
p <- Heatmap(tp,show_column_names=FALSE,top_annotation=ha, name="scaled\nlog\nexpression", column_title=paste0(gset,"\nT1D vs. Control\nExpanded T-conventional Cells"), column_split = df$studyGroup)
print(p)
dev.off()

## Plot Heatmap of TGF Beta sigaling gene set Treg vs. Tconv
de <- t1dExpandedDE[["Tconv"]]
gset <- "HALLMARK_TGF_BETA_SIGNALING"
sigs <- rownames(de)[de$adj.P.Val <= 0.05]
df <- design_bulk[ design_bulk$type == "Tconventional",]
df <- df[ order(df$studyGroup,df$srid),]
cols <- lapply( df, function(col) make_colors(unique(col)) )
tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,rownames(df)]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
tp <- tp[ !apply(tp,1,function(r) any(is.na(r))),]
ha <- HeatmapAnnotation( df=df[colnames(tp),c("studyGroup","srid","nCells")], col=cols[c("studyGroup","srid")])
pdf( "../../data/2023-10-23/TconvExpanded_T1DvHC_FDR0.05_heatmap.pdf", width=6.5,height=7)
p <- Heatmap(tp,show_column_names=FALSE,top_annotation=ha, name="scaled\nlog\nexpression", column_title=paste0("\nT1D vs. Control, FDR <= 0.05\nExpanded T-conventional Cells"), column_split = df$studyGroup)
print(p)
dev.off()

de <- t1dExpandedDE[["Tconv"]]
sigs <- rownames(de)[de$adj.P.Val <= 0.05]
df <- design_bulk[ design_bulk$type == "Tconventional",]
df <- df[ order(df$studyGroup,df$srid),]
cols <- lapply( df, function(col) make_colors(unique(col)) )
tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,rownames(df)]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
tp <- tp[ !apply(tp,1,function(r) any(is.na(r))),]
ha <- HeatmapAnnotation( df=df[colnames(tp),c("studyGroup","srid","nCells")], col=cols[c("studyGroup","srid")])
#pdf( "../../data/2023-10-23/TconvExpanded_T1DvHC_FDR0.05_heatmap.pdf", width=6.5,height=7)
p <- Heatmap(tp,show_column_names=FALSE,top_annotation=ha, name="scaled\nlog\nexpression", column_title=paste0("\nT1D vs. Control, FDR <= 0.05\nExpanded T-conventional Cells"), column_split = df$studyGroup)
print(p)
#dev.off()

```

```{r 10/23/23 Karen Request}

# Email from Karen on 10/23/23
#"...can send me the following by midday Wednesday?
# -String db plot of Tonv HC vs T1D DEGs showing SMAD gene as one of the nodes
# -TGFB Hallmark gene set in HC vs T1D Tconv cells
# -Info on heatmap of Tconv HC vs T1D DEGs
#     -What is the FDR for this heatmap?
#     -How is the heatmap organized (see below)? Are the HC Tconv on the right being compared to T1D Tconv on the   left? Are these just expanded cells and if so what was the expansion cutoff- >1 cell?

### Make Heatmap
tregDE$anno <- tregDE$HGNC.symbol %in% c2_list[["AUJLA_IL22_AND_IL17A_SIGNALING"]]
tregDE <- tregDE[order(tregDE$anno),]
ggplot( tregDE, aes(x=logFC,y=-log10(adj.P.Val),color=anno)) + geom_point()

tregDE <- t1dDE[["Treg"]]
gset <- "KEGG_CYTOKINE_CYTOKINE_RECEPTOR_INTERACTION"
sigs <- rownames(tregDE)[ tregDE$HGNC.symbol %in% c2_list[[gset]]]
df <- design_bulk[ design_bulk$type == "Treg",]
df <- df[ order(df$studyGroup,df$srid),]
cols <- lapply( df, function(col) make_colors(unique(col)) )
tp <- t(scale(t(log2(1+bulk_pc_norm[sigs,rownames(df)]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
tp <- tp[ !apply(tp,1,function(r) any(is.na(r))),]
ha <- HeatmapAnnotation( df=df[colnames(tp),c("studyGroup","srid")], col=cols[c("studyGroup","srid")])
pdf( paste0("../../data/2022-11-15/Hallmark/T1D_DE_",gset,"_Treg_heatmap.pdf"), width=6.5,height=7)
p <- Heatmap(tp,show_column_names=FALSE,top_annotation=ha, name="scaled\nlog\nexpression", column_title=paste0(gset,"\nT1D vs. Control\nTreg"), cluster_columns=FALSE)
print(p)
dev.off()


```

``` {r goana_and_kegga for infusion group 3}
tidy_bh_go <- function(go){
  # For Goana output
  if("Term" %in% colnames(go) ){
    up <- go[,c("Term","Ont","N","Up","P.Up")]
    down <- go[,c("Term","Ont","N","Down","P.Down")]
    colnames(down) <- c("Term","Ont","N","N Genes Changed","PValue")
    colnames(up) <- c("Term","Ont","N","N Genes Changed","PValue")
  }
  # For Kegga output
  else{
    up <- go[,c("Pathway","N","Up","P.Up")]
    down <- go[,c("Pathway","N","Down","P.Down")]
    colnames(down) <- c("Pathway","N","N Genes Changed","PValue")
    colnames(up) <- c("Pathway","N","N Genes Changed","PValue")
  }
  down$direction <- rep("Down",nrow(down))
  up$direction <- rep("Up",nrow(down))
  go <- rbind(up,down)
  go$QValue <- p.adjust(go$PValue,method="BH")
  go <- go[order(go$PValue),]
  return(go)    
}

ezkey <- read.table("../../../data/ensemblkey_GRCh38.txt", header = TRUE,sep = "\t",na.strings = "") 
ens2entrez <- ezkey$entrezgene
names(ens2entrez) <- ezkey$ensembl_gene_id

entrez2ens <- ezkey$ensembl_gene_id[ !is.na(ezkey$entrezgene)]
names(entrez2ens) <- ezkey$entrezgene[ !is.na(ezkey$entrezgene)]

keggs <- list()
gos <- list()
plotdir <- "../../data/2023-03-15/Expansion2GroupDE/"
plotdir <- "../../data/2023-10-23/"

for(i in 1:ncol(vfit_c_eb$contrasts) ){
#for(i in c(1) ){

  cname <- colnames(vfit_c_eb$contrasts)[i]
  print( colnames(vfit_c_eb$contrasts)[i])
  go <- goana(vfit_c_eb,coef=i, geneid=ens2entrez[rownames(vfit_c_eb)],FDR=0.1)
  go <- tidy_bh_go(go)
  gos[[colnames(vfit_c_eb$contrasts)[i]]] <- go

  write.table(go,paste0(plotdir,"go_",cname,".txt"),quote=FALSE,sep="\t",col.names=NA)
  
  print(table(go$QValue <= 0.05))
  
  kegg <- kegga(vfit_c_eb,coef=i, geneid=ens2entrez[rownames(vfit_c_eb)],FDR=0.1)
  kegg <- tidy_bh_go(kegg)
  keggs[[colnames(vfit_c_eb$contrasts)[i]]] <- kegg
  
  print(table(kegg$QValue <= 0.05))
  
  write.table(kegg,paste0(plotdir,"kegg_",cname,".txt"),quote=FALSE,sep="\t",col.names=NA)
}

```

```{r Pseudobulk Clusters}

design_qc$cellType[ design_qc$project == "P390-1"] <- "Tconventional"
design_qc$cellType[ design_qc$project == "P390-2"] <- "Treg"
design_qc$cluster <- cds_coords[ rownames(design_qc),"cluster"]
design_qc$group <- paste0(design_qc$sampleRepositoryID, "_", design_qc$cluster)
groups <- unique(design_qc$group)
libsByGroup <- lapply(groups, function(group) design_qc$libid[ design_qc$group == group])
names(libsByGroup) <- groups
libsByGroup <- libsByGroup[ sapply(libsByGroup,length) > 0]

bulk_pc_norm <- sapply( libsByGroup, function(libs) rowSums(counts_pc[,c(libs,libs)] )/2 )
bulk_pc_norm <- bulk_pc_norm[ rowMeans(bulk_pc_norm > 0) >= 0.1, ]

bulk_pc_norm <- normalize_counts(bulk_pc_norm,"tmm")
design_bulk <- data.frame( t( sapply( colnames(bulk_pc_norm), function(s) strsplit(s,"_")[[1]]) ) )
colnames(design_bulk) <- c("srid","cluster")

design_mat <- model.matrix(~0+cluster+srid,data=design_bulk)
colnames(design_mat) <- gsub("cluster","c",colnames(design_mat))
colnames(design_mat) <- gsub("srid","",colnames(design_mat))

clusts <- colnames(design_mat)[ grepl("c",colnames(design_mat))]
cont.matrix <- matrix(0,ncol(design_mat),length(clusts))
rownames(cont.matrix) <- colnames(design_mat)
for( i in 1:length(clusts) ){
  clust <- clusts[i]
  cont.matrix[clusts,i] <- -1/(length(clusts)-1)
  cont.matrix[clusts[i],i] <- 1
}
colnames(cont.matrix) <- clusts

vwts <- voomWithQualityWeights(bulk_pc_norm[ ,rownames(design_mat)], design= design_mat, plot=T, span=0.1)
vfit <- lmFit(vwts, design = design_mat)
vfit_eb <- eBayes(vfit)
vfit_c <- contrasts.fit(vfit, cont.matrix)
vfit_c_eb <- eBayes(vfit_c)

clustcomps <- lapply( 1:ncol(cont.matrix), function(i) topTable (vfit_c_eb, coef = i, number=Inf, sort.by="P")  )
names(clustcomps) <- colnames(cont.matrix)
for( i in 1:length(clustcomps) ){ 
  clustcomps[[i]]$HGNC.symbol <- ens2hgnc[ rownames(clustcomps[[i]])]
  clustcomps[[i]]$cluster <- names(clustcomps)[i]
  clustcomps[[i]]$Ensemble.ID <- rownames(clustcomps[[i]])

}
lapply(clustcomps, function(l) table( l$adj.P.Val <= 0.05))

topMarkers <- do.call( rbind, clustcomps)
topMarkers <- topMarkers[ topMarkers$logFC > 0 & topMarkers$adj.P.Val <= 0.01,]
topMarkers  <- topMarkers[order(topMarkers$P.Value),]
topMarkers <- topMarkers[!duplicated(topMarkers$HGNC.symbol),]
topN <- do.call( rbind, lapply( unique(topMarkers$cluster), function(clust) topMarkers[topMarkers$cluster==clust,][1:20,]))

clustsMarkersTregsPos <- clustsMarkersTregsPos[order(clustsMarkersTregsPos$p_val),]
clustsMarkersTconvsPos <- clustsMarkersTconvsPos[order(clustsMarkersTconvsPos$p_val),]

top20Tregs <- do.call( rbind, lapply( unique(clustsMarkersTregsPos$cluster), function(clust) clustsMarkersTregsPos[clustsMarkersTregsPos$cluster==clust,][1:20,]))
top20Tconvs <- do.call( rbind, lapply( unique(clustsMarkersTconvsPos$cluster), function(clust) clustsMarkersTconvsPos[clustsMarkersTconvsPos$cluster==clust,][1:20,]))
write.table(top20Tconvs,"../../data/2025-02-10/top20markers_P390Tconvs5.txt",quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)
write.table(top20Tregs,"../../data/2025-02-10/top20markers_P390Tregs3.txt",quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)


design_bulk$anno <- "other"
design_bulk$anno[ design_bulk$cluster %in% c(1,3,4) ] <- "Tconventional"
design_bulk$anno[ design_bulk$cluster %in% c(5,2) ] <- "Treg"

annocols <- c("purple","red","blue")
names(annocols) <- c("other","Tconventional","Treg")

ens <- topN$Ensemble.ID
libs <- rownames(design_bulk); libs <- libs[order(design_bulk$anno,design_bulk$cluster)]
tp <- t(scale(t(log2(1+bulk_pc_norm[ens,libs]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
clustcols <- hue_pal()(length(unique(design_bulk$cluster)))
names(clustcols) <- 1:length(unique(design_bulk$cluster))
ha <- HeatmapAnnotation(df=design_bulk[libs,], col=list(cluster=clustcols, anno=annocols))
pdf("../../data/2023-04-17/cluster_heatmap_top20.pdf", width=6,height =20)
Heatmap(tp,show_column_names=FALSE,column_split=design_bulk[libs,"cluster"],name="scaled\nlog2\nexpression", top_annotation=ha,  cluster_rows=TRUE )
dev.off()


tregDE <- tregDE[order(tregDE$P.Value),]
ens <- rownames(tregDE)[1:140]
libs <- rownames(design_bulk); libs <- libs[order(design_bulk$anno,design_bulk$cluster)]
tp <- t(scale(t(log2(1+bulk_pc_norm[ens,libs]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
clustcols <- hue_pal()(length(unique(design_bulk$cluster)))
names(clustcols) <- 1:length(unique(design_bulk$cluster))
ha <- HeatmapAnnotation(df=design_bulk[libs,], col=list(cluster=clustcols, anno=annocols))
pdf("../../data/2023-04-17/cluster_heatmap_TregTconvGenes.pdf", width=6,height =20)
Heatmap(tp,show_column_names=FALSE,column_split=design_bulk[libs,"cluster"],name="scaled\nlog2\nexpression", top_annotation=ha,  cluster_rows=TRUE )
dev.off()
pdf("../../data/2023-04-17/UMAP_TregTconvDEGenesDisplayed_clusters.pdf",width=6,height=4)
ggplot(cds_coords,aes(x=x,y=y,color=as.factor(cluster)))+ geom_point() + labs(x="UMAP 1",y="UMAP 2",color="cluster")
dev.off()
```

```{r Sharing Treg v Tconv }

### Do they same as above, but subsample each donor so that there are the same numbers of Tregs and Tconvs per person
## 01/17/24 Also, remove the CD45RA+ naive cells as specified by the index sort data.
naivelibs <- design$libid[ design$TNaive == 1]
toFilter <- design_qc$libid[ ! design_qc$libid %in% soFiltered$libid]
dids <- unique(design_qc$donorId)
subTcrs <- tcrs[ tcrs$libid %in% soFiltered$libid,]
libsToKeep <- soFiltered$libid
pairs$chain <- "pair"
pairs$libid <- pairs$sample
pairs$full_nt_sequence <- paste( pairs$CDR3ant, pairs$CDR3bnt )
pairs[,c("CD4Type","donorId")] <- design_qc[ pairs$sample, c("CD4Type","donorId")]
# 08/08/25 edited to look at total sequences, not unique sequences
getSharingSubsampled <- function( did, chain="TRA", N=1000, tcrs){
  # Remove naive libs
  print(did)
  # Is there more within-Treg sharing the within-T-conventional Sharing?
  tconva <- tcrs[ grepl("Tconv",tcrs$CD4Type) & tcrs$chain == chain & tcrs$donorId==did & tcrs$libid %in% libsToKeep,] 
  trega <- tcrs[ tcrs$CD4Type == "Treg" & tcrs$chain == chain & tcrs$donorId==did & tcrs$libid %in% libsToKeep,]

  convashared <- unique( tconva$full_nt_sequence[ duplicated(tconva$full_nt_sequence) ] )
  regashared <- unique( trega$full_nt_sequence[ duplicated(trega$full_nt_sequence) ] )
  
  convshared <- sum(tconva$full_nt_sequence %in% convashared)/nrow(tconva)
  regshared <- sum(trega$full_nt_sequence %in% regashared)/nrow(trega)
  
  if( nrow(tconva) > nrow(trega ) ){
    n1 <- nrow(trega)
    n2 <- nrow(tconva)
    samples <- lapply( 1:N, function(i) tconva[sample(1:n2,n1),] )
    convashared <- sapply( samples, function(l) unique( l$full_nt_sequence[ duplicated(l$full_nt_sequence)]))
    convshared <- mean(sapply( 1:N, function(i) sum( samples[[i]]$full_nt_sequence %in% convashared[[i]])/nrow( samples[[i]]) ))
  }
    if( nrow(trega) > nrow(tconva) ){
    n1 <- nrow(tconva)
    n2 <- nrow(trega)
    samples <- lapply( 1:N, function(i) trega[sample(1:n2,n1),] )
    regashared <- sapply( samples, function(l) unique( l$full_nt_sequence[ duplicated(l$full_nt_sequence)]))
    regshared <- mean(sapply( 1:N, function(i) sum( samples[[i]]$full_nt_sequence %in% regashared[[i]])/nrow( samples[[i]]) ))
  }
  v <- c(sharedTconventionalProportion=convshared, sharedTregProportion=regshared)
  return(v)
}
getSharingSubsampledByPair <- function( did, chain="pair", N=1000, tcrs){
  # Remove naive libs
  print(did)
  # Is there more within-Treg sharing the within-T-conventional Sharing?
  tconva <- tcrs[ grepl("Tconv",tcrs$CD4Type) & tcrs$chain == chain & tcrs$donorId==did & tcrs$libid %in% libsToKeep,] 
  trega <- tcrs[ tcrs$CD4Type == "Treg" & tcrs$chain == chain & tcrs$donorId==did & tcrs$libid %in% libsToKeep,]

  convashared <- unique( tconva$full_nt_sequence[ duplicated(tconva$full_nt_sequence) ] )
  regashared <- unique( trega$full_nt_sequence[ duplicated(trega$full_nt_sequence) ] )
  
  convshared <- sum(tconva$full_nt_sequence %in% convashared)/nrow(tconva)
  regshared <- sum(trega$full_nt_sequence %in% regashared)/nrow(trega)
  
  if( nrow(tconva) > nrow(trega ) ){
    n1 <- nrow(trega)
    n2 <- nrow(tconva)
    samples <- lapply( 1:N, function(i) tconva[sample(1:n2,n1),] )
    convashared <- sapply( samples, function(l) unique( l$full_nt_sequence[ duplicated(l$full_nt_sequence)]))
    convshared <- mean(sapply( 1:N, function(i) sum( samples[[i]]$full_nt_sequence %in% convashared[[i]])/nrow( samples[[i]]) ))
  }
    if( nrow(trega) > nrow(tconva) ){
    n1 <- nrow(tconva)
    n2 <- nrow(trega)
    samples <- lapply( 1:N, function(i) trega[sample(1:n2,n1),] )
    regashared <- sapply( samples, function(l) unique( l$full_nt_sequence[ duplicated(l$full_nt_sequence)]))
    regshared <- mean(sapply( 1:N, function(i) sum( samples[[i]]$full_nt_sequence %in% regashared[[i]])/nrow( samples[[i]]) ))
  }
  v <- c(sharedTconventionalProportion=convshared, sharedTregProportion=regshared)
  return(v)
}
sharedStatsA <-  data.frame(t(sapply( dids, function(did) getSharingSubsampled(did,"TRA",tcrs=subTcrs)  )))
sharedStatsA$chain <- "TRA"
sharedStatsB <-  data.frame(t(sapply( dids, function(did) getSharingSubsampled(did,"TRB",tcrs=subTcrs)  )))
sharedStatsB$chain <- "TRB"
sharedStatsPair <- data.frame(t(sapply( dids, function(did) getSharingSubsampled(did,"pair",tcrs=pairs)  )))
sharedStatsPair$chain <- "pair"
sharedStats <- rbind(sharedStatsA, sharedStatsB,sharedStatsPair)
sharedStats$did <- c(dids,dids,dids)


sharedStats$studyGroup <- designByDonor[dids,"studyGroup"]
sharedStats$log2FoldDifference <- log2((sharedStats$sharedTregProportion+0.01)/ (sharedStats$sharedTconventionalProportion+0.01))

diffs <- sharedStats$sharedTconventionalProportion-sharedStats$sharedTregProportion
diffs <- diffs[!is.na(diffs)]

ix <- sharedStats$chain == "TRA"
diffs <- sharedStats$sharedTconventionalProportion[ix]-sharedStats$sharedTregProportion[ix]
diffs <- diffs[!is.na(diffs)]
pvala <- t.test(diffs)$p.value
print( t.test(diffs)$p.value )

ix <- sharedStats$chain == "TRB"
diffs <- sharedStats$sharedTconventionalProportion[ix]-sharedStats$sharedTregProportion[ix]
diffs <- diffs[!is.na(diffs)]
pvalb <- t.test(diffs)$p.value

print( t.test(diffs)$p.value )

ix <- sharedStats$chain == "pair"
diffs <- sharedStats$sharedTconventionalProportion[ix]-sharedStats$sharedTregProportion[ix]
diffs <- diffs[!is.na(diffs)]
pvalp <- t.test(diffs)$p.value
print( t.test(diffs)$p.value )

sharedStatsLong <- reshape2::melt(sharedStats[,c("did","studyGroup","chain","sharedTconventionalProportion","sharedTregProportion")], id.vars=c("did","studyGroup","chain"))
colnames(sharedStatsLong) <- c("did","studyGroup","chain","CD4Type","proportion")
sharedStatsLong$CD4Type <- ifelse(sharedStatsLong$CD4Type == "sharedTconventionalProportion","Tconv","Treg")
pdf("../../data/2025-02-10/PaperFigures/sharedJunctionProportion_Subsampled_nonNaive_boxplots.pdf",width=8,height=6)
sharedStatsLong$chainAnno <- ifelse(sharedStatsLong$chain == "TRA", paste0("TRA\np-value: ",format(signif(pvala,3),scientific=TRUE)), paste0("TRB\np-value: ",format(signif(pvalb,3),scientific=TRUE)) )
ggplot(sharedStatsLong,aes(x=CD4Type,y=proportion,color=studyGroup)) + geom_boxplot(color="grey",outlier.color=NA) + geom_point() + geom_line( aes(group=did)) + labs(x="CD4 Type",y="median proportion\nwith shared nucleotide sequence", color="",title="Shared Junction Proportions\nSubsampled to match Tconv and\nTreg numbers per donor (1000 subsamples)") + facet_wrap(~chainAnno)
dev.off()


subdf <- sharedStatsLong[sharedStatsLong$chain == "pair",]

ix <- sharedStats$chain == "pair"
diffs <- sharedStats$sharedTconventionalProportion[ix]-sharedStats$sharedTregProportion[ix]
diffs <- diffs[!is.na(diffs)]
t1d = sharedStats$studyGroup[ix] == "T1D"
pvalp_t1d <- signif( t.test(diffs[t1d])$p.value,3)
pvalp_hc <- signif( t.test(diffs[!t1d])$p.value, 3 )

subdf$groupAnno <- paste0( subdf$studyGroup, "\np: ", ifelse( subdf$studyGroup == "T1D", pvalp_t1d, pvalp_hc) )
pdf("../../data/2025-02-10/PaperFigures/sharedNtProportion_Subsampled_nonNaive_pair_boxplots.pdf",width=5,height=5.5)
png("../../data/2025-02-10/PaperFigures/sharedNtProportion_Subsampled_nonNaive_pair_boxplots.png",width=350,height=400)
ggplot(subdf,aes(x=CD4Type,y=proportion)) + geom_boxplot(outlier.color=NA) + geom_point() + geom_line( aes(group=did)) + labs(x="CD4 Type",y="median proportion\nwith shared nucleotide sequence", color="",title="Shared Nt Pair Prop\nSubsampled")  + facet_wrap(~groupAnno) + guides(color="none")
dev.off()


### Do they same as above, but subsample each donor so that there are the same numbers of Tregs and Tconvs per person
## 01/22/24 Do naive Treg vs Tconv,
naivelibs <- design$libid[ design$TNaive == 1]
getSharingSubsampled <- function( srid, chain="TRA", N=500){
  # Remove naive libs
  
  # Is there more within-Treg sharing the within-T-conventional Sharing?
  tconva <- tcrs[ tcrs$CD4Type == "Tconv" & tcrs$chain == chain & tcrs$sampleRepositoryID==srid & ! tcrs$libid %in% c(iNKTMaitLibids,toFilter, naivelibs),] 
  trega <- tcrs[ tcrs$CD4Type == "Treg" & tcrs$chain == chain & tcrs$sampleRepositoryID==srid & ! tcrs$libid %in% c(iNKTMaitLibids,toFilter, naivelibs),]

  convashared <- unique( tconva$junction[ duplicated(tconva$junction) ] )
  regashared <- unique( trega$junction[ duplicated(trega$junction) ] )
  
  convshared <- sum(tconva$junction %in% convashared)/nrow(tconva)
  regshared <- sum(trega$junction %in% regashared)/nrow(trega)
  
  if( nrow(tconva) > nrow(trega ) ){
    n1 <- nrow(trega)
    n2 <- nrow(tconva)
    samples <- lapply( 1:N, function(i) tconva[sample(1:n2,n1),] )
    convashared <- sapply( samples, function(l) unique( l$junction[ duplicated(l$junction)]))
    convshared <- mean(sapply( 1:N, function(i) sum( samples[[i]]$junction %in% convashared[[i]])/nrow( samples[[i]]) ))
  }
    if( nrow(trega) > nrow(tconva) ){
    n1 <- nrow(tconva)
    n2 <- nrow(trega)
    samples <- lapply( 1:N, function(i) trega[sample(1:n2,n1),] )
    regashared <- sapply( samples, function(l) unique( l$junction[ duplicated(l$junction)]))
    regshared <- mean(sapply( 1:N, function(i) sum( samples[[i]]$junction %in% regashared[[i]])/nrow( samples[[i]]) ))
  }
  v <- c(sharedTconventionalProportion=convshared, sharedTregProportion=regshared)
  return(v)
}
sharedStatsA <-  data.frame(t(sapply( srids, function(srid) getSharingSubsampled(srid,"TRA")  )))
sharedStatsA$chain <- "TRA"
sharedStatsB <-  data.frame(t(sapply( srids, function(srid) getSharingSubsampled(srid,"TRB")  )))
sharedStatsB$chain <- "TRB"
sharedStats <- rbind(sharedStatsA, sharedStatsB)
sharedStats$srid <- c(srids,srids)

sharedStats$studyGroup <- sridDf[srids,"studyGroup"]
sharedStats$studyGroup[ sharedStats$srid == "P390-34"] <- "T1D"
sharedStats$log2FoldDifference <- log2((sharedStats$sharedTregProportion+0.01)/ (sharedStats$sharedTconventionalProportion+0.01))

diffs <- sharedStats$sharedTconventionalProportion-sharedStats$sharedTregProportion
diffs <- diffs[!is.na(diffs)]

ix <- sharedStats$chain == "TRA"
diffs <- sharedStats$sharedTconventionalProportion[ix]-sharedStats$sharedTregProportion[ix]
diffs <- diffs[!is.na(diffs)]
pvala <- t.test(diffs)$p.value
print( t.test(diffs)$p.value )

ix <- sharedStats$chain == "TRB"
diffs <- sharedStats$sharedTconventionalProportion[ix]-sharedStats$sharedTregProportion[ix]
diffs <- diffs[!is.na(diffs)]
pvalb <- t.test(diffs)$p.value

print( t.test(diffs)$p.value )

sharedStatsLong <- melt(sharedStats[,c("srid","studyGroup","chain","sharedTconventionalProportion","sharedTregProportion")], id.vars=c("srid","studyGroup","chain"))
colnames(sharedStatsLong) <- c("srid","studyGroup","chain","CD4Type","proportion")
sharedStatsLong$CD4Type <- ifelse(sharedStatsLong$CD4Type == "sharedTconventionalProportion","Tconv","Treg")
png("../../data/2023-06-05/sharedJunctionProportion_Subsampled_nonNaive_boxplots.png",width=450,height=600)
sharedStatsLong$chainAnno <- ifelse(sharedStatsLong$chain == "TRA", paste0("TRA\np-value: ",signif(pvala,4)), paste0("TRB\np-value: ",signif(pvalb,4)))
ggplot(sharedStatsLong,aes(x=CD4Type,y=proportion,color=studyGroup)) + geom_boxplot(color="grey",outlier.color=NA) + geom_point() + geom_line( aes(group=srid)) + labs(x="CD4 Type",y="proportion with shared junction", color="",title="Shared Junction Proportions\nSubsampled to match Tconv and\nTreg numbers per donor") + facet_wrap(~chainAnno)
dev.off()

### Differences in sharing between T1D and HC
a <- tcrs[ tcrs$chain == "TRA" & ! tcrs$libid %in% c(toFilter,iNKTMaitLibids,betaDoublets) & tcrs$CD4Type == "Tconv",]
designBySrid <- design_qc[ !duplicated(design_qc$sampleRepositoryID),]
rownames(designBySrid) <- designBySrid$sampleRepositoryID
atab <- data.frame( table( a$sampleRepositoryID) ); colnames(atab) <- c("sampleRepositoryID","count")
atab$studyGroup <- designBySrid[ atab$sampleRepositoryID, "studyGroup"]
ggplot( atab, aes(x=count,fill=studyGroup)) + geom_histogram( position="identity")

subsampleT1DControlProp <- function( chain="TRA", cd4Type = "Tconv", Nsamples = 100){
  a <- tcrs[ tcrs$chain == chain & ! tcrs$libid %in% c(toFilter,iNKTMaitLibids,betaDoublets) & tcrs$CD4Type == cd4Type,]
  atab <- data.frame( table( a$sampleRepositoryID) ); colnames(atab) <- c("sampleRepositoryID","count")
  atab <- atab[ atab$count > 50,]
  donors <- atab$sampleRepositoryID
  n <- min(atab$count)
  print( paste( chain, cd4Type, paste0( Nsamples, " samples"), paste0("ncells: ", n) , sep=", ") )

  getSubsampledSharedProp <- function(suba,n=n){
    suba <- suba[ sample(1:nrow(suba),n),]
    return( sum(suba$junction %in% commonJunctions)/nrow(suba) )
  }
  subProps <- sapply( donors, function(srid) mean(sapply(1:Nsamples, function(i) getSubsampledSharedProp( a[ a$sampleRepositoryID == srid,])   )))
  df <- data.frame( srid = donors, proportion = subProps, studyGroup=designBySrid[donors,"studyGroup"], chain=chain,CD4Type=cd4Type,Ncells=n,Nsamples=Nsamples )
  return(df) 
}
cd4Type <- "Treg"
subPropA <- subsampleT1DControlProp(cd4Type=cd4Type)
subPropB <- subsampleT1DControlProp(cd4Type=cd4Type,chain="TRB")
subProp <- rbind(subPropA, subPropB)

if( cd4Type == "Tconv"){
  png("../../data/2023-06-05/SharedProportionP168P91P474_subsampled_tconvs.png",width=800,height=500)
  p <- ggplot(subProp, aes(x=studyGroup,y=proportion, color=studyGroup)) + geom_boxplot() + geom_point() + facet_wrap(~chain) + labs(y="Shared Proportion",x="", color="", title="Control vs. T1D Shared Proportion\nT conventional cells\nSubsampled to 81 cells (alphas)\nand 74 cells (betas) ")
  print(p)
  dev.off()
} else{
  png("../../data/2023-06-05/SharedProportionP168P91P474_subsampled_tregs.png",width=800,height=500)
  p <- ggplot(subProp, aes(x=studyGroup,y=proportion, color=studyGroup)) + geom_boxplot() + geom_point() + facet_wrap(~chain) + labs(y="Shared Proportion",x="", color="", title="Control vs. T1D Shared Proportion\nTregs\nSubsampled to 52 cells (alphas)\nand 51 cells (betas) ")
  print(p)
  dev.off()
}

### Now look at simpsons diversity?
library(immunarch)
immunarchColumns <- function(tcrs){
  cn <- colnames(tcrs)
  tcrs$Clones <- rep(1,nrow(tcrs))
  tcrs$CDR3.nt <- tcrs$full_nt_sequence
  tcrs$CDR3.aa <- tcrs$junction
  tcrs$Sequence <- tcrs$full_nt_sequence
  tcrs$chain <- sapply( tcrs$v_gene, function(s) strsplit(s,"V")[[1]][1])
  return(tcrs)
}
df <- immunarchColumns(tcrs)


projects <- unique(design_qc$project)
donorTypes <- unique(design_qc$donorType)
libsByProject <- lapply( donorTypes, function(p) design_qc$libid[ design_qc$donorType == p & ! design_qc$libid %in% toFilter]); names(libsByProject) <- donorTypes


invsimpA <- sapply( libsByProject, function(libs) repDiversity(df[ df$libid %in% libs & df$chain == "TRA",], .method='inv.simp', .quant='read.count') )
invsimpB <- sapply( libsByProject, function(libs) repDiversity(df[ df$libid %in% libs & df$chain == "TRB",], .method='inv.simp', .quant='read.count') )

designByProject <- design_qc[ !duplicated(design_qc$donorType),]
rownames(designByProject) <- designByProject$donorType
designByProject$invsimpB <- invsimpB[ designByProject$donorType]
designByProject$invsimpA <- invsimpA[ designByProject$donorType]

pdf("../../data/2023-06-05/alphaDiversity.pdf",width=6,height=6)
ggplot(designByProject, aes(x=CD4Type, y=invsimpA, group=sampleRepositoryID, color=studyGroup)) + geom_line() + geom_point() + labs(y="Inverse Simpson's Diversity",title="Alpha Chain Diversity\nand CD4 Tcell Type")
dev.off()
pdf("../../data/2023-06-05/betaDiversity.pdf",width=6,height=6)
ggplot(designByProject, aes(x=CD4Type, y=invsimpB, group=sampleRepositoryID, color=studyGroup)) + geom_line() + geom_point() + labs(y="Inverse Simpson's Diversity",title="Beta Chain Diversity\nand CD4 Tcell Type")
dev.off()

t.test( designByProject$invsimpA[ designByProject$CD4Type == "Treg"],  designByProject$invsimpA[ designByProject$CD4Type == "Tconventional"] )

t.test( designByProject$invsimpB[ designByProject$CD4Type == "Treg"],  designByProject$invsimpB[ designByProject$CD4Type == "Tconventional"] )

### Do the same, but subsample so that the number of tregs and tconvs are the same.
### Do they same as above, but subsample each donor so that there are the same numbers of Tregs and Tconvs per person
tcrs$donorId <- design[ tcrs$libid, "donorID"]; tcrs$donorID <- tcrs$donorId
df <- immunarchColumns(tcrs)
dids <- unique(tcrs$donorId)
toKeep <- soFiltered$libid
toKeep <- toKeep[!toKeep %in% design$libid[ design$TNaive == 1] ] # Remove Naive Libs
getDiversitySubsampled <- function( did, chain="TRA", N=100){
  # Is there more within-Treg sharing the within-T-conventional Sharing?
  tconva <- df[ grepl("Tconv",df$CD4Type)  & df$chain == chain & df$donorId==did &df$libid %in% c(toKeep),] 
  trega <- df[ df$CD4Type == "Treg" & df$chain == chain & df$donorId==did & df$libid %in% c(toKeep),]

  convashared <- unique( tconva$junction[ duplicated(tconva$junction) ] )
  regashared <- unique( trega$junction[ duplicated(trega$junction) ] )
  
  convDiv <- repDiversity(tconva, .method='inv.simp', .quant='read.count')
  regDiv <- repDiversity(trega, .method='inv.simp', .quant='read.count')
  
  if( nrow(tconva) > nrow(trega) ){
    n1 <- nrow(trega)
    n2 <- nrow(tconva)
    samples <- lapply( 1:N, function(i) tconva[sample(1:n2,n1),] )
    convDiv <- mean(sapply( 1:N, function(i) repDiversity(samples[[i]], .method='inv.simp', .quant='read.count')))
  }
  if( nrow(trega) > nrow(tconva) ){
    n1 <- nrow(tconva)
    n2 <- nrow(trega)
    samples <- lapply( 1:N, function(i) trega[sample(1:n2,n1),] )
    regDiv <- mean(sapply( 1:N, function(i) repDiversity(samples[[i]], .method='inv.simp', .quant='read.count')))
  }
  v <- c(TconventionalDiv=convDiv, TregDiv=regDiv)
  return(v)
}
sharedStatsA <-  data.frame(t(sapply( dids, function(did) getDiversitySubsampled(did,"TRA")  )))
sharedStatsA$chain <- "TRA"
sharedStatsB <-  data.frame(t(sapply( dids, function(did) getDiversitySubsampled(did,"TRB")  )))
sharedStatsB$chain <- "TRB"
sharedStats <- rbind(sharedStatsA, sharedStatsB)
sharedStats$did <- c(dids,dids)

sharedStats$studyGroup <- designByDonor[dids,"studyGroup"]

diffs <- sharedStats$TconventionalDiv-sharedStats$TregDiv
diffs <- diffs[!is.na(diffs)]

ix <- sharedStats$chain == "TRA"
diffs <- sharedStats$TconventionalDiv[ix]-sharedStats$TregDiv[ix]
diffs <- diffs[!is.na(diffs)]
pvala <- t.test(diffs)$p.value
print( t.test(diffs)$p.value )

ix <- sharedStats$chain == "TRB"
diffs <- sharedStats$TconventionalDiv[ix]-sharedStats$TregDiv[ix]
diffs <- diffs[!is.na(diffs)]
pvalb <- t.test(diffs)$p.value

print( t.test(diffs)$p.value )


sharedStatsLong <- reshape2::melt(sharedStats[,c("did","studyGroup","chain","TconventionalDiv","TregDiv")], id.vars=c("did","studyGroup","chain"))
colnames(sharedStatsLong) <- c("did","studyGroup","chain","CD4Type","diversity")
sharedStatsLong$CD4Type <- ifelse(sharedStatsLong$CD4Type == "TconventionalDiv","Tconv","Treg")
#png("../../data/2025-01-10/diversity_subsampled_nonNaive_boxplots.png",width=450,height=600)
pdf("../../data/2025-01-10/diversity_subsampled_nonNaive_boxplots.pdf",width=6.5,height=9)
sharedStatsLong$chainAnno <- ifelse(sharedStatsLong$chain == "TRA", paste0("TRA\np-value: ",round(pvala,4)), paste0("TRB\np-value: ",round(pvalb,4)))
ggplot(sharedStatsLong,aes(x=CD4Type,y=diversity,color=studyGroup)) + geom_boxplot(color="grey",outlier.color=NA) + geom_point() + geom_line( aes(group=did)) + labs(x="CD4 Type",y="Inverse Simpson's Diversity", color="",title="Inverse Simpson's Diversity\nSubsampled to match Tconv and\nTreg numbers per donor") + facet_wrap(~chainAnno) + scale_color_manual( values=groupCols)
dev.off()

divs <- sharedStatsLong[ !is.infinite(sharedStatsLong$diversity),]
divs$typeChain <- paste(divs$CD4Type,divs$chain)

typeChains <- unique( divs$typeChain )
pvals <- sapply( typeChains, function(tc) t.test( divs$diversity[ divs$typeChain == tc & divs$studyGroup == "Control"], divs$diversity[ divs$typeChain == tc & divs$studyGroup == "T1D"])$p.value )

sharedStatsLong$chainAnno <- paste(sharedStatsLong$CD4Type, sharedStatsLong$chain)
sharedStatsLong$chainAnno <- paste0( sharedStatsLong$chainAnno, "\np-value: ", round( pvals[sharedStatsLong$chainAnno],3) )

png("../../data/2023-06-05/diversity_subsampled_boxplots_byT1D.png",width=450,height=600)
ggplot(sharedStatsLong,aes(x=studyGroup,y=diversity, color=studyGroup)) + geom_boxplot(color="grey",outlier.color=NA) + geom_point() + geom_line( aes(group=srid)) + labs(x="",y="Inverse Simpson's Diversity", color="",title="Inverse Simpson's Diversity\nSubsampled to match Tconv and\nTreg numbers per donor") + facet_wrap(~chainAnno, nrow=2)
dev.off()

### Sample all the t1d and control tcrs to the same number
a <- tcrs[ tcrs$chain == "TRA" & ! tcrs$libid %in% c(toFilter,iNKTMaitLibids) & tcrs$CD4Type == "Tconv",]
designBySrid <- design_qc[ !duplicated(design_qc$sampleRepositoryID),]
rownames(designBySrid) <- designBySrid$sampleRepositoryID
atab <- data.frame( table( a$sampleRepositoryID) ); colnames(atab) <- c("sampleRepositoryID","count")
atab$studyGroup <- designBySrid[ atab$sampleRepositoryID, "studyGroup"]
ggplot( atab, aes(x=count,fill=studyGroup)) + geom_histogram( position="identity")

subsampleT1DControlDiv <- function( chain="TRA", cd4Type = "Tconv", Nsamples = 100){
  a <- tcrs[ tcrs$chain == chain & ! tcrs$libid %in% c(toFilter,iNKTMaitLibids) & tcrs$CD4Type == cd4Type,]
  atab <- data.frame( table( a$sampleRepositoryID) ); colnames(atab) <- c("sampleRepositoryID","count")
  atab <- atab[ atab$count > 50,]
  donors <- atab$sampleRepositoryID
  n <- min(atab$count)
  print( paste( chain, cd4Type, paste0( Nsamples, " samples"), paste0("ncells: ", n) , sep=", ") )
  a <- immunarchColumns(a[ a$sampleRepositoryID %in% donors,])
  
  getSubsampledDiversity <- function(suba,n=n){
    suba <- suba[ sample(1:nrow(suba),n),]
    return( repDiversity( suba, .method='inv.simp', .quant='read.count') )
  }
  
  subDivs <- sapply( donors, function(srid) mean(sapply(1:Nsamples, function(i) getSubsampledDiversity( a[ a$sampleRepositoryID == srid,])   )))
  df <- data.frame( srid = donors, div = subDivs, studyGroup=designBySrid[donors,"studyGroup"], chain=chain,CD4Type=cd4Type,Ncells=n,Nsamples=Nsamples )
  return(df) 
}
subDivA <- subsampleT1DControlDiv()
subDivB <- subsampleT1DControlDiv(chain="TRB")
subDiv <- rbind(subDivA, subDivB)

ggplot(subDiv, aes(x=studyGroup,y=div, color=studyGroup)) + geom_boxplot() + geom_point() + facet_wrap(~chain) + labs(y="inverse Simpson's Diversity",x="", color="", title="Control vs. T1D Diversity\nSubsampled to 81 cells (alphas)\nand 74 cells (betas) ")

```


```{r Randomizing and seeing what clusters you get }

subcds <- cds_coords[ sample(1:nrow(cds_coords),100),]

library(igraph)


silhouetteCoefficient <- function( sampleName, clusters, distanceMatrix){
  clusts <- unique(clusters)
  sampleClust <- clusters[sampleName]
  clusterDistances <- sapply( clusts, function(clust) mean(distanceMatrix[sampleName, names(clusters)[ clusters == clust & names(clusters) != sampleName]]))
  names(clusterDistances) <- clusts
  minSampleClust <- min( clusterDistances[ names(clusterDistances) != sampleClust] )
  return( ( minSampleClust - clusterDistances[sampleClust] )/max( minSampleClust, clusterDistances[sampleClust] ) )
}

getMeanSC <- function( data.tmp ){
  
  dist.tmp <- as.matrix( dist(data.tmp, method = "euclidean", diag = TRUE) )
  g <- graph.adjacency(as.matrix(1/dist.tmp), mode = "undirected", weighted = TRUE)
  clouvain <- cluster_louvain( g )
  membs <- igraph::groups(clouvain ) %>%
    lapply(function(x) data.frame(libid = x)) %>%
    bind_rows(.id = "clusterLouvain") %>%
    mutate(
      clusterLouvain = 
        factor(clusterLouvain,
               levels = sort(unique(clusterLouvain))))
  memberships <- membs$clusterLouvain
  names(memberships) <- membs$libid

  scs <- sapply( rownames(data.tmp), function(n) silhouetteCoefficient(n, memberships,dist.tmp) )
  scs <- data.frame( sc=scs, cluster=memberships[rownames(data.tmp)])
  return( c( meansc=mean(scs$sc), numClusters=length(unique(memberships)) ) )
}

z <- getMeanSC(subcds[,c("x","y")])

```

```{r Airline plot for TCR sharing between clusters, tregs and tconvs}


library(plyr)
library(edgeR)
library(ggsignif)
library(monocle3)
library(dplyr)

library(ggplot2); library(reshape2); theme_set(theme_bw(26) + theme(panel.grid.major = element_blank(), 
                                                 panel.grid.minor = element_blank()) +
                              theme(legend.key = element_blank()))
library(plyr)
library(data.table)
library(igraph)
library(scales)

getAirlinePlot <- function(so, alphaBetaPairsOnly=TRUE, colorCol = "seurat_clusters"){ # Take seurat object as input
  cds_coords <- data.frame( Embeddings(so, reduction = "umap") )
  cds_coords <- cbind( cds_coords[so$libid,], so@meta.data)

  
  update_geom_defaults("point", aes(size = 4))
  libs <- cds_coords$libid
  anno.tcrs = tcrs[,c("libid", "v_gene", "j_gene", "junction")]
  colnames(anno.tcrs) = c("libid", "V.gene", "J.gene", "junction") # 1413  zz
#tcrs = tcrs[!duplicated(tcrs[,]),] #1406
  
  if( alphaBetaPairsOnly ){ # only include lines for both alpha and beta
    anno.tcrs <- pairs[ pairs$sample %in% cds_coords$libid,]
    anno.tcrs$V.gene <- paste( anno.tcrs$TRAV, anno.tcrs$TRBV)
    anno.tcrs$J.gene <- paste( anno.tcrs$TRAJ, anno.tcrs$TRBJ)
    anno.tcrs$junction <- paste( anno.tcrs$CDR3ant, anno.tcrs$CDR3bnt )
    anno.tcrs$libid <- anno.tcrs$sample
  } else{ # include either alpha or beta or both
    anno.tcrs <- tcrs
    colnames(anno.tcrs) = gsub("v_gene", "V.gene", colnames(anno.tcrs))
    colnames(anno.tcrs) = gsub("j_gene", "J.gene", colnames(anno.tcrs))
    colnames(anno.tcrs) = gsub("junction", "junction", colnames(anno.tcrs))
    colnames(anno.tcrs) = gsub("libid", "libid", colnames(anno.tcrs))
  
    anno.tcrs = subset(anno.tcrs, libid %in% cds_coords$libid) # subset tcrs to libs in cds object
    anno.tcrs$junction <- anno.tcrs$full_nt_sequence
  }
  ## look at TCR expansion in clusters
  
  cut <- 2
  no = ddply(anno.tcrs,.(V.gene, J.gene,junction), plyr::summarize, sum = length(junction))
  no.sub = subset(no, sum>=cut)
  no.not.sub = subset(no, sum<cut)
  
  E = subset(anno.tcrs, junction %in% no.sub$junction) # 1490
  NE = subset(anno.tcrs, !junction %in% E$junction) # 4232
  E.cell = subset(anno.tcrs, anno.tcrs$libid %in% E$libid) # 844
  NE.cell = subset(anno.tcrs, !anno.tcrs$libid %in% E$libid) # 2203
  
  E.cell.u = E.cell[!duplicated(E.cell$libid),] # 844
  NE.cell.u = NE.cell[!duplicated(NE.cell$libid),] # 2203
  
  ## calculate overlap using circos code
  sub = E
  ##### trim TCR sequences
  melt.tcrs = sub[,]
  melt.tcrs = melt.tcrs[c("libid", "V.gene", "junction")]
  melt.tcrs$junction = as.character(melt.tcrs$junction)
  
  ###### combine TRAV as origing and TRBV as deistination using junction as key
  melt.join = merge(melt.tcrs, melt.tcrs, by = "junction", stringsAsFactors = F)
  melt.join$junction = as.character(melt.join$junction)
  
  #melt.join = subset(melt.join, !melt.join$libid.x== melt.join$libid.y)
  
  ##### limit variables
  
  melt.join = melt.join[c(1,2,4)]
  colnames(melt.join) = c("junction", "orig", "dest")
  
  ##### remove duplicated TCR records including libid
  #melt.join = subset(melt.join, !orig == dest)
  mju = melt.join # 3386
  mju = mju[!duplicated(mju[,]),] # 3770
  
  #### tabulate repeated pairings without libid and create df2
  #table.mju= aggregate(list(numdup=rep(1,nrow(mju[2:ncol(mju)]))), mju[2:ncol(mju)], length)
  table.mju = ddply(mju,.(orig, dest), plyr::summarize, numdup = length(orig))
  
  table.mju$orig = as.character(table.mju$orig)
  table.mju$dest = as.character(table.mju$dest)
  table.set = subset(table.mju, table.mju$orig %in% sub$libid)
  
  ## remove duplicated combinations of orig and dest http://stackoverflow.com/questions/24194879/all-combinations-of-two-and-remove-if-they-are-same-in-r
  g <-graph_from_data_frame(table.set[, 1:2], directed = F)
  g <- simplify(g, remove.multiple = T, remove.loops = T)
  zz = data.frame(get.edgelist(g))
  colnames(zz) = c("orig", "dest")
  
  temp = get.data.frame(g)
  colnames(temp) = c("orig", "dest")
  tempa = data.frame(orig = temp$dest, dest = temp$orig) # 730
  #tempc = rbind(temp, tempa)
  #tempc = tempc[!duplicated(tempc[,]),]
  
  #temp$merge = paste(temp$orig, temp$dest)
  
  t.sub = subset(table.set, table.set$orig %in% zz$orig & table.set$dest %in% zz$dest)
  mdf6 = t.sub # 238
  mdf6 = temp
  
  mdf6 = subset(mdf6, !orig == dest) # 1824
  cds_coords$x <- cds_coords$umap_1
  cds_coords$y <- cds_coords$umap_2
  ## 
  
  ## extract UMAP coordinates from ggplot object and calculate centroids for clusters as mean of x and y coordiintes
  cluster_cols = c("red", "gray")
  cluster_cols2 = c("red", "blue", "gray")
  cluster_cols3 = c("gray", "red")
   
  gb.data = cds_coords
  gb.data$group <- cds_coords[ , colorCol]
  ## extract UMAP coordinates for each expanded cell
  
  mdf6$x = gb.data$x[match(mdf6$orig, gb.data$libid)]
  mdf6$y = gb.data$y[match(mdf6$orig, gb.data$libid)]
  mdf6$xend = gb.data$x[match(mdf6$dest, gb.data$libid)]
  mdf6$yend = gb.data$y[match(mdf6$dest, gb.data$libid)]
  mdf6$group <-  cds_coords[ mdf6$orig, "group"]
  
  for.lines = mdf6
  
  #for.lines = for.lines[,c("lenOver", "x","y","xend", "yend")]
  #for.lines$thick = for.lines$numdup/4
  #for.lines$thick = c(0.00000125)
  for.lines$thick = c(0.2)
  for.lines$cluster <- cds_coords[ for.lines$orig, "cluster"]
  for.lines$newcluster <- cds_coords[ for.lines$orig, "newcluster"]
  
  #for.lines$thick = c(1)
  
  ### colour by cluster
  
  cds_coords$colorCol <- cds_coords[,colorCol]
  ## set defaults
  theme_set(theme_bw(30) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + theme(legend.key = element_blank()))
  
  pal = c('#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffed6f','#b15928', "gray")	
  
  p <- ggplot( cds_coords, aes(x=x,y=y,color=colorCol)) + geom_point(size=1) + geom_curve(data = for.lines, aes(x = x, y = y, xend = xend, yend = yend), color="black", size = for.lines$thick, curvature = 0.6) + theme(legend.position="right") + labs(x="UMAP 1",y="UMAP 2",color="cluster")
  return(p)
}

# assay = NULL; cols = c("lightgrey", "blue"); col.min = -2.5; col.max = 2.5; dot.min = 0; dot.scale = 6;  idents = NULL; group.by = NULL; split.by = NULL; cluster.idents = FALSE; scale = TRUE; scale.by = "radius"; scale.min = NA; scale.max = NA

# This shows unique clonotypes
makeClusterExpansionPlots <- function(so){
  
  subpairs <- pairs[ pairs$sample %in% so$libid,]
  subpairs$pairnt <- paste( subpairs$CDR3ant, subpairs$CDR3bnt)
  subpairs$cluster <- so@meta.data[ subpairs$sample, "seurat_clusters"]
  expandedPairs <- subpairs[ subpairs$pairnt %in% subpairs$pairnt[duplicated(subpairs$pairnt)],]
  nodup <- expandedPairs[ !duplicated( paste( expandedPairs$pairnt, expandedPairs$cluster)),]
  
  clusters <- 1:length(unique(nodup$cluster))-1
  sharingMat <- sapply( clusters, function(c1) sapply( clusters, function(c2) length(intersect(nodup$pairnt[ nodup$cluster == c1], nodup$pairnt[ nodup$cluster == c2] ) ) ) )
  rownames(sharingMat) <- as.character( clusters)
  colnames(sharingMat) <- rownames(sharingMat)
  
  
  # Prepare the matrix for plotting
  tp <- sharingMat
  tp[lower.tri(tp)] <- NA  # Keep only the upper triangular portion
  # Also get rid of the diagonal

  col_fun = colorRamp2(c(0,max(tp,na.rm=TRUE)), c("gray90","red"))
  
  #pdf("../../data/2024-11-19/BetaSharingMatrix_allDonors.pdf",width=8,height=8)
  p <- Heatmap(tp, col=col_fun,
          name = "unique\nclonotype\ncount",
          na_col = "white",   # Set NA values to be white
          cluster_rows = FALSE, # Disable clustering for rows
          cluster_columns = FALSE, # Disable clustering for columns
          show_heatmap_legend = TRUE, column_title="Counts of Expanded Clonotypes Between Clusters\nby full nucleotide sequence",row_title_gp=gpar(fontsize=0), column_names_rot = 0, column_names_side = "top")# Display legend
  return(p)
  # dev.off()
}


# This shows unique clonotypes
# so is the seurat object
# pairs is a data frame where each entry is a cell with columns for both the alpha and beta TCR sequences
library(UpSetR)
makeClusterExpansionUpsetPlots <- function(so,title="", filename="", clusterCol="seurat_clusters"){
  
  subpairs <- pairs[ pairs$sample %in% so$libid,]
  subpairs$pairnt <- paste( subpairs$CDR3ant, subpairs$CDR3bnt) # Combine cdr3 a and b nucleotide sequences
  subpairs$cluster <- so@meta.data[ subpairs$sample, clusterCol ]
  expandedPairs <- subpairs[ subpairs$pairnt %in% subpairs$pairnt[duplicated(subpairs$pairnt)],]

  clusters <- unique(expandedPairs$cluster); clusters <- clusters[order(clusters)]
  categories <- lapply(clusters, function(clust) expandedPairs$pairnt[ expandedPairs$cluster == clust])
  names(categories) <- as.character(clusters)
  p <- UpSetR::upset(fromList(categories), order.by = "freq",mainbar.y.label="count",text.scale=2, keep.order=TRUE, sets=names(categories))

  if( filename == "" ){
    return(p)
  }
  png( filename, width = 600,height=600)
  print(p)
  grid.text(title,x = 0.65, y=0.95, gp=gpar(fontsize=20))
  dev.off()
}

makeClusterExpansionUpsetPlots2 <- function(so,title="", filename="", clusterCol="seurat_clusters"){
  
  subpairs <- pairs[ pairs$sample %in% so$libid,]
  subpairs$pairnt <- paste( subpairs$CDR3ant, subpairs$CDR3bnt) # Combine cdr3 a and b nucleotide sequences
  subpairs$cluster <- so@meta.data[ subpairs$sample, clusterCol ]
  expandedPairs <- subpairs[ subpairs$pairnt %in% subpairs$pairnt[duplicated(subpairs$pairnt)],]

  clusters <- unique(expandedPairs$cluster); clusters <- clusters[order(clusters)]
  categories <- lapply(clusters, function(clust) expandedPairs$pairnt[ expandedPairs$cluster == clust])
  names(categories) <- as.character(clusters)
  
  upset_plot <- ComplexUpset::upset(
    membership_df,
    intersect = cluster_sets,
    name = "Expanded Clonotypes",
    base_annotations = list(
      "Intersection size" = ComplexUpset::intersection_size(
        text = list(size = 3, angle = 0, hjust = 0.5, vjust = 0)
      )
    ),
    stripes = ComplexUpset::upset_stripes(colors = colors),
    set_sizes = ComplexUpset::upset_set_size(
      geom = ggplot2::geom_bar(stat = "count", position = "stack", fill = "grey50"),
      position = "left"
    ),
    sort_sets = FALSE,
    sort_intersections = "descending",
    guides = "over",
    width_ratio = 0.2,
    height_ratio = 0.7
  ) +
    ggtitle(title) +
    labs(caption = paste("Based on", nrow(membership_df), "unique expanded clonotypes")) +
    theme(plot.title = element_text(hjust = 0.5))
  
  
  p <- UpSetR::upset(fromList(categories), order.by = "freq",mainbar.y.label="count",text.scale=2, keep.order=TRUE, sets=names(categories))

  if( filename == "" ){
    return(p)
  }
  png( filename, width = 600,height=600)
  print(p)
  grid.text(title,x = 0.65, y=0.95, gp=gpar(fontsize=20))
  dev.off()
}

  

# This shows the number of cells that share
makeClusterExpansionPlotsByCell <- function(so){
  
  subpairs <- pairs[ pairs$sample %in% so$libid,]
  subpairs$pairnt <- paste( subpairs$CDR3ant, subpairs$CDR3bnt)
  subpairs$cluster <- so@meta.data[ subpairs$sample, "seurat_clusters"]
  expandedPairs <- subpairs[ subpairs$pairnt %in% subpairs$pairnt[duplicated(subpairs$pairnt)],]

  clusters <- unique(nodup$cluster)
  sharingMat <- sapply( clusters, function(c1) sapply( clusters, function(c2) sum(expandedPairs$pairnt[ expandedPairs$cluster == c1] %in% expandedPairs$pairnt[ expandedPairs$cluster == c2]  ) ) )
  rownames(sharingMat) <- as.character( (1:nrow(sharingMat))-1 )
  colnames(sharingMat) <- rownames(sharingMat)
  
  # Prepare the matrix for plotting
  tp <- sharingMat
  tp[lower.tri(tp)] <- NA  # Keep only the upper triangular portion
  # Also get rid of the diagonal

  col_fun = colorRamp2(c(0,max(tp,na.rm=TRUE)), c("gray90","red"))
  
  #pdf("../../data/2024-11-19/BetaSharingMatrix_allDonors.pdf",width=8,height=8)
  p <- Heatmap(tp, col=col_fun,
          name = "unique\nclonotype\ncount",
          na_col = "white",   # Set NA values to be white
          cluster_rows = FALSE, # Disable clustering for rows
          cluster_columns = FALSE, # Disable clustering for columns
          show_heatmap_legend = TRUE, column_title="Counts of Expanded Clonotypes Between Clusters\nby full nucleotide sequence",row_title_gp=gpar(fontsize=0), column_names_rot = 0, column_names_side = "top")# Display legend
  return(p)
  # dev.off()
}

```

```{r 06/11/25 New code for cluster expansion plots}

clusterColumn <- "seurat_clusters"
seuratObject <- soTregs
title <- "TCR sharing analysis"
filename = "upset_plot.png"
displayCounts=TRUE
colors <- NULL
colors <- c("blue","blue","blue")

makeClusterExpansionUpsetPlots <- function(
    seuratObject,
    pairs,
    clusterColumn,
    title = "TCR sharing analysis",
    filename = "upset_plot.png",
    displayCounts = TRUE, # whether or not to display counts above the barplot
    colors = NULL
    ) {
  # library(dplyr)
  # library(tidyr)
  # library(ggplot2)
  # library(ComplexUpset)
  # library(patchwork)
  pairs$barcode <- pairs$libid
  pairs[,c("fullLengthNTa","fullLengthNTb")] <- pairs[,c("CDR3ant","CDR3bnt")]
  seurat_meta <- seuratObject@meta.data
  if (!"barcode" %in% colnames(seurat_meta)) seurat_meta$barcode <- rownames(seurat_meta)
  subpairs <- pairs %>% filter(barcode %in% rownames(seurat_meta))
  subpairs <- subpairs %>%
    mutate(
      fullLengthNTa = ifelse(is.na(fullLengthNTa) | fullLengthNTa == "", "NA", fullLengthNTa),
      fullLengthNTb = ifelse(is.na(fullLengthNTb) | fullLengthNTb == "", "NA", fullLengthNTb),
      pairnt = paste(fullLengthNTa, fullLengthNTb, sep = "_")
    ) %>%
    filter(!grepl("^NA_|_NA$|^NA_NA$", pairnt))

  subpairs <- left_join(subpairs, seurat_meta[, c("barcode", clusterColumn)], by = "barcode")
  colnames(subpairs)[ncol(subpairs)] <- "cluster"
  subpairs <- filter(subpairs, !is.na(cluster))

  expandedPairs <- subpairs %>%
    group_by(pairnt) %>%
    filter(n() > 1) %>%
    ungroup() %>%
    distinct(pairnt, cluster)

  clusters_sorted <- sort(unique(as.character(expandedPairs$cluster)))
  membership_df <- expandedPairs %>%
    mutate(present = TRUE) %>%
    pivot_wider(id_cols = pairnt, names_from = cluster, values_from = present, values_fill = FALSE)
  for (col in setdiff(clusters_sorted, colnames(membership_df))) membership_df[[col]] <- FALSE
  membership_df <- membership_df[, c("pairnt", clusters_sorted)]

  cluster_sets <- setdiff(colnames(membership_df), "pairnt")
  if (is.null(colors)) colors <- scales::hue_pal()(length(cluster_sets))

  upset_plot <- ComplexUpset::upset(
    membership_df,
    intersect = cluster_sets,
    name = "Expanded Clonotypes",
    base_annotations = list(
      "Intersection size" = ComplexUpset::intersection_size(
        counts = displayCounts,
        text = list(size = 3, angle = 0, hjust = 0.5, vjust = 0)
      )
    ),
    stripes = ComplexUpset::upset_stripes(colors = colors),
    set_sizes = ComplexUpset::upset_set_size(
      geom = ggplot2::geom_bar(stat = "count", position = "stack", fill = "grey50"),
      position = "left"
    ),
    sort_sets = FALSE,
    sort_intersections = "descending",
    guides = "over",
    width_ratio = 0.2,
    height_ratio = 0.7
  ) +
    ggtitle(title) +
    labs(caption = paste("Based on", nrow(membership_df), "unique expanded clonotypes")) +
    patchwork::plot_layout() &
    theme(
      plot.title = element_text(hjust = 0.5),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank()
    )

  return(upset_plot)
}

if(FALSE){
  seurat.tmp <- subset(seuratQCMergedCleaned, stimulationFigures == "Microbial")
  seurat.tmp <- subset(seurat.tmp, cellType %in% c("Treg", "Tconv"))
  colors <- c(
    scales::alpha("red", 0.5), scales::alpha("red", 0.5), scales::alpha("red", 0.5),
    scales::alpha("blue", 0.5), scales::alpha("blue", 0.5),
    scales::alpha("red", 0.5), scales::alpha("red", 0.5)
  )
  makeClusterExpansionUpsetPlots(seuratObject = seurat.tmp,
    pairs = cleanTCRpairs.df,
    clusterColumn = "seurat_clusters_DS",
    title = "TCR sharing in RNAseq clusters\nMicrobial",
    colors = colors,
    filename = "microbial_TCR_Pair_Sharing_UpSet_Plot")
  
  makeClusterExpansionUpsetPlots(seuratObject = seurat.tmp,
    pairs = cleanTCRpairs.df,
    clusterColumn = "seurat_clusters_DS",
    title = "TCR sharing in RNAseq clusters\nMicrobial",
    colors = colors,
    displayCounts = FALSE,
    filename = "microbial_TCR_Pair_Sharing_UpSet_Plot_noCounts")
}


colors <- c(
  scales::alpha("blue", 0.5), scales::alpha("blue", 0.5), scales::alpha("blue", 0.5)
)
p <- makeClusterExpansionUpsetPlots(seuratObject = soTregs,
    pairs = pairs[ pairs$libid %in% soTregs$libid,],
    clusterColumn = "seurat_clusters",
    title = "TCR sharing in RNAseq Treg clusters\nIslet",
    colors = colors,
    displayCounts = FALSE,
    filename = "../../data/2025-06-10/TregIsletP390_TCR_Pair_Sharing_UpSet_Plot")
#pdf("../../data/2025-06-10/TregIsletP390_TCR_Pair_Sharing_UpSet_Plot.pdf",width=4.5,height=4.3)  
png("../../data/2025-06-10/TregIsletP390_TCR_Pair_Sharing_UpSet_Plot.png",width=400,height=380)  

print(p)
dev.off()

colors <- c(
  scales::alpha("red", 0.5), scales::alpha("red", 0.5), scales::alpha("red", 0.5),
  scales::alpha("red", 0.5), scales::alpha("red", 0.5)
)
p <- makeClusterExpansionUpsetPlots(seuratObject = soTconvs,
    pairs = pairs[ pairs$libid %in% soTconvs$libid,],
    clusterColumn = "seurat_clusters",
    title = "TCR sharing in RNAseq Tconv clusters\nIslet",
    displayCounts = FALSE,
    colors = colors)
png("../../data/2025-06-10/TconvIsletP390_TCR_Pair_Sharing_UpSet_Plot.png",width=600,height=400)  
#pdf("../../data/2025-06-10/TconvIsletP390_TCR_Pair_Sharing_UpSet_Plot.pdf",width=8,height=6)  

print(p)
dev.off()
```

```{r 01/26/24 Peter and Karen's question about Treg and Tconv sharing amino acid sequences}

# By Nucleotide
tcrs$donorID <- design[ tcrs$libid, "donorID"]
tcrs$donorSort <- paste0( tcrs$donorID, "_", tcrs$sort)
tcrs$donorSortNt <- paste0( tcrs$donorSort, "_", tcrs$full_nt_sequence)
tcrs$DonorNuc

subtcrs <- tcrs[!duplicated(tcrs$donorSortNt),]
tregTconvSharing <- unique( subtcrs$donorJunction[ duplicated(subtcrs$donorJunction)])

# By Amino Acid
tcrs$donorID <- design[ tcrs$libid, "donorID"]
tcrs$donorSort <- paste0( tcrs$donorID, "_", tcrs$sort)
tcrs$donorSortJunction <- paste0( tcrs$donorSort, "_", tcrs$junction)
tcrs$donorJunction <- paste0( tcrs$donorID, "_", tcrs$junction)

subtcrs <- tcrs[!duplicated(tcrs$donorSortJunction),]
tregTconvSharing <- unique( subtcrs$donorJunction[ duplicated(subtcrs$donorJunction)])
print(tregTconvSharing)

```

```{r 2023-12-04 Save counts, metadata, and normalized expression for Kristin Weinstein}

write.table( counts_pc, "../../data/2023-12-04/P390_counts_pc.txt", col.names=NA,sep="\t",quote=FALSE )
write.table( counts_pc_norm, "../../data/2023-12-04/P390_counts_pc_norm.txt", col.names=NA,sep="\t",quote=FALSE )
write.table( design, "../../data/2023-12-04/P390_design.txt", col.names=TRUE,row.names=FALSE, sep="\t", quote=FALSE )

saveRDS( cdsTregs, "../../data/2024-10-24/cdsTregs.RDS")
saveRDS( cdsTconvs, "../../data/2024-10-24/cdsTconvs.RDS")
write.table( counts_pc_norm, "../../data/2024-10-24/P390_counts_pc_norm.txt", col.names=NA,sep="\t",quote=FALSE )
write.table( design, "../../data/2024-10-24/P390_design.txt", col.names=TRUE,row.names=FALSE, sep="\t", quote=FALSE )

```



```{r 11/18/24 cluster plots for Karen and the paper }

cds_coords <- treg_coords
clusterReorder <- c(1,5,4,2,3)
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}
clusterCols <- gg_color_hue(5)
clusterCols <- clusterCols[c(3,5,1,4,2)]
names(clusterCols) <- as.character(1:5)

treg_coords$originalCluster <- factor( clusterReorder[ cds_coords$cluster ])
cds_coords <- treg_coords
ggplot( cds_coords, aes(x=x,y=y,color=originalCluster)) + geom_point() + scale_color_manual( values=clusterCols)

### Genes to plot
gs <- c("FOXP3","IKZF2","IL2RA","IL2RA","LRRC32","CCR7","SELL","CD27","CD69","TNFRSF4","TNFRSF9","CTLA4","ICOS","TIGIT","LAG3","ENTPD1","TGFB1","EBI3","IL10","ENTPD1","TGFB1","CCR6","CXCR3","CXCR5","GATA3","RORC","TBX21")

for( g in gs ){
  ens <- names(ens2hgnc)[ens2hgnc == g]; ens <- ens[!is.na(ens) & grepl("ENS",ens)]
#for( ens in pseudotimeEns ){
#for( ens in tEns ){
#for( ens in topN$Ensemble.ID ){
  #g <- topN$HGNC.symbol[ topN$Ensemble.ID == ens][1]
  g <- ens2hgnc[ens]
  print(g)
  treg_coords$g <- as.numeric( log2(1+counts_pc_norm[ens,treg_coords$libid]) )
  treg_coords <- treg_coords[order(treg_coords$g),]
  p <- ggplot( treg_coords, aes(x=x,y=y,color=g)) + geom_point(size=1) + scale_color_viridis( option="B") + labs(x="UMAP 1",y="UMAP 2",color="log2\nnormalized\nexpression",title=g)
  #png( paste0("../../data/2023-06-05/TregPseudotimeGenes/", g, ".png"),width=450,height=350 )
  pdf( paste0("../../data/2024-11-19/TregClusterMarkers/", g, ".pdf"),width=6.2,height=4.5 )

  print(p)
  dev.off()  
}

### Figure 2
# Check expression of HLA-DR, CD38, IFN gamma, TBET, IL-4, GATA3, IL-17, RORC expression by cluster
counts_pc_norm["HLADR",] <- apply( counts_pc_norm[grepl("HLA-DR",ens2hgnc[rownames(counts_pc_norm)]),],2, function(col) exp(mean(log(col))))

gs <- c("CD38","IFNG","TBX21","IL4","GATA3","IL17A","RORC")
for( g in gs ){
  print(g)
  ens <- names(ens2hgnc)[ens2hgnc == g]; ens <- ens[!is.na(ens) & grepl("ENS",ens)]
  print(ens)
  treg_coords$g <- as.numeric( log2(1+counts_pc_norm[ens,treg_coords$libid]) )
  p <- ggplot( treg_coords, aes(x=originalCluster,y=g,color=originalCluster)) + geom_boxplot(outlier.color=NA) + geom_quasirandom() + labs(x="cluster",y="log2 normalized expression",title=g) + guides(color="none")
  #png( paste0("../../data/2023-06-05/TregPseudotimeGenes/", g, ".png"),width=450,height=350 )
  pdf( paste0("../../data/2024-11-19/TregMarkerClusterBoxplots/", g, ".pdf"),width=6.2,height=4.5 )
  print(p)
  dev.off()  
}

 treg_coords$HLADR <- as.numeric( log(1+counts_pc_norm["HLADR",rownames(treg_coords)]) )
 p <- ggplot( treg_coords, aes(x=originalCluster,y=g,color=originalCluster)) + geom_boxplot(outlier.color=NA) + geom_quasirandom() + labs(x="cluster",y="log2 normalized expression",title="HLA-DR") + guides(color="none")
  #png( paste0("../../data/2023-06-05/TregPseudotimeGenes/", g, ".png"),width=450,height=350 )
  pdf( paste0("../../data/2024-11-19/TregMarkerClusterBoxplots/HLADR.pdf"),width=6.2,height=4.5 )
  print(p)
  dev.off()  

# bubble plots signature genes by cluster
getMeanAndPropByCluster <- function(ens,coords){
  clusters <- unique(coords$cluster); clusters <- clusters[order(clusters)]
  libsByClust <- lapply( clusters, function(clust) rownames(coords)[ coords$cluster == clust]); names(libsByClust) <- clusters
  e <- log2(1+t(counts_pc_norm[ens,]))
  # Expression is z-scored
  e <- scale(e)

  # Expression scaled from min to max
  #e <- e-min(e); e <- e/max(e)
  means <- sapply( libsByClust, function(libs) mean(e[libs,]))
  # Scale the means
  means <- scale(means)
  props <- sapply( libsByClust, function(libs) mean(counts_pc_norm[ens,libs]>0))
  meanAndProps <- data.frame( mean=means,prop=props,cluster=clusters,EnsemblID=ens,HGNC.symbol=ens2hgnc[ens])
}
meanAndProps <- do.call(rbind,lapply(tregUp, function(ens) getMeanAndPropByCluster(ens,treg_coords) ) ) 
meanAndProps$originalCluster <- clusterReorder[ meanAndProps$cluster ]
pdf("../../data/2024-11-19/TregSignatureBubbleByCluster.pdf",height=7,width=5)
png("../../data/2024-11-19/TregSignatureBubbleByCluster.png",height=500,width=450)

ggplot(meanAndProps, aes(y=originalCluster,x=HGNC.symbol,size=prop,fill=mean)) + geom_point(shape=21)+ labs(x="gene",y="cluster",title="Treg Signature Genes",fill="mean\nz-score",size="proportion\nof cells\nexpressed") + scale_fill_viridis() + coord_flip() + scale_fill_gradient2( name = waiver(),high = "red",mid = "white",low = "blue",midpoint = 0.5,space = "Lab",na.value = "grey50",transform = "identity",guide = "colourbar",aesthetics = "fill" ) 
dev.off()

topN <- tregMarkers$topN
topN$originalCluster <- clusterReorder[ as.numeric(gsub("c","",topN$cluster)) ]
topN <- topN[order(topN$originalCluster),]
ens <- topN$Ensemble.ID
meanAndProps <- do.call(rbind,lapply(ens, function(ens) getMeanAndPropByCluster(ens,treg_coords) ) ) 
#pdf("../../data/2024-11-19/TregSignatureBubbleByCluster.pdf",height=7,width=5)
pdf("../../data/2024-11-19/TregClusterMarkerBubble.pdf",height=6,width=18)
png("../../data/2024-11-19/TregClusterMarkerBubble.png",height=450,width=1600)

meanAndProps$g <- factor( meanAndProps$HGNC.symbol, levels= topN$HGNC.symbol)
ggplot(meanAndProps, aes(y=clusterReorder[cluster],x=g,size=prop,fill=mean)) + geom_point(shape=21)+ labs(x="gene",y="cluster",title="Treg Cluster Marker Genes",fill="mean z-score",size="proportion of cells expressed") + scale_fill_gradient2( name = waiver(),high = "red",mid = "grey",low = "blue",midpoint = 0.5,space = "Lab",na.value = "grey50",transform = "identity",guide = "colourbar",aesthetics = "fill" ) + theme(axis.text.x = element_text(angle = 45, vjust =1.05, hjust=1), legend.position = "bottom")
dev.off()

z <- reshape2::dcast(meanAndProps, cluster ~ HGNC.symbol, value.var = "mean")
z <- data.frame( z[,2:ncol(z)] ); rownames(z) <- 1:5
Heatmap(t(z))

```

```{r 12/19/24 TCR sharing}
### TCR Sharing
library(igraph)

donorTable <- data.frame( read_xlsx("../../data/2025-01-10/GenLIMS Samples_P390_demographics.xlsx") )
rownames(donorTable) <- donorTable$Proj.Sub
donorTable$Donor.ID <- gsub("CerosalettiLab144794","CerosalettiLab144744",donorTable$Donor.ID)

design_qc$donorId <- donorTable[ design_qc$project, "Donor.ID"]
designByDonor <- design_qc[!duplicated(design_qc$donorId),]
rownames(designByDonor) <- designByDonor$donorId

# Make TCR Sharing plot

tcrs$donorId <-  donorTable[tcrs$project, "Donor.ID"]
tcrs$donorType <- paste0( tcrs$donorId,"_",tcrs$CD4Type)
tcrs$donorJunctionType <- paste0( tcrs$donorJunction,"_",tcrs$CD4Type)
z <- tcrs[ !duplicated(tcrs$donorJunction),]
sharedJunctions <- unique( z$junction[ duplicated(z$junction)] )
betas <- tcrs[ tcrs$chain == "TRB",]
alphas <- tcrs[ tcrs$chain == "TRA",]
sharedBetas <- tcrs[ tcrs$junction %in% sharedJunctions & tcrs$chain == "TRB",]
sharedAlphas <- tcrs[ tcrs$junction %in% sharedJunctions & tcrs$chain == "TRA",]

donorJunctions <- unique( sharedBetas$donorJunction )
donorJunctionTab <- table(sharedBetas$donorJunction)  
junctions <- sapply(donorJunctions, function(s) strsplit(s,"_")[[1]][2] )
amat <- sapply( junctions, function(j) ifelse( junctions == j,1,0) ); rownames(amat) <- donorJunctions; colnames(amat) <- rownames(amat)

pgraph <- graph_from_adjacency_matrix(
  amat,
  mode = c("max"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NA
)
plot(pgraph,vertex.label="", vertex.size=donorJunctionTab[rownames(amat)]+5)

### Inter-donor and cell type sharing heatmap
tcrs$CD4Type <- design[ tcrs$libid, "CD4Type"]
tcrs$trinity <- paste( tcrs$v_gene, tcrs$junction, tcrs$j_gene, sep="-") # concatenation of v-gene, amino acid CDR3 sequence and j_gene
matchcol <- "trinity"# match the tcrs based on the "trinity" column
tcrs$donorJunctionType <- paste0( tcrs$donorID,"_", tcrs[,matchcol],"_",tcrs$CD4Type)
tcrs$donorJunction <- paste0( tcrs$donorID,"_", tcrs[,matchcol])
tcrs$donorType <- paste0( tcrs$donorID,"_", tcrs$CD4Type)
tcrs <- tcrs[order(tcrs$donorID),]
sharingDfCombined <- c()
for( chain in c("TRB","TRA") ){
  for( cd4type in c( "Tconv","Treg" ) ){
    print(paste(chain,cd4type))
    #print( chain)
    # We call it alphas here, but it could be TRB depending on the value of 'chain'
    #alphas <- tcrs[ tcrs$chain == chain,]
    alphas <- tcrs[ tcrs$chain == chain & grepl(cd4type,tcrs$CD4Type),]
    alphas <- alphas[ alphas$libid %in% soFiltered$libid,]
    
    # Assign an ID to each tcr sequence which is the concatenation of
    # donor, matchcol, and type (Treg or Tconv)
    alphas$donorJunctionType <- paste0( alphas$donorJunction,"_",alphas$CD4Type)
    # To count unique clonotypes, just keep one entry for each unique donorJunctionType
    alphasUnique <- alphas[ !duplicated(alphas$donorJunctionType),]
    # Get rid of iNKTMAIT libs
    alphasUnique <- alphasUnique[ !alphasUnique$libid %in% iNKTMaitLibids,]
    # Count how many shared clonotypes are in common between each donor and sort combination
    donorTypes <- unique(alphas$donorType)
    donorCols <- make_colors( unique(alphasUnique$donorID ) )
    
    # Generate sharing matrix
    if( TRUE ){ # Jaccard Index
      sharingMat <- sapply( donorTypes, function(d1) sapply( donorTypes, function(d2) length(intersect(alphasUnique[alphasUnique$donorType == d1,matchcol], alphasUnique[ alphasUnique$donorType == d2,matchcol]))/length(unique(c(alphasUnique[alphasUnique$donorType == d1,matchcol], alphasUnique[ alphasUnique$donorType == d2,matchcol]) ))  ) )
      countMat <- sapply( donorTypes, function(d1) sapply( donorTypes, function(d2) length(intersect(alphasUnique[alphasUnique$donorType == d1,matchcol], alphasUnique[ alphasUnique$donorType == d2,matchcol]) ) ) )
    } else{ # Just count the shared TCRs
      sharingMat <- countMat
    }
    
    # put into the data frame Dmat data for each row/column of the matrix, which
    # includes the donorID, CD4 Type (sort), and disease group
    dmat <- data.frame( t( sapply( rownames(sharingMat), function(s) strsplit(s,"_")[[1]]) ) ); colnames(dmat) <- c("donorId","sort") 
    dmat$group <- designByDonor[ dmat$donorId,"studyGroup"] # Put whether the donor is T1D or HC in the column 'group'
    dmat$id <- dmat$donorId
    sort <- paste0( dmat$sort," ", dmat$group)
    sharingMat <- sharingMat[ order(sort),order(sort)]
    dmat <- dmat[order(sort),]
    sort <- sort[order(sort)]
  
    # Prepare the matrix for plotting
    tp <- sharingMat
    tp[lower.tri(tp)] <- NA  # Keep only the upper triangular portion
    # Also get rid of the diagonal
    for( i in 1:nrow(tp) ){ tp[i,i] <- NA}
    
    ## Make a dot and boxplot showing sharing between T1D and HC
    t1dRows <- rownames(dmat)[ dmat$group == "Control" ]
    hcRows <- rownames(dmat)[ dmat$group == "T1D"]
    t1dsharing <- tp[t1dRows,t1dRows]; t1dsharing <- t1dsharing[!is.na(t1dsharing)]
    hcsharing <- tp[hcRows,hcRows]; hcsharing <- hcsharing[!is.na(hcsharing)]
    t1dhcsharing <- sharingMat[t1dRows,hcRows]; t1dhcsharing <- t1dhcsharing[!is.na(t1dhcsharing)]
    sharingDf <- data.frame( jaccardIndex = c(t1dsharing,hcsharing,t1dhcsharing), partners = c(rep("T1D\n-T1D",length(t1dsharing)),rep("HC\n-HC",length(hcsharing)),rep("T1D\n-HC",length(t1dhcsharing))), CD4Type=cd4type,chain=chain)
    sharingDfCombined <- rbind(sharingDfCombined,sharingDf)

    # Top and side annotations
    ha <- HeatmapAnnotation(df=dmat[,c("sort","group","id")], col=list(group=t1dcols,sort=c("Tconv"="blue","Tconventional"="blue","Treg"="red"),id=donorCols),show_legend=FALSE)
    ra <- rowAnnotation(df=dmat[,c("sort","group","id")], col=list(group=t1dcols,sort=c("Tconv"="blue","Tconventional"="blue","Treg"="red"), id=donorCols))
    # Heatmap color palette 
    col_fun = colorRamp2(c(0,max(tp,na.rm=TRUE)), c("gray90","red"))
    
    width <- ifelse( cd4type == "Treg",6.5,7)
    # pdf( paste0("../../data/2025-02-10/PaperFigures/",chain,"SharingMatrix_allDonors_",matchcol,"_jaccard_",cd4type,".pdf"),width=width,height=4.75)
    # pdf( paste0("../../data/2025-02-10/PaperFigures/",chain,"SharingMatrix_allDonors_",matchcol,"_jaccard2.pdf"),width=width,height=5.5)
    if(FALSE){
      png( paste0("../../data/2025-02-10/PaperFigures/",chain,"SharingMatrix_allDonors_",matchcol,"_jaccard2.png"),width=width*80,height=5.5*90)
  
      # title <- paste0("Shared ",chain," ",ifelse(matchcol == "trinity","v-gene, CDR3 AA, j-gene",matchcol),"\nBetween Donors, ",cd4type)
      title = paste0("Shared ",chain," ",ifelse(matchcol == "trinity","v-gene, CDR3 AA, j-gene",matchcol),"\nBetween Donors")
      p <- Heatmap(tp, col=col_fun,
              name = "jaccard\nindex",
              na_col = "white",   # Set NA values to be white
              cluster_rows = FALSE, # Disable clustering for rows
              cluster_columns = FALSE, # Disable clustering for columns
              show_heatmap_legend = TRUE, top_annotation=ha,column_split=sort, row_split=sort,show_row_names=FALSE,show_column_names=FALSE,row_title_side="right",column_title=title,row_title_gp=gpar(fontsize=0)) + ra# Display legend
      print(p)
      dev.off()
    }
  }
}

sortCols <- c("Treg"="blue","Tconv"="red","Tconventional"="red")
#pdf("../../data/2025-02-10/PaperFigures/DonorSharingBoxplots.pdf",width=10,height=6)
png("../../data/2025-02-10/PaperFigures/DonorSharingBoxplots.png",width=800,height=500)
ggplot( sharingDfCombined, aes(x=partners,y=jaccardIndex,color=CD4Type)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=1) + scale_color_manual( values=sortCols) + facet_wrap(~CD4Type+chain, nrow=1) + guides(color="none") + labs(x="",y="proportion of shared TCR chains\nby donor pair (Jaccard Index)",title="Proportion of Shared TCR Chains Between Donor Pairs\nBy Chain Type and T1D Status")
dev.off()

pdf("../../data/2025-02-10/PaperFigures/DonorSharingBoxplots.pdf",width=10,height=6)
ggplot( sharingDfCombined, aes(x=partners,y=jaccardIndex,color=CD4Type)) + geom_boxplot(outlier.color=NA) + geom_quasirandom() + scale_color_manual( values=sortCols) + facet_wrap(~CD4Type+chain, nrow=1) + guides(color="none") + labs(x="",y="proportion of shared TCR chains\nby donor pair (Jaccard Index)",title="Proportion of Shared TCR Chains Between Donor Pairs\nBy Chain Type and T1D Status")
dev.off()

### Do it for pairs
pairs$trinityPair <- paste( pairs$trinitya, pairs$trinityb)
pairs$trinityPairDonor <- paste( pairs$trinityPair, pairs$donorID)
pairs$CD4Type <- design[ pairs$sample, "CD4Type"]
pairs$donorId <- pairs$donorID
pairs$libid <- pairs$sample
pairs$donorType <- paste0( pairs$donorId,"_", pairs$CD4Type)
  for( cd4type in c( "Tconv","Treg" ) ){
    print(paste(cd4type))
    # We call it alphas here, but it could be TRB depending on the value of 'chain'
    #alphas <- pairs[ pairs$chain == chain,]
    alphas <- pairs[ pairs$CD4Type == cd4type,]
    alphas$junction <- alphas$trinityPair
    alphas$donorJunction <- paste( alphas$donorID, alphas$junction)
    
    # Assign an ID to each tcr sequence which is the concatenation of
    # donor, matchcol, and type (Treg or Tconv)
    alphas$donorJunctionType <- paste0( alphas$donorJunction,"_",alphas$CD4Type)
    # To count unique clonotypes, just keep one entry for each unique donorJunctionType
    alphasUnique <- alphas[ !duplicated(alphas$donorJunctionType),]
    # Get rid of iNKTMAIT libs
    alphasUnique <- alphasUnique[ !alphasUnique$libid %in% iNKTMaitLibids,]
    # Count how many shared clonotypes are in common between each donor and sort combination
    donorTypes <- unique(alphas$donorType)
    donorCols <- make_colors( unique(alphasUnique$donorID ) )
    
    # Generate sharing matrix
    if( TRUE ){ # Jaccard Index
      sharingMat <- sapply( donorTypes, function(d1) sapply( donorTypes, function(d2) length(intersect(alphasUnique[alphasUnique$donorType == d1,matchcol], alphasUnique[ alphasUnique$donorType == d2,matchcol]))/length(unique(c(alphasUnique[alphasUnique$donorType == d1,matchcol], alphasUnique[ alphasUnique$donorType == d2,matchcol]) ))  ) )
    } else{ # Just count the shared pairs
      sharingMat <- sapply( donorTypes, function(d1) sapply( donorTypes, function(d2) length(intersect(alphasUnique[alphasUnique$donorType == d1,matchcol], alphasUnique[ alphasUnique$donorType == d2,matchcol]) ) ) )
    }
    
    # put into the data frame Dmat data for each row/column of the matrix, which
    # includes the donorID, CD4 Type (sort), and disease group
    dmat <- data.frame( t( sapply( rownames(sharingMat), function(s) strsplit(s,"_")[[1]]) ) ); colnames(dmat) <- c("donorId","sort") 
    dmat$group <- designByDonor[ dmat$donorId,"studyGroup"] # Put whether the donor is T1D or HC in the column 'group'
    dmat$id <- dmat$donorId
    sort <- paste0( dmat$sort," ", dmat$group)
    sharingMat <- sharingMat[ order(sort),order(sort)]
    dmat <- dmat[order(sort),]
    sort <- sort[order(sort)]
    
    
    # Prepare the matrix for plotting
    tp <- sharingMat
    tp[lower.tri(tp)] <- NA  # Keep only the upper triangular portion
    # Also get rid of the diagonal
    for( i in 1:nrow(tp) ){ tp[i,i] <- NA}
    
    # Top and side annotations
    ha <- HeatmapAnnotation(df=dmat[,c("sort","group","id")], col=list(group=t1dcols,sort=c("Tconv"="blue","Treg"="red"),id=donorCols),show_legend=FALSE)
    ra <- rowAnnotation(df=dmat[,c("sort","group","id")], col=list(group=t1dcols,sort=c("Tconv"="blue","Treg"="red"), id=donorCols))
    # Heatmap color palette 
    col_fun = colorRamp2(c(0,max(tp,na.rm=TRUE)), c("gray90","red"))
    
    width <- ifelse( cd4type == "Treg",6.5,7)
    pdf( paste0("../../data/2025-01-10/",chain,"SharingMatrix_allDonors_",matchcol,"_jaccard_",cd4type,".pdf"),width=width,height=4.75)
    p <- Heatmap(tp, col=col_fun,
            name = "jaccard\nindex",
            na_col = "white",   # Set NA values to be white
            cluster_rows = FALSE, # Disable clustering for rows
            cluster_columns = FALSE, # Disable clustering for columns
            show_heatmap_legend = TRUE, top_annotation=ha,column_split=sort, row_split=sort,show_row_names=FALSE,show_column_names=FALSE,row_title_side="right",column_title=paste0("Shared ",chain," ",ifelse(matchcol == "trinity","v-gene, CDR3 AA, j-gene",matchcol),"\nBetween Donors, ",cd4type),row_title_gp=gpar(fontsize=0)) + ra# Display legend
    print(p)
    dev.off()
  }


## Subsample to match Tregs and Tconv to match for the same sharing figure
### Beta Sharing Mat
tcrs$donorJunction <- paste0( tcrs$donorID,"_",tcrs$junction)
tcrs$donorType <- paste0( tcrs$donorID,"_",tcrs$CD4Type)
tcrs$donorJunctionType <- paste0( tcrs$donorJunction,"_",tcrs$CD4Type)
getSubsampledMat <- function(chains, matchcol = "trinity", jaccardIndex=TRUE){
  ### Beta Sharing Mat#
  chains$CD4Type <- design[ chains$libid, "CD4Type"]
  chains$donorJunctionType <- paste0( chains$donorId,"_", chains[,matchcol],"_", chains$CD4Type)
  
  # To count unique clonotypes, just keep one entry for each unique donorJunctionType
  # Just get one row per donor/junction/type to count clonotypes 
  chainsUnique <- chains[ !duplicated(chains$donorJunctionType),]
  # Find the number to downsample to between the Tregs and Tconvs for each donor
  numPerDonor <- apply( table(chainsUnique$donorID, chainsUnique$CD4Type),1,min )
  # Do the downsampling
  donorTypes <- unique(chainsUnique$donorType)
  chainsUniqueByDonorType <- lapply( donorTypes, function(donorType) chainsUnique[ chainsUnique$donorType == donorType,]); names(chainsUniqueByDonorType) <- donorTypes
  chainsUniqueByDonorType <- lapply(chainsUniqueByDonorType, function(l) l[sample(1:nrow(l),numPerDonor[l$donorID[1]]),] )
  
  chainsUnique <- do.call( rbind, chainsUniqueByDonorType)
  # Count how many shared clonotypes are in common between each donor and sort combination
  donorTypes <- unique(chainsUnique$donorType)
  # Generate sharing matrix
  if( jaccardIndex ){ # Jaccard Index
    sharingMat <- sapply( donorTypes, function(d1) sapply( donorTypes, function(d2) length(intersect(chainsUnique[chainsUnique$donorType == d1,matchcol], chainsUnique[ chainsUnique$donorType == d2,matchcol]))/length(unique(c(chainsUnique[chainsUnique$donorType == d1,matchcol], chainsUnique[ chainsUnique$donorType == d2,matchcol]) ))  ) )
  } else{ # Just count the amount shared
    sharingMat <- sapply( donorTypes, function(d1) sapply( donorTypes, function(d2) length(intersect(chainsUnique[chainsUnique$donorType == d1,matchcol], chainsUnique[ chainsUnique$donorType == d2,matchcol]) ) ) )
  }
  
  return(sharingMat)
}

NDownsamples <- 100
matchcol <- "trinity"
for( chainType in c("TRA","TRB")){
  chains <- tcrs[ tcrs$chain == chainType,]
  chains$donorJunctionType <- paste0( chains$donorID,"_", chains[,matchcol],"_", chains$CD4Type)

  # Get the median of N downsamples
  sharingMatDownsampled <- getSubsampledMat(chains)
  n <- nrow(sharingMatDownsampled)
  downsampledSharingMats <- array(0, dim = c(nrow(sharingMatDownsampled), ncol(sharingMatDownsampled), NDownsamples))
  downsampledSharingMats[1:n,1:n,1] <- sharingMatDownsampled
  for( i in 2:NDownsamples){ downsampledSharingMats[1:n,1:n,i] <- getSubsampledMat(chains) }
  medianDownsampledMat <- apply( downsampledSharingMats, c(1,2), median)
  rownames(medianDownsampledMat) <- rownames(sharingMatDownsampled)
  colnames(medianDownsampledMat) <- colnames(sharingMatDownsampled)
  
  # Assign an ID to each tcr sequence which is the concatenation of
  # donor, cdr3 amino acid sequence, and type (Treg or Tconv)
  # To count unique clonotypes, just keep one entry for each unique donorJunctionType
  chainsUnique <- chains[ !duplicated(chains$donorJunctionType),]
  # Count how many shared clonotypes are in common between each donor and sort combination
  donorTypes <- unique(chains$donorType)
  sharingMat <- sapply( donorTypes, function(d1) sapply( donorTypes, function(d2) length(intersect(chainsUnique$junction[chainsUnique$donorType == d1], chainsUnique$junction[ chainsUnique$donorType == d2]) ) ) )
  
  sharingMat <- medianDownsampledMat
  
  # put into the data frame Dmat data for each row/column of the matrix, which
  # includes the donorID, CD4 Type, and disease group
  dmat <- data.frame( t( sapply( rownames(sharingMat), function(s) strsplit(s,"_")[[1]]) ) ); colnames(dmat) <- c("donorId","sort") 
  dmat$group <- designByDonor[ dmat$donorId,"studyGroup"]
  sort <- paste0( dmat$sort," ", dmat$group)
  sharingMat <- sharingMat[ order(sort),order(sort)]
  dmat <- dmat[order(sort),]
  sort <- sort[order(sort)]
  
  # Prepare the matrix for plotting
  tp <- sharingMat
  tp[lower.tri(tp)] <- NA  # Keep only the upper triangular portion
  # Also get rid of the diagonal
  for( i in 1:nrow(tp) ){ tp[i,i] <- NA}
  
  # Top and side annotations
  ha <- HeatmapAnnotation(df=dmat[,c("sort","group")], col=list(group=t1dcols,sort=c("Tconv"="blue","Treg"="red","Tconventional"="blue")),show_legend=FALSE)
  ra <- rowAnnotation(df=dmat[,c("sort","group")], col=list(group=t1dcols,sort=c("Tconv"="blue","Treg"="red","Tconventional"="blue")))
  # Heatmap color palette 
  col_fun = colorRamp2(c(0,max(tp,na.rm=TRUE)), c("gray90","red"))
  pdf(paste0("../../data/2025-01-10/",chainType,"SharingMatrixDownsampledMedian_allDonors.pdf"),width=8,height=8)
  p <- Heatmap(tp, col=col_fun,
          name = "jaccard\nindex",
          na_col = "white",   # Set NA values to be white
          cluster_rows = FALSE, # Disable clustering for rows
          cluster_columns = FALSE, # Disable clustering for columns
          show_heatmap_legend = TRUE, top_annotation=ha,column_split=sort, row_split=sort,show_row_names=FALSE,show_column_names=FALSE,row_title_side="right",column_title=paste0("Jaccard Index of", chainType," v-gene, CDR3 AA, j-gene Between Donors and CD4 Types"),row_title_gp=gpar(fontsize=0)) + ra# Display legend
  print(p)
  dev.off()
}

### Same as above, alpha beta pairs
pairs$donorId <- design[ pairs$sample,"donorId"]
pairs$CD4Type <- design[ pairs$sample, "CD4Type"]
pairs$donorType <- paste0( pairs$sampleRepositoryID,"_",pairs$CD4Type)
pairs$donorPair <- paste0( pairs$sampleRepositoryID,"_",pairs$CDR3pair)
pairs$donorPairType <- paste0( pairs$donorPair,"_",pairs$CD4Type)
matchcol <- "full_nt_sequence"
# Assign an ID to each tcr sequence which is the concatenation of
# donor, cdr3 amino acid sequence, and type (Treg or Tconv)
# To count unique clonotypes, just keep one entry for each unique donorJunctionType
pairsUnique <- pairs[ !duplicated(pairs$donorPairType),]
# Count how many shared clonotypes are in common between each donor and sort combination
donorTypes <- unique(pairs$donorType)
sharingMat <- sapply( donorTypes, function(d1) sapply( donorTypes, function(d2) length(intersect(pairsUnique[pairsUnique$donorType == d1,matchcol], pairsUnique[ pairsUnique$donorType == d2,matchcol]) ) ) )

# put into the data frame Dmat data for each row/column of the matrix, which
# includes the donorID, CD4 Type, and disease group
dmat <- data.frame( t( sapply( rownames(sharingMat), function(s) strsplit(s,"_")[[1]]) ) ); colnames(dmat) <- c("srid","sort") 
dmat$group <- designBySrid[ dmat$srid,"studyGroup"]
sort <- paste0( dmat$sort," ", dmat$group)
sharingMat <- sharingMat[ order(sort),order(sort)]
dmat <- dmat[order(sort),]
sort <- sort[order(sort)]

# Prepare the matrix for plotting
tp <- sharingMat
tp[lower.tri(tp)] <- NA  # Keep only the upper triangular portion
# Also get rid of the diagonal
for( i in 1:nrow(tp) ){ tp[i,i] <- NA}

donorCols["P390-34"] <- "#0072B2"
# Top and side annotations
ha <- HeatmapAnnotation(df=dmat[,c("sort","group","srid")], col=list(group=t1dcols,sort=c("Tconventional"="blue","Treg"="red"),srid=donorCols),show_legend=FALSE)
ra <- rowAnnotation(df=dmat[,c("sort","group","srid")], col=list(group=t1dcols,sort=c("Tconventional"="blue","Treg"="red"), srid=donorCols))
# Heatmap color palette 
col_fun = colorRamp2(c(0,max(tp,na.rm=TRUE)), c("gray90","red"))

pdf( paste0("../../data/2025-01-10/PairSharingMatrix_allDonors_",matchcol,".pdf"),width=8,height=8)
Heatmap(tp, col=col_fun,
        name = "unique\nsequence\ncount",
        na_col = "white",   # Set NA values to be white
        cluster_rows = FALSE, # Disable clustering for rows
        cluster_columns = FALSE, # Disable clustering for columns
        show_heatmap_legend = TRUE, top_annotation=ha,column_split=sort, row_split=sort,show_row_names=FALSE,show_column_names=FALSE,row_title_side="right",column_title=paste0("Counts of Shared A/B Pair Nucleotide Sequences\nBetween Donors and CD4 Types"),row_title_gp=gpar(fontsize=0)) + ra# Display legend
dev.off()

## 2025-02-04 Proportion Expanded Plots
pairs$pair <- pairs$CDR3pair
pairs$donorID <- design[pairs$sample,"donorID"]
pairs$pairDonor <- paste0( pairs$pair,"_",pairs$donorID)
expandedPairDonors <- unique(pairs$pairDonor[duplicated(pairs$pairDonor)])
pairs$expanded <- pairs$pairDonor %in% expandedPairDonors
pairs <- pairs[ order(!pairs$expanded),]
samples <- pairs[ !duplicated(pairs$sample),]
samples$CD4Type <- ifelse( design_qc[ samples$sample,"CD4Type"] == "Treg","Treg","Tconv")
samples$studyGroup <- design_qc[ samples$sample,"studyGroup"]

isExpanded <- function(pairs){
  expandedPairs <- unique( pairs$pairDonor[ duplicated(pairs$pairDonor)] )
  return( pairs$pairDonor %in% expandedPairs )
}

expanded <- samples[samples$expanded,]
propExpanded <- data.frame( table(expanded$donorID,expanded$CD4Type)); colnames(propExpanded) <- c("donorID","CD4Type","count") 
propExpanded$proportion <- propExpanded$count/table( paste(samples$donorID, samples$CD4Type) )[ paste( propExpanded$donorID,propExpanded$CD4Type)]
propExpanded$studyGroup <- designByDonor[ propExpanded$donorID,"studyGroup"]
propExpanded$groupType <- paste0( propExpanded$studyGroup, "\n",ifelse(propExpanded$CD4Type == "Treg","Treg","Tconv") )
ggplot( propExpanded, aes(x=CD4Type,y=proportion, color=CD4Type)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=1) + scale_color_manual( values=sortCols) + guides(color="none") + labs(x="") + facet_wrap(~studyGroup)

## T-tests of treg vs. tconv?
logitTransform <- function(x) {
    if (any(x %in% c(0,1))) {
      epsilon <-
        x %>%
        setdiff(c(0,1)) %>%
        c(., 1-.) %>%
        abs() %>%
        min(na.rm = TRUE) %>%
        magrittr::divide_by(2)
      x[x %in% 0] <- x[x %in% 0] + epsilon
      x[x %in% 1] <- x[x %in% 1] - epsilon
    }
    x <- log(x/(1-x))
}
propExpanded$logit <- logitTransform( propExpanded$proportion)
expandedModel <- lm( logit ~ CD4Type*studyGroup, data=propExpanded)
## t.test
pvals <- sapply( c("Tconv","Treg"), function(celltype) propExpanded %>% filter(CD4Type == celltype) %>% t.test(logit ~ studyGroup, data = .) %>% .$p.value )
propExpanded$anno <- paste0( propExpanded$CD4Type,"\np-value: ",signif(pvals[propExpanded$CD4Type],3))
pdf("../../data/2025-02-10/PaperFigures/T1DvHC_propExpanded_byType.pdf",width=6,height=6)
ggplot( propExpanded, aes(x=studyGroup,y=proportion, color=CD4Type)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=1) + scale_color_manual( values=sortCols) + guides(color="none") + labs(x="",title="Proportion Expanded by Donor\nT1D vs. HC p-values") + facet_wrap(~anno) 
dev.off()

propExpandedFullData <- propExpanded

ggplot( counts[counts$count != 0,], aes(x=studyGroup,y=count)) + geom_boxplot(outlier.color = NA) + geom_quasirandom(size=1,aes(color=CD4Type)) + facet_wrap(~CD4Type) + scale_color_manual( values=sortCols) + guides(color="none") + labs(x="",y="paired cell count")

### Now do the same thing, but for the tconvs, downsample  
downsampleN <- 66
numDownsamples <- 100
getPropsExpanded <- function( downsampleN, CD4Type = "Tconv" ){
  subsamples <- samples[ samples$CD4Type == CD4Type & ! samples$sample %in% seuratMismatchedLibs, ]
  donorIDTab <- table( subsamples$donorID ); donorIDTab <- donorIDTab[ donorIDTab >= downsampleN ]
  downsamples <- do.call(rbind, lapply( names(donorIDTab), function(did) subsamples[ subsamples$donorID == did,][sample(1:donorIDTab[did],downsampleN),]))
  
  subpairs <- pairs[ pairs$sample %in% downsamples$sample, ]
  subpairs$expanded <- isExpanded(subpairs)
  downsamples$expanded <- downsamples$sample %in% subpairs$sample[ subpairs$expanded]
  
  propExpanded <- data.frame( table(as.factor(downsamples$donorID),as.factor(downsamples$CD4Type), downsamples$expanded )); colnames(propExpanded) <- c("donorID","CD4Type","expanded","count") 
  propExpanded$expanded <- propExpanded$expanded == "TRUE"
  propExpanded <- propExpanded[ propExpanded$expanded,]
  propExpanded$proportion <- propExpanded$count/table( paste(samples$donorID, samples$CD4Type) )[ paste( propExpanded$donorID,propExpanded$CD4Type)]
  propExpanded$studyGroup <- designByDonor[ as.character(propExpanded$donorID),"studyGroup"]
  propExpanded$groupType <- paste0( propExpanded$studyGroup, "\n",ifelse(propExpanded$CD4Type == "Treg","Treg","Tconv") )
  propExpanded$logit <- logitTransform( propExpanded$proportion)
  return(propExpanded)
}
propsExpanded <- do.call(rbind,lapply(1:numDownsamples, function(i) getPropsExpanded(downsampleN,"Tconv") ))

medianPropsExpanded <- aggregate(proportion ~ donorID + studyGroup + groupType + CD4Type, data = propsExpanded, FUN = median)
medianPropsExpanded$logit <- logitTransform(medianPropsExpanded$proportion)

pval <- t.test( medianPropsExpanded$logit[ medianPropsExpanded$studyGroup == "Control"], medianPropsExpanded$logit[ medianPropsExpanded$studyGroup != "Control"] )$p.value
medianPropsExpanded$anno <- paste0(medianPropsExpanded$CD4Type, "\np-value: ", signif(pval,3),"\n(downsampled)")
ggplot( medianPropsExpanded, aes(x=studyGroup,y=proportion, color=CD4Type)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=1) + scale_color_manual( values=sortCols) + guides(color="none") + labs(x="",title="Proportion Expanded by Donor\nMedian of 100 Downsamples\nto 66 Cells Per Donor (Tconv)") 

cols <- c("studyGroup","proportion","anno","CD4Type")
comboExpanded <- rbind( propExpandedFullData[,cols], medianPropsExpanded[,cols])
comboExpanded$anno <- relevel( as.factor(comboExpanded$anno), ref="Treg\np-value: 0.247")
#pdf("../../data/2025-04-10/PropExpandedCombined.pdf",width=7,height=7)
png("../../data/2025-04-10/PropExpandedCombined.png",width=600,height=600)
ggplot( comboExpanded, aes(x=studyGroup,y=proportion, color=CD4Type)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=1) + scale_color_manual( values=sortCols) + guides(color="none") + labs(x="",title="Proportion Expanded by Donor\nMedian of 100 Downsamples\nto 66 Cells Per Donor (Tconv)") + facet_wrap(~anno)
dev.off()
### Numbers of islet Treg and Tconv cells passing QC by donor and cluster
design_qc$cluster <- "other"
design_qc[ combinedDf$libid,"cluster"] <- combinedDf$cluster
countDf <- data.frame( table( design_qc$donorId, design_qc$cluster)); colnames(countDf) <- c("donorId","cluster","count")
countDf <- countDf[order(countDf$cluster == "other"),]
write.table(countDf,"../../data/2025-04-10/CellCountByDonorClusterQC.csv",quote=FALSE,sep=",",col.names=TRUE,row.names=FALSE)

# All TCR sequences for Treg and Tconv in T1D and HC (cell type and donor type should be noted)
subTcrs <- tcrs[ tcrs$libid %in% design_qc$libid, ]
subTcrs$donorID
write.table(subTcrs[,c("junction","full_nt_sequence","v_gene","j_gene","chain","donorID","studyGroup","CD4Type")],"../../data/2025-04-10/TCRsForPaper.csv",quote=FALSE,sep=",",col.names=TRUE,row.names=FALSE)


```

```{r `12/10/24 Read in Karen's markers}

library(readxl)

read_excel_allsheets <- function(filename, tibble = FALSE) {
  # I prefer straight data.frames
  # but if you like tidyverse tibbles (the default with read_excel)
  # then just pass tibble = TRUE
  sheets <- readxl::excel_sheets(filename)
  x <- lapply(sheets, function(X) readxl::read_excel(filename, sheet = X))
  if(!tibble) x <- lapply(x, as.data.frame)
  names(x) <- sheets
  x
}


```

```{r 12/10/24 Clustering Optimization in Seurat}


### Here are parameters that Thomas used
seuratObjects <- lapply(gexObjects,
  function(x) CreateSeuratObject(counts = x,
    min.features = 100,
    min.cells = 3))

# Re-run normalization, clustering, UMAP, etc on this subset
seuratQCMergedCleaned <- JoinLayers(seuratQCMergedCleaned, assay = "RNA")

DefaultAssay(seuratQCMergedCleaned) <- "RNA"
seuratQCMergedCleaned <- NormalizeData(object = seuratQCMergedCleaned, verbose = FALSE, assay = "RNA")

seuratQCMergedCleaned <- NormalizeData(object = seuratQCMergedCleaned,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "FB")

seuratQCMergedCleaned <- NormalizeData(object = seuratQCMergedCleaned,
  verbose = FALSE,
  normalization.method = "LogNormalize",
  margin = 2,
  assay = "HT")

seuratQCMergedCleaned <- FindVariableFeatures(object = seuratQCMergedCleaned,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)

seuratQCMergedCleaned <- ScaleData(object = seuratQCMergedCleaned, verbose = FALSE)
seuratQCMergedCleaned <- RunPCA(object = seuratQCMergedCleaned, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(seuratQCMergedCleaned)

pdf(file.path(plotDir,
  paste0(filenameSuffix, "_elbowPlotUMAP.pdf")),
height = 5,
width = 6)

print(elbowPlot.tmp)

dev.off()
rm_tmp(ask = FALSE)
###

libs <- design_qc$libid
# so is a seurat object
counts <- counts_pc[rownames(counts_pc),libs]
rownames(counts) <- ens2hgnc[ rownames(counts)]
colnames(counts) <- design_qc[libs,"libid"]

countsForCellTypist <- counts_pc_filtered
rownames(countsForCellTypist) <- ens2hgnc[ rownames(countsForCellTypist)]
write.table(as.matrix(countsForCellTypist), 
             '../../data/2024-12-10/P390_filtered_countsfile.csv', 
             sep = ',', row.names = T, col.names = T, quote = F)

countsForCellTypist <- counts_pc_norm
countsForCellTypist<- countsForCellTypist[rev(order(rowSums(countsForCellTypist))),]
countsForCellTypist <-  log1p(countsForCellTypist[!duplicated(ens2hgnc[ rownames(countsForCellTypist)]),])
rownames(countsForCellTypist) <- ens2hgnc[ rownames(countsForCellTypist)]
write.table(as.matrix(countsForCellTypist), 
             '../../data/2024-12-10/P390_filtered_countsNormalizedLog1pfile.csv', 
             sep = ',', row.names = T, col.names = T, quote = F)


so <- CreateSeuratObject(counts = counts, min.features = 100, min.cells = 3)
# Cells are already filtered out based on qc metrics
md <- design_qc
rownames(md) <- md$libid
so <- AddMetaData(object = so, metadata = md[colnames(so),])
so[["RNA"]] <- split(so[["RNA"]], f = so$donorID)
so[["percent.mt"]] <- PercentageFeatureSet(so, features = rownames(counts_pc)[ grepl("^MT-",rownames(counts_pc))])
so[["mismatched"]] <- ifelse( so$libid %in% mismatchedlibs, "OldMismatched","OldConsistent")

so <- NormalizeData(object = so, verbose = FALSE, assay = "RNA")

so <- FindVariableFeatures(object = so,
  selection.method = "vst", nfeatures = 2000, verbose = FALSE)
so <- ScaleData(object = so, verbose = FALSE)
so<- RunPCA(object = so, npcs = 30, verbose = FALSE)

# Elbow plot
elbowPlot.tmp <- ElbowPlot(so)
plotdir <- "../../data/2024-12-10/"
pdf(file.path(plotdir,"P390_elbowPlotUMAP.pdf"),
height = 5,
width = 6)
print(elbowPlot.tmp)

dev.off()

so <- FindNeighbors(so, reduction = "pca", dims = 1:30)
so <- RunUMAP(so, dims = 1:10, verbose = FALSE)
so <- FindClusters(so, resolution = 0.5)
# saveRDS(so,"../../data/2024-12-10/P390TregTconvSeuratObject.RDS")

DimPlot(so,
  label = TRUE,
  repel = TRUE,
  group.by = "seurat_clusters")

DimPlot(so,
  label = TRUE,
  repel = TRUE,
  group.by = "mismatched")

DimPlot(so,
  label = TRUE,
  repel = TRUE,
  group.by = "mismatched", split.by="CD4Type") + labs(title="Seurat UMAP and Clustering\nMismatches determined by previous Monocle3 analysis")

tregClusters <- c(0,5)
otherClusters <- c(7)
tconvClusters <- c(1,2,3,4,6)

so@meta.data$CD4TypeFactor <- factor( gsub("Tconventional","Tconv",so@meta.data$CD4Type) )
ggplot(so@meta.data, aes(x=CD4TypeFactor, fill=CD4TypeFactor)) + geom_histogram(stat="count") + facet_wrap(~seurat_clusters, scales="free_y",nrow=2) + labs(x="CD4 Type") + guides(fill="none")

# Define mismatched cells
so@meta.data$mismatched <- ifelse( so@meta.data$seurat_clusters %in% otherClusters, "mismatched","consistent") 
so@meta.data$mismatched[ so@meta.data$CD4Type == "Tconventional" & so@meta.data$seurat_clusters %in% tregClusters ] <- "mismatched"
so@meta.data$mismatched[ so@meta.data$CD4Type == "Treg" & so@meta.data$seurat_clusters %in% tconvClusters ] <- "mismatched"
so@meta.data$mismatched[ so$libid %in% iNKTMaitLibids ] <- paste0( so@meta.data$mismatched[ so$libid %in% iNKTMaitLibids ], ", iNKT/MAIT")
## Also note the doublets
so@meta.data$mismatched[ so$libid %in% betaDoublets ] <- paste0( so@meta.data$mismatched[ so$libid %in% betaDoublets ], ", betaDoublet")

soFiltered <- subset(x = so, subset =  mismatched == "consistent")
soTregs <- subset( x=soFiltered, subset = CD4Type=="Treg")
soTconvs <- subset( x=soFiltered, subset = CD4Type=="Tconventional")

# initialize the inputs for the optimization function
hyperParamGridPCA.df <- expand.grid(
  findNeighborsDim = c(5, 7, 11, 15, 19), # these values were chosen after examining the elbow plot.
  findClustersRes = c(0.01, 0.025, 0.05, 0.75, 0.1, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.8, 1, 1.3, 1.5, 2, 2.5) # these values were chosen somewhat arbitrarily
)
min.dist.vector <- seq(0.02,0.1,0.02)
n_neighbors.vector <- seq(5,65,10)
maxNClusters = 10
minNClusters = 1

library(plyr)
library(doParallel)
library(foreach)
library(clusterSim)
library(Seurat)
library(scDEED)

print( table(soTconvs$mismatched))
optimizeRNAseqClustering <- function(seuratObject, hyperParamGridPCA.df, min.dist.vector, n_neighbors.vector, maxNClusters = 10, minNClusters = 1) {
  # ------------------------------------------------INPUTS------------------------------------------------
  # seuratObject is... a seurat object
  # hyperParamGridPCA.df is an expanded grid for a full grid search for PCA clustering. type: dataframe
  # min.dist.vector is a vector of min.dist values to pass to UMAP (via scDEED())
  # n_neighbors.vector is a vector of n_neighbors values to pass to UMAP (via scDEED())
  # maxNClusters is the maximum number of clusters to be considered (will evaluate 2 through maxNClusters)
  #-------------------------------------------------------------------------------------------------------

  #----------------------------------------------OUTPUTS--------------------------------------------------
  # result contains $hyperParamGridOptClusterAndUMAP.df and $hyperParamGridClusterOnly.df   
  #   Extract like:
  #     hyperParamGridOptClusterAndUMAP.df <- result$hyperParamGridOptClusterAndUMAP.df (smaller output with opt PCA clustering and UMAP embedding params)
  #     hyperParamGridClusterOnly.df <- result$hyperParamGridClusterOnly.df (larger output with full PCA clustering gridsearch and results)
  #--------------------------------------------------------------------------------------------------------


  # STEP 1: grid search over FindNeighbors() and FindClusters() hyperparameters to find
  # the best combinations for each nClusters obtained
  
  # detect nuymber of cores, leave one available for the machine to do other things
  nCores <- parallel::detectCores() - 1
  
  # create the cluster for parallel computation
  myCluster <- parallel::makeCluster(
    nCores,
    type = "FORK"
  )
  
  # register it to be used by %dopar%
  doParallel::registerDoParallel(cl = myCluster)
  
  # Hyperparameter grid search
  clusteringMetrics <- foreach(
    findNeighborsDim = hyperParamGridPCA.df$findNeighborsDim,
    findClustersRes = hyperParamGridPCA.df$findClustersRes,
    .combine = "cbind"
  ) %dopar% {
    # do the UMAP clustering on the Seurat object
    set.seed(6022)
    seuratObject <- FindNeighbors(seuratObject, dims = 1:findNeighborsDim, verbose = FALSE)
    seuratObject <- FindClusters(seuratObject, resolution = findClustersRes, verbose = FALSE)
    
    # extract the cluster information
    metaData.df <- seuratObject@meta.data
    
    # Extract PCA embeddings
    pcaEmbeddings <- seuratObject@reductions$pca@cell.embeddings
    
    clusterMat <- pcaEmbeddings
    clusterVect <- as.numeric(metaData.df$seurat_clusters)
    nClusters <- dim(table(metaData.df$seurat_clusters))
    
    # calculate clustering metrics
    daviesBouldinIdx <- index.DB(clusterMat, clusterVect)
    calinskiHarabasz <- index.G1(clusterMat, clusterVect)
    silScore <- silhouette(clusterVect, dist(clusterMat))
    if (anyNA(silScore)) { # this is gross and clumsy, but hey, we'll fix it later
      medianSilScore <- NaN
    } else {
      silScoreSummary <- summary(silScore)
      medianSilScore <- silScoreSummary$si.summary["Median"]
    }
    
    clusteringMetrics <- c("nClusters" = nClusters,
                           "DBIndex" = daviesBouldinIdx$DB,
                           "CHMetric" = calinskiHarabasz,
                           "medianSilScore" = medianSilScore)
    return(clusteringMetrics)
  }
  
  # transpose the result
  clusteringMetrics <- t(clusteringMetrics)
  
  # adding the prediction error column
  hyperParamGridPCA.df$DBIndex <- clusteringMetrics[, "DBIndex"]
  hyperParamGridPCA.df$CHMetric <- clusteringMetrics[, "CHMetric"]
  hyperParamGridPCA.df$medianSilScore <- clusteringMetrics[, "medianSilScore"]
  hyperParamGridPCA.df$nClusters <- clusteringMetrics[, "nClusters"]
  
  # stop cluster after we're done
  parallel::stopCluster(cl = myCluster)
  
  # scale the clustering metrics to fall between 0 and 1
  hyperParamGridPCA.df$DBIndex <- (hyperParamGridPCA.df$DBIndex - min(hyperParamGridPCA.df$DBIndex, na.rm = TRUE)) /
    (max(hyperParamGridPCA.df$DBIndex, na.rm = TRUE) - min(hyperParamGridPCA.df$DBIndex, na.rm = TRUE))
  
  hyperParamGridPCA.df$CHMetric <- (hyperParamGridPCA.df$CHMetric - min(hyperParamGridPCA.df$CHMetric, na.rm = TRUE)) /
    (max(hyperParamGridPCA.df$CHMetric, na.rm = TRUE) - min(hyperParamGridPCA.df$CHMetric, na.rm = TRUE))
  
  hyperParamGridPCA.df$medianSilScore <- (hyperParamGridPCA.df$medianSilScore - min(hyperParamGridPCA.df$medianSilScore, na.rm = TRUE)) /
    (max(hyperParamGridPCA.df$medianSilScore, na.rm = TRUE) - min(hyperParamGridPCA.df$medianSilScore, na.rm = TRUE))
  
  # make an inverse DB score so that it is more easily compared to the other two metrics
  # (small DB is best, but large CH and silscore are best)
  hyperParamGridPCA.df$DBIndexInverse <- 1 - hyperParamGridPCA.df$DBIndex
  
  # create hyperParamGridPCA.df$meanEvalMetric, as the mean of $DBIndex, $CHMetric, $medianSilScore
  hyperParamGridPCA.df$meanEvalMetric <- rowMeans(hyperParamGridPCA.df[, c("DBIndexInverse", "CHMetric", "medianSilScore")], na.rm = TRUE)
  
  # sort and export (optional) the hyperparamgrid
  hyperParamGridPCA.df <- hyperParamGridPCA.df %>%
    arrange(nClusters, desc(meanEvalMetric))
  
  # TODO: wrap this in an if statement to print out a file if the user requests it with a true/false function parameter
  # write.xlsx(hyperParamGridPCA.df, file = file.path(dataOutputDir, "20242017_RNA_clustering_hyperParamGrid.xlsx"))
  
  # create a subset of hyperParamGridPCA.df with the best option for each nClusters
  hyperParamGridOptSubset.df <- hyperParamGridPCA.df %>%
    group_by(nClusters) %>%
    filter(meanEvalMetric == max(meanEvalMetric)) %>%
    ungroup()

  # Pre-allocate min.dist and n_neighbors columns with NA values
  hyperParamGridOptSubset.df$min.dist <- NA
  hyperParamGridOptSubset.df$n_neighbors <- NA
  
  # STEP 2: use scDEED to optimize the UMAP hyperparameters
  # ---------------------------start of scDEED UMAP opt---------------------------------------
  # if nrow(hyperParamGridOptSubset.df) is smaller than maxNClusters, then set maxNClusters to nrow(hyperParamGridOptSubset.df)
  if (nrow(hyperParamGridOptSubset.df) < maxNClusters) {
    maxNClusters <- nrow(hyperParamGridOptSubset.df)
  }

  # Loop over the rows of hyperParamGridOptSubset.df, finding the best UMAP embedding for each nClusters
  for (i in minNClusters:maxNClusters) {
    # Extract necessary values from hyperParamGridOptSubset.df
    nClusters <- hyperParamGridOptSubset.df$nClusters[i]
    numPCs <- hyperParamGridOptSubset.df$findNeighborsDim[i]
    findClustersRes <- hyperParamGridOptSubset.df$findClustersRes[i]
    
    set.seed(6022)
    seuratObject <- FindNeighbors(seuratObject, dims = 1:numPCs)
    seuratObject <- FindClusters(seuratObject, resolution = findClustersRes)
    
    scDEEDResult <- scDEED(seuratObject, # input Seurat object (must have UMAP or t-SNE already run)
                           K = numPCs, # number of PCs
                           reduction.method = "umap", # 'umap' or 'tsne'
                           min.dist =  min.dist.vector, # scDEED default is 0.1 & 0.4; Seurat default is 0.3
                           n_neighbors = n_neighbors.vector, #scDEED defaults are c(5, 20, 30, 40, 50). Seurat default is 30.
                           similarity_percent = 0.5, # scDEECD default
                           dubious_cutoff = 0.05, # scDEED default
                           trustworthy_cutoff = 0.95) # scDEED default
    
    # add $number_trustworthy_cells and $number_intermediate_cells to scDEEDResult
    scDEEDResult$full_results$number_trustworthy_cells <- str_count(scDEEDResult$full_results$trustworthy_cells, ",") + 1
    scDEEDResult$full_results$number_intermediate_cells <- str_count(scDEEDResult$full_results$intermediate_cells, ",") + 1
    
    # utile scDEED output
    optIdx <- which(scDEEDResult$num_dubious$number_dubious_cells == min(scDEEDResult$num_dubious$number_dubious_cells)) # find the result with the fewest 'dubiously' embedded cells
    # min.distOpt <- scDEEDResult$num_dubious$min.dist[optIdx]
    # n_neighborsOpt <- scDEEDResult$num_dubious$n_neighbors[optIdx]
    
    # just output the optimal hyperparams into hyperParamGridOptSubset.df
    hyperParamGridOptSubset.df$min.dist[i] <- scDEEDResult$num_dubious$min.dist[optIdx]
    hyperParamGridOptSubset.df$n_neighbors[i] <- scDEEDResult$num_dubious$n_neighbors[optIdx]
  }

  # Reorder columns to place min.dist and n_neighbors after findClustersRes
  hyperParamGridOptSubset.df <- hyperParamGridOptSubset.df %>%
    dplyr::select(findNeighborsDim, findClustersRes, min.dist, n_neighbors, everything())
  
  # Return the hyperparam dataframes
  return(list(hyperParamGridOptClusterAndUMAP.df = hyperParamGridOptSubset.df, hyperParamGridClusterOnly.df = hyperParamGridPCA.df))
}

tconvClusterUMAPOptimalResults <- optimizeRNAseqClustering (soTconvs, hyperParamGridPCA.df, min.dist.vector, n_neighbors.vector, maxNClusters = 10, minNClusters = 1)

print( table(soTconvs$mismatched) )


tregClusterUMAPOptimalResults <- optimizeRNAseqClustering (soTregs, hyperParamGridPCA.df, min.dist.vector, n_neighbors.vector, maxNClusters = 10, minNClusters = 1)
#tregClusterUMAPOptimalResults <- readRDS("tregClusterUMAPOptimalResults.RDS")


#saveRDS( tconvClusterUMAPOptimalResults,"tconvClusterUMAPOptimalResults.RDS")
#tconvClusterUMAPOptimalResults <- readRDS("tconvClusterUMAPOptimalResults.RDS")

# TconvMarkers
tconvMarkers <-  unique( c("CCR7", "CD27", "SELL", "TCF7","LEF1", "ID2", "FAS",
           "CD40LG", "CD69", "CD44", "TNFRSF4", "TNFRSF9", "CD38", "HLA-DRB1",
           "CXCR3", "CCR4", "CCR6", "PTGDR2", "CXCR5",
           "IL2", "IFNG", "TNF", "CSF2", "IL17RA", "IL10",
           "PDCD1", "ICOS", "TIGIT",
           "LEF1", "TCF7", "ID2", "ID3", "TBX21", "GATA3", "RORC", "BCL6", 
           "FOXP3", "BHLHE40", "TOX","HLA-DRB5","HLA-DRA") )
table(tconvMarkers %in% rownames( soFiltered[["RNA"]] ))
absentTconvMarkers <- tconvMarkers[!tconvMarkers %in% rownames( soFiltered[["RNA"]] )]
print(absentTconvMarkers)
tconvMarkers2 <- c("CCR7","CD27","SELL","TCF7","LEF1","ID2","TBX21","GATA3","RORC","BCL6","BHLHE40","IL2","IFNG","IL4","IL17A","IL21","TNF","CSF2","CXCR4","CXCR3","CCR4","CCR6","CXCR5","CD40LG","CD69","CD44","TNFRSF9","PDCD1","TIGIT","LAG3")


tregMarkers <- unique( c("CCR7", "CD27", "SELL", "PECAM1", "FAS", "FOXP3", "IKZF2", "IL2RA", "IL7R", "LRRC32", "NRP1", "IRF4", "PRDM1", "RHBDD2", "BCL3", "ID3", "LBH", "TOB2", "IKZF1", "IKZF4", "SATB1", "BACH2", "BATF", "ZFP36L2", "RORC", "RUNX1", "CBFB", "BCL11B", "ETS1", "CD38", "ICOS", "ITGA4", "BSG", "KLRB1", "CD28", "SOCS1","SOCS2", "CD274", "TNFSF10", "CD69", "CD44", "TNFRSF9", "CD40LG", "CXCR3", "CCR4", "CCR6", "CXCR4", "CXCR5", "CCR9", "CCR7", "ITGB1", "ITGA4", "ITGA6", "ITGB7", "SELPLG", "IL2", "IL10", "TGFB1", "IL12A","EBI3", "IFNG", "TNF", "CSF2", "CTLA4", "HAVCR2", "ICOS", "TIGIT", "LAG3", "ENTPD1", "NT5E", "GZMB", "TNFRSF18", "MKI67", "TNFRSF4", "PDCD1", "LGALS9","HLA-DRB5","HLA-DRA","HLA-DRB1") )
tregMarkers[ !tregMarkers %in% gene_key$HGNC.symbol[ gene_key$Ensembl.Gene.ID %in% rownames(counts_pc)]]
absentTregMarkers <- tregMarkers[ !tregMarkers %in% rownames( soTregs[["RNA"]])]
tregMarkers2 <- c("CCR7","CD27","SELL","FOXP3","IKZF2","IL2RA","LRRC32","IRF4","BATF","CTLA4","ENTPD1","TIGIT","ICOS","TGFB1","LAG3","PDCD1","GZMB","CD69","CD44","TNFRSF9","HLA-DRB5","HLA-DRA","HLA-DRB1","CD38","ITGA4","CXCR3","CCR4","CCR6","CXCR4")
# Show plots and clusters for Tconv
tconvClusterOpts <- tconvClusterUMAPOptimalResults$hyperParamGridOptClusterAndUMAP.df
tconvClusterOpts <- tconvClusterOpts[ tconvClusterOpts$nClusters > 1,]
nclusters <- unique(tconvClusterOpts$nClusters)
tconvClusterOpts <- tconvClusterOpts[rev(order(tconvClusterOpts$meanEvalMetric)),]
tconvOpts <- do.call( rbind, lapply(nclusters, function(nclust) tconvClusterOpts[ tconvClusterOpts$nClusters == nclust,][1,] ))
plotDir <- "../../data/2025-01-10/SeuratClusterPlots/"
png(paste0(plotDir,"/TconvClusterNumEvalMetrics.png"),width=500,height=500)
ggplot(tconvOpts, aes(x=nClusters,y=meanEvalMetric)) + geom_point() + labs(title="Tconv Cluster Number Evaluation")
dev.off()
nclusts <- unique(tconvOpts$nClusters)
nclusts <- nclusts[nclusts %in% 2:6]
for( nclust in nclusts ){
  print(nclust)
  tconvBestParams <- tconvOpts[ tconvOpts$nClusters == nclust,]
  soTconvs <- FindNeighbors(soTconvs, reduction = "pca", dims = 1:tconvBestParams$findNeighborsDim[1])
  soTconvs <- FindClusters(soTconvs, resolution = tconvBestParams[1,"findClustersRes"], verbose = FALSE)
  soTconvs <- RunUMAP(soTconvs, dims = 1:tconvBestParams$findNeighborsDim[1], verbose = FALSE)
  soTconvs <- JoinLayers(soTconvs, assay = "RNA")
  
  if(TRUE){ # TCR Expansion plots
    # Make Upset Plot
    makeClusterExpansionUpsetPlots( soTconvs, title=paste0("Tconvs ", nclust, ", Expanded Clones By Cluster"),filename=paste0(plotDir,"Tconvs",nclust,"_clusterSharing_upset.png"))
    
    clusterSharingPlot <- makeClusterExpansionPlots( soTconvs)
    png( paste0(plotDir,"Tconvs",nclust,"_clusterSharing_UMAP.png"),width=400,height=400 )
    print(clusterSharingPlot)
    dev.off()
  
    nclust <- 5
    airlinePlot <- getAirlinePlot(soTconvs, alphaBetaPairsOnly=TRUE) + labs(title= paste0("Tconv ", nclust, " clusters") )
    #png( paste0(plotDir,"Tconvs",nclust,"_airline_UMAP.png"),width=600,height=500 )
    pdf( paste0(plotDir,"Tconvs",nclust,"_airline_UMAP.pdf"),width=7.6,height=6 )

    print(airlinePlot)
    dev.off()
  }

  if(TRUE){
    
    clustsMarkersTconvsPos <- FindAllMarkers(soTconvs)
  
  write.table(  clustsMarkersTconvsPos
,paste0(plotDir,"Tconvs",nclust,"_markerGenes.txt"),quote=FALSE,sep="\t",col.names=NA)
    
    # Get top markers per cluster
    clustsMarkersTconvsPos <- clustsMarkersTconvsPos[clustsMarkersTconvsPos$avg_log2FC > 0,]
    ngenes <- 10
    clustsMarkersTconvsPos <- unique( do.call( c, lapply( unique(clustsMarkersTconvsPos$cluster ), function( clust ) clustsMarkersTconvsPos$gene[ clustsMarkersTconvsPos$cluster == clust][1:ngenes] ) ) )
    
    # Create a DotPlot of the expression of these genes in seuratQCMergedCleanedDS
    fontSize=10
    dotPlot.tmp <- DotPlot(soTconvs, features = clustsMarkersTconvsPos) +
      theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
        text = element_text(size = fontSize),
        axis.text.y = element_text(size = fontSize),
        axis.title.y = element_text(size = fontSize),
        legend.text = element_text(size = fontSize),
        legend.title = element_text(size = fontSize),
        strip.text = element_text(size = fontSize),
        plot.title = element_text(size = fontSize)) + labs(title=paste0(nclust," Tconv Clusters Top Markers"))
    
    # Print the DotPlot
    plotDir <- "../../data/2025-01-10/SeuratClusterPlots/"
    # pdf(file.path(plotDir, paste0("Tconvs",nclust, "_clusterDefiningGenesDotPlot_top10genes.pdf")), height = 4, width = 12)
    png(file.path(plotDir, paste0("Tconvs",nclust, "_clusterDefiningGenesDotPlot_top10genes.png")), height = 220, width = 900)

    print(dotPlot.tmp + scale_color_gradient2(low = "blue", mid = "white", high = "red"))
    dev.off()
  }
  
  # Create a DotPlot of the expression of these genes in seuratQCMergedCleanedDS
  if(TRUE){
    # Order the features so they're cluster
    ens  <- names(ens2hgnc)[ens2hgnc %in% tconvMarkers2 & names(ens2hgnc) %in% rownames(counts_pc_norm)]
    ## Cluster genes
    tp <- t(scale(t(log2(1+counts_pc_norm[ens, soTconvs$libid]))))
    dist_matrix <- dist(tp)
    # Perform hierarchical clustering
    hc <- hclust(dist_matrix)
    # Get the order of columns based on hierarchical clustering
    column_order <- hc$order
    geneNames <- as.character( ens2hgnc[ ens[column_order]] )
    soTconvs$Sort <- ifelse( soTconvs$libid %in% naivelibs,"Naive","Memory") 
    
    dotPlot.tmp <- DotPlot(soTconvs, features = geneNames) +
        theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
          text = element_text(size = fontSize),
          axis.text.y = element_text(size = fontSize),
          axis.title.y = element_text(size = fontSize),
          legend.text = element_text(size = fontSize),
          legend.title = element_text(size = fontSize),
          strip.text = element_text(size = fontSize),
          plot.title = element_text(size = fontSize)) + labs(title=paste0(nclust," Tconv Clusters, Curated Markers"))
    

    
    # Print the DotPlot
    # pdf(file.path(plotDir, paste0("Tconvs",nclust, "_TconvMarkersDotPlot_2.pdf")), height = 3.5, width = 6)
    png(file.path(plotDir, paste0("Tconvs",nclust, "_TconvMarkersDotPlot_2.png")), height = 250, width = 450)

    print(dotPlot.tmp + scale_color_gradient2(low = "blue", mid = "white", high = "red"))
    dev.off()
    
    pdf(file.path(plotDir, paste0("Tconvs",nclust, "_UMAP.pdf")), height = 5, width = 5.3)
    dimPlot.tmp <- DimPlot(soTconvs,
    label = FALSE,
    repel = TRUE,
    group.by = "seurat_clusters")
    print(dimPlot.tmp)
    dev.off()
    
    #pdf(file.path(plotDir, paste0("Tconvs",nclust, "_UMAP_donorID.pdf")), height = 5, width = 7)
    png(file.path(plotDir, paste0("Tconvs",nclust, "_UMAP_donorID.png")), height = 400, width = 560)

    dimPlot.tmp <- DimPlot(soTconvs,
    label = FALSE,
    repel = TRUE,
    group.by = "donorID")
    print(dimPlot.tmp)
    dev.off()
    
        
    pdf(file.path(plotDir, paste0("Tconvs",nclust, "_UMAP_MemNaive.pdf")), height = 5, width = 5.3)
    dimPlot.tmp <- DimPlot(soTconvs,
    label = FALSE,
    repel = TRUE,
    group.by = "Sort") + scale_color_manual( values=c("Memory"="#b65a49","Naive"="#387390"))
    print(dimPlot.tmp)
    dev.off()
    

  }
  
    ### Plot flow markers
  if(TRUE){
    subanno[,markerCols] <- apply(subanno[,markerCols],2, function(r) as.numeric(r)) 
    subanno <- subanno[ subanno$libid %in% soTconvs$libid,]
    subanno$cluster <- soTconvs@meta.data[subanno$libid,"seurat_clusters"]
    clusterMfiMeans <- aggregate( scale(subanno[,markerCols]), by=list(subanno$cluster), FUN=meanNoNa)
    
    rownames(clusterMfiMeans) <- clusterMfiMeans[,1]; clusterMfiMeans <- clusterMfiMeans[,2:ncol(clusterMfiMeans)]
    if( FALSE ){ # z-score
      clusterMfiMeans <- t(scale(clusterMfiMeans))
    } else{ # don't z-score
      clusterMfiMeans <- t(clusterMfiMeans)
    }
    clusterMfiMeansLong <- reshape2::melt(clusterMfiMeans); colnames(clusterMfiMeansLong) <- c("marker","cluster","value")
    
    gg_color_hue <- function(n) {
      hues = seq(15, 375, length = n + 1)
      hcl(h = hues, l = 65, c = 100)[1:n]
    }
    
    tp <- clusterMfiMeans
    rownames(tp) <- gsub("\\.","",gsub("Geometric.Mean..","",rownames(tp)))
    rownames(tp) <- gsub("CD452","CD45-2",rownames(tp))
    clustercols <- gg_color_hue( ncol(tp)); names(clustercols) <- 1:ncol(tp)
    pdf( paste0(plotDir,"Tconvs",nclust,"_FlowMarkerMFIHeatmap.pdf"),width=5,height=5 )
    p <- Heatmap(tp,name="mean\ngMFI",column_names_rot = 0,column_title="Tconv Clusters\nMean Geometric Mean of Flow Markers",cluster_columns=FALSE)
    print(p)
    dev.off()
  }
  
  soDf <- data.frame( Embeddings(soTconvs, reduction = "umap") )
  soDf <- cbind( soDf[soTconvs$libid,], soTconvs@meta.data)
  
  ## Predicted Labels Plots
  if(TRUE){
    png( paste(plotDir,"SeuratClusterPlots/Tconvs",nclust,"_cellTypist_AllenL3_UMAP.png"),width=1000,height=600 )
    p <- ggplot( soDf, aes(x=umap_1,y=umap_2,color=seurat_clusters)) + geom_point(size=0.5) + facet_wrap(~predictedLabels2, nrow=3) + theme(text = element_text(size = 11))
    print(p)
    dev.off()
  }
  
  clustercols <- gg_color_hue(length(unique(soDf$seurat_clusters)))
  ## Make UMAPS of the missing markers
  il17s <- unique(ens2hgnc[grepl("IL17",ens2hgnc) & !grepl("R",ens2hgnc)])
  for( g in c(absentTconvMarkers,tconvMarkers,c("CXCR4","IL21", "IL4", "IL13"), il17s) ){
  # for( g in c("CD5","NR4A1")){
    print(g)
    ens <- names(ens2hgnc)[ ens2hgnc == g & names(ens2hgnc) %in% rownames(counts_pc)]
    if( ens %in% rownames(counts_pc_norm) ){
      soDf$g <- log1p(as.numeric(counts_pc_norm[ens,rownames(soDf)]))
      soDf <- soDf[ order(soDf$g),]
      p <- ggplot( soDf, aes(x=umap_1,y=umap_2,color=g)) + geom_point() + scale_color_viridis(option="B") +labs(title=paste0(g," RNA"),size="",color="log\nexpr") 

    } else{ ## + and - markers
      soDf$gex <- log1p(as.numeric(counts_pc[ens,rownames(soDf)]))
      soDf$g <- ifelse( as.numeric(counts_pc[ens,rownames(soDf)]) > 0, "+", "-")
      soDf <- soDf[ order(soDf$gex),]
      p <- ggplot( soDf, aes(x=umap_1,y=umap_2,color=gex)) + geom_point() + scale_color_viridis(option="B") +labs(title=paste0(g," RNA"),size="",color="cluster") 
      # Color by cluster
      # p <- ggplot( soDf, aes(x=umap_1,y=umap_2,color=seurat_clusters,size=g)) + geom_point() + scale_color_manual(values=clustercols) + scale_size_manual( values=c("+"=4,"-"=0.005)) +labs(title=paste0(g," RNA +/-"),size="",color="cluster") 
      # Color by expression
      # p <- ggplot( soDf, aes(x=umap_1,y=umap_2,color=gex,size=g)) + geom_point()  + scale_size_manual( values=c("+"=2,"-"=0.005)) +labs(title=paste0(g," RNA +/-"),size="",color="log\nexpression") + scale_color_viridis(option="B")
    }
    png(paste0(plotDir,"SeuratGexTconvsUMAP/Tconv",nclust,"_",g,".png"),width=500,height=400)
    print(p)
    dev.off()
  } 

}


# Show plots and clusters for Treg
tregOpts <- tregClusterUMAPOptimalResults$hyperParamGridOptClusterAndUMAP.df
tregOpts <- tregOpts[ tregOpts$nClusters > 1,]
nclusters <- unique(tregOpts$nClusters)
tregOpts <- tregOpts[rev(order(tregOpts$meanEvalMetric)),]
TregOpts <- do.call( rbind, lapply(nclusters, function(nclust) tregOpts[ tregOpts$nClusters == nclust,][1,] ))
png(paste0(plotDir,"TregClusterNumEvalMetrics.png"),width=500,height=500)
ggplot(TregOpts, aes(x=nClusters,y=meanEvalMetric)) + geom_point() + labs(title="Treg Cluster Number Evaluation")
dev.off()
nclusts <- unique(tregOpts$nClusters)
nclusts <- nclusts[nclusts %in% 2:6]
for( nclust in nclusts ){
  print(nclust)
  tregBestParams <- tregOpts[ tregOpts$nClusters == nclust,]
  soTregs <- FindNeighbors(soTregs, reduction = "pca", dims = 1:tregBestParams$findNeighborsDim[1])
  soTregs <- FindClusters(soTregs, resolution = tregBestParams[1,"findClustersRes"], verbose = FALSE)
  soTregs <- RunUMAP(soTregs, dims = 1:tregBestParams$findNeighborsDim[1], verbose = FALSE)
  soTregs <- JoinLayers(soTregs, assay = "RNA")
  
    
  # Make Upset Plot
  makeClusterExpansionUpsetPlots( soTregs, title=paste0("Tregs ", nclust, ", Expanded Clones By Cluster"),filename=paste0(plotDir,"Tregs",nclust,"_clusterSharing_upset.png"))
  next
  
  if(FALSE){ # Cluster SHaring Plot
    clusterSharingPlot <- makeClusterExpansionPlots( soTregs)
    png( paste0(plotDir,"Tregs",nclust,"_clusterSharing_UMAP.png"),width=400,height=400 )
    print(clusterSharingPlot)
    dev.off()

    nclust <- 3
    airlinePlot <- getAirlinePlot(soTregs, alphaBetaPairsOnly=TRUE) + labs(title= paste0("Tregs ", nclust, " clusters") )
    # png( paste0(plotDir,"Tregs",nclust,"_airline_UMAP.png"),width=600,height=500 )
    pdf( paste0(plotDir,"Tregs",nclust,"_airline_UMAP.pdf"),width=7.6,height=6 )
    print(airlinePlot)
    dev.off()
  }

  
  if(FALSE){
    
    clustsMarkersTregsPos <- FindAllMarkers(soTregs)
  
    
    
  write.table(  clustsMarkersTregsPos
,paste0(plotDir,"Tregs",nclust,"_markerGenes.txt"),quote=FALSE,sep="\t",col.names=NA)
    
    # Get top markers per cluster
    clustsMarkersTregsPos <- clustsMarkersTregsPos[clustsMarkersTregsPos$avg_log2FC > 0,]
    ngenes <- 10
    clustsMarkersTregsPos <- unique( do.call( c, lapply( unique(clustsMarkersTregsPos$cluster ), function( clust ) clustsMarkersTregsPos$gene[ clustsMarkersTregsPos$cluster == clust][1:ngenes] ) ) )
    
    # Create a DotPlot of the expression of these genes in seuratQCMergedCleanedDS
    fontSize=10
    dotPlot.tmp <- DotPlot(soTregs, features = clustsMarkersTregsPos) +
      theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
        text = element_text(size = fontSize),
        axis.text.y = element_text(size = fontSize),
        axis.title.y = element_text(size = fontSize),
        legend.text = element_text(size = fontSize),
        legend.title = element_text(size = fontSize),
        strip.text = element_text(size = fontSize),
        plot.title = element_text(size = fontSize)) + labs(title=paste0(nclust," Treg Clusters Top Markers"))
    
    # Print the DotPlot
    #pdf(file.path(plotDir, paste0("Tregs",nclust, "_clusterDefiningGenesDotPlot_top10genes.pdf")), height = 3.5, width = 8)
    png(file.path(plotDir, paste0("Tregs",nclust, "_clusterDefiningGenesDotPlot_top10genes.png")), height = 250, width = 600)

    print(dotPlot.tmp  + scale_color_gradient2(low = "blue", mid = "white", high = "red"))
    dev.off()
  }
  
  # Create a DotPlot of the expression of these genes in seuratQCMergedCleanedDS
  # Order the features so they're cluster
  ens  <- names(ens2hgnc)[ens2hgnc %in% tregMarkers2 & names(ens2hgnc) %in% rownames(counts_pc_norm)]
    ## Cluster genes
  tp <- t(scale(t(log2(1+counts_pc_norm[ens, soTconvs$libid]))))
  dist_matrix <- dist(tp)
  # Perform hierarchical clustering
  hc <- hclust(dist_matrix)
  # Get the order of columns based on hierarchical clustering
  column_order <- hc$order
  geneNames <- as.character( ens2hgnc[ ens[column_order]] )
  
  fontSize=10
  dotPlot.tmp <- DotPlot(soTregs, features = geneNames) +
      theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8),
        text = element_text(size = fontSize),
        axis.text.y = element_text(size = fontSize),
        axis.title.y = element_text(size = fontSize),
        legend.text = element_text(size = fontSize),
        legend.title = element_text(size = fontSize),
        strip.text = element_text(size = fontSize),
        plot.title = element_text(size = fontSize)) + labs(title=paste0(nclust," Treg Clusters, Curated Markers"))
    
  # Print the DotPlot
  #pdf(file.path(plotDir, paste0("Tregs",nclust, "_TregMarkersDotPlot_2.pdf")), height = 3, width = 7)
  png(file.path(plotDir, paste0("Tregs",nclust, "_TregMarkersDotPlot_2.png")), height = 250, width = 600)
  print(dotPlot.tmp  + scale_color_gradient2(low = "blue", mid = "white", high = "red"))
  dev.off()
  
  pdf(file.path(plotDir, paste0("Tregs",nclust, "_UMAP.pdf")), height = 5, width = 5.4)
  dimPlot.tmp <- DimPlot(soTregs,
  label = FALSE,
  repel = TRUE,
  group.by = "seurat_clusters")
  print(dimPlot.tmp)
  dev.off()
  
    # pdf(file.path(plotDir, paste0("Tregs3_UMAP_donorID.pdf")), height = 5, width = 9.2)
    png(file.path(plotDir, paste0("Tregs3_UMAP_donorID.png")), height = 400, width = 690)

    dimPlot.tmp <- DimPlot(soTregs,
    label = FALSE,
    repel = TRUE,
    group.by = "donorID")
    print(dimPlot.tmp)
    dev.off()
  
    ### Plot flow markers
  if(FALSE){
    subanno[,markerCols] <- apply(subanno[,markerCols],2, function(r) as.numeric(r)) 
    subanno <- subanno[ subanno$libid %in% soTregs$libid,]
    subanno$cluster <- soTregs@meta.data[subanno$libid,"seurat_clusters"]
    clusterMfiMeans <- aggregate( scale(subanno[,markerCols]), by=list(subanno$cluster), FUN=meanNoNa)
    
    rownames(clusterMfiMeans) <- clusterMfiMeans[,1]; clusterMfiMeans <- clusterMfiMeans[,2:ncol(clusterMfiMeans)]
    if( FALSE ){ # z-score
      clusterMfiMeans <- t(scale(clusterMfiMeans))
    } else{ # don't z-score
      clusterMfiMeans <- t(clusterMfiMeans)
    }
    clusterMfiMeansLong <- reshape2::melt(clusterMfiMeans); colnames(clusterMfiMeansLong) <- c("marker","cluster","value")
    
    gg_color_hue <- function(n) {
      hues = seq(15, 375, length = n + 1)
      hcl(h = hues, l = 65, c = 100)[1:n]
    }
    
    tp <- clusterMfiMeans
    rownames(tp) <- gsub("\\.","",gsub("Geometric.Mean..","",rownames(tp)))
    rownames(tp) <- gsub("CD452","CD45-2",rownames(tp))
    clustercols <- gg_color_hue( ncol(tp)); names(clustercols) <- 1:ncol(tp)
    pdf( paste0(plotDir,"Tregs",nclust,"_FlowMarkerMFIHeatmap.pdf"),width=5,height=5 )
    p <- Heatmap(tp,name="mean\ngMFI",column_names_rot = 0,column_title="Treg Clusters\nMean Geometric Mean of Flow Markers",cluster_columns=FALSE)
    print(p)
    dev.off()
  }
  
  soDf <- data.frame( Embeddings(soTregs, reduction = "umap") )
  soDf <- cbind( soDf[soTregs$libid,], soTregs@meta.data)
  
  ## Predicted Labels Plots
  if(FALSE){
    png( paste(plotDir,"Tregs",nclust,"_cellTypist_AllenL3_UMAP.png"),width=1000,height=600 )
    p <- ggplot( soDf, aes(x=umap_1,y=umap_2,color=seurat_clusters)) + geom_point(size=0.5) + facet_wrap(~predictedLabels2, nrow=3) + theme(text = element_text(size = 11))
    print(p)
    dev.off()
  }
  
  clustercols <- gg_color_hue(length(unique(soDf$seurat_clusters)))
  ## Make UMAPS of the missing markers
  for( g in c(absentTregMarkers,tregMarkers) ){
  # for( g in c("CD5","NR4A1")){
    print(g)
    ens <- names(ens2hgnc)[ ens2hgnc == g & names(ens2hgnc) %in% rownames(counts_pc)]
    if( ens %in% rownames(counts_pc_norm) ){
      soDf$g <- log1p(as.numeric(counts_pc_norm[ens,rownames(soDf)]))
      soDf <- soDf[ order(soDf$g),]
      p <- ggplot( soDf, aes(x=umap_1,y=umap_2,color=g)) + geom_point() + scale_color_viridis(option="B") +labs(title=paste0(g," RNA"),size="",color="log\nexpr") 

    } else{ ## + and - markers
      soDf$gex <- log1p(as.numeric(counts_pc[ens,rownames(soDf)]))
      soDf$g <- ifelse( as.numeric(counts_pc[ens,rownames(soDf)]) > 0, "+", "-")
      soDf <- soDf[ order(soDf$gex),]
      p <- ggplot( soDf, aes(x=umap_1,y=umap_2,color=gex)) + geom_point() + scale_color_viridis(option="B") +labs(title=paste0(g," RNA"),size="",color="cluster") 
      # Color by cluster
      # p <- ggplot( soDf, aes(x=umap_1,y=umap_2,color=seurat_clusters,size=g)) + geom_point() + scale_color_manual(values=clustercols) + scale_size_manual( values=c("+"=4,"-"=0.005)) +labs(title=paste0(g," RNA +/-"),size="",color="cluster") 
      # Color by expression
      # p <- ggplot( soDf, aes(x=umap_1,y=umap_2,color=gex,size=g)) + geom_point()  + scale_size_manual( values=c("+"=2,"-"=0.005)) +labs(title=paste0(g," RNA +/-"),size="",color="log\nexpression") + scale_color_viridis(option="B")
    }
    png(paste0(plotDir,"SeuratGexTregsUMAP/Treg",nclust,"_",g,".png"),width=500,height=400)
    print(p)
    dev.off()
  } 

}



### Read in celltypist stuff
ct <- read.csv("../../data/2024-12-10/P390_filtered_corrected_predicted_labels.csv",row.names=1)
soTconvs@meta.data$predictedLabels <- ct[ soTconvs$libid,"predicted_labels"]
tcells <- c("CD8a/a","Double-positive thymocytes","Regulatory T cells","T(agonist)","Tcm/Naive cytotoxic T cells","Tcm/Naive helper T cells","Tem/Effector helper T cells","Treg(diff)","Type 1 helper T cells","Type 17 helper T cells")
soTconvs@meta.data$predictedLabels2 <- ifelse( soTconvs@meta.data$predictedLabels %in% tcells ,soTconvs@meta.data$predictedLabels,"other")

## Allen celltypes
### Read in celltypist stuff
ct <- read.csv("../../data/2024-12-10/P390_filtered_corrected_ref_pbmc_clean_celltypist_model_AIFI_L3predicted_labels.csv",row.names=1)
soTconvs@meta.data$predictedLabels <- ct[ soTconvs$libid,"predicted_labels"]
tcells <- unique(ct$predicted_labels[ grepl( "CD4",ct$predicted_labels) |  grepl( "CD8",ct$predicted_labels) | grepl( "T",ct$predicted_labels) ])
soTconvs@meta.data$predictedLabels2 <- ifelse( soTconvs@meta.data$predictedLabels %in% tcells ,soTconvs@meta.data$predictedLabels,"other")
## Do Tregs
soTregs@meta.data$predictedLabels <- ct[ soTregs$libid,"predicted_labels"]
tcells <- unique(ct$predicted_labels[ grepl( "CD4",ct$predicted_labels) |  grepl( "CD8",ct$predicted_labels) | grepl( "T",ct$predicted_labels) ])
soTregs@meta.data$predictedLabels2 <- ifelse( soTregs@meta.data$predictedLabels %in% tcells ,soTregs@meta.data$predictedLabels,"other")

DimPlot(soTconvs,
  label = TRUE,
  repel = TRUE,
  group.by = "predictedLabels2")

DimPlot(soTconvs,
  label = TRUE,
  repel = TRUE,
  split.by = "seurat_clusters", group.by="predictedLabels2")

DimPlot(soTconvs,
        label = TRUE,
        repel = TRUE,
        group.by = "seurat_clusters", split.by="predictedLabels2", nrow=2)

soTregs@meta.data$predictedLabels <- ct[ soTregs$libid,"predicted_labels"]
soTregs@meta.data$predictedLabels2 <- ifelse( soTregs@meta.data$predictedLabels %in% tcells ,soTregs@meta.data$predictedLabels,"other")
DimPlot(soTregs,
  label = TRUE,
  repel = TRUE,
  group.by = "predictedLabels2")


```

```{r 02/11/25 combined cluster airline plot}

soFiltered$combinedClusters
airlinePlot <- getAirlinePlot(soFiltered, alphaBetaPairsOnly=TRUE,colorCol="combinedClusters") + labs(title= paste0("5 Tconv clusters, 3 Treg Clusters") )
print(airlinePlot)

### paired circos
subpairs <- pairs[ pairs$sample %in% soFiltered$libid, ]
subpairs$full_nt_sequence <- paste( subpairs$CDR3ant, subpairs$CDR3bnt)
subpairs$clonotypes <- assignClonotypeNumbers(subpairs$full_nt_sequence,"p")
subpairs$CD4Type <- design[ subpairs$sample, "CD4Type"]
subpairs <- subpairs[ subpairs$clonotypes != "singleton",]
subpairs$v_gene <- paste( subpairs$TRAV, subpairs$TRBV )
subpairs$j_gene <- paste( subpairs$TRAJ, subpairs$TRBJ)
subpairs$libid <- subpairs$sample
subpairs$studyGroup <- design[ subpairs$libid, "studyGroup"]

pcloncols <- make_colors( unique(subpairs$clonotypes) )
donorCols <- make_colors(unique(subpairs$donorID))
t1dcols <- c("Control"="lightblue","T1D"="orange")
sortCols <- c("Treg"="red","Tconv"="blue","Tconventional"="blue")
sortCols <- c("Treg"="blue","Tconv"="red","Tconventional"="red")

plotdir <- "../../data/2025-02-10/"

subpairs <- subpairs[ order(subpairs$donorID, subpairs$CD4Type),]
subpairs$typeDonor <- paste( subpairs$CD4Type, subpairs$donorID)
pGraph <- makeTcrGraph( subpairs )
pdf(paste0(plotdir,"pairCircos_TregTconvSharing_expandedOnly2.pdf"),width=10,height=7)
makeCircos(
  pGraph,
  annoFields = c("CD4Type","studyGroup","donorID"),
  #annoFields = c("CD4Type","sampleRepositoryID","clonotypes"),
  annoPalettes = list(
    # unnamed vectors of colors with the right length are allowed
    # named vectors of colors are also allowed
    CD4Type = sortCols,
    donorID=donorCols,
    studyGroup= t1dcols
    #project = c("P390-2"="grey","P390-1"="black","P390-3"="orange","P390-4"="brown","P390-5"="green","P390-6"="purple"),
    #clonotypes = pcloncols
  ),
  #sortField = "CD4Type",
  sortField = "typeDonor",
  arcColorField = "CD4Type",
  title="Alpha/Beta Nucleotide Pairs"
)
dev.off();

## Make combined Treg+Tconv upset plot for expansion
png("../../data/2025-02-10/TconvTregCombinedClusterExpansionUpsetPlot.png",width=700,height=600)
p <- makeClusterExpansionUpsetPlots( soFiltered, clusterCol = "combinedClusters" )
print(p)
grid.text("Treg and Tconv Inter-cluster Expansion",x = 0.65, y=0.95, gp=gpar(fontsize=20))
dev.off()

## Are there trinity pairs shared between donors?
pairs$trinityPair <- paste( pairs$trinitya, pairs$trinityb)
pairs$trinityPairDonor <- paste( pairs$trinityPair, pairs$donorID)
z <- pairs[ !duplicated(pairs$trinityPairDonor),]

```

```{r 01/10/25 Plot Tested Treg TCRs on UMAP}

nclust <- 3
tregBestParams <- TregOpts[ TregOpts$nClusters == nclust,]
soTregs <- FindNeighbors(soTregs, reduction = "pca", dims = 1:tregBestParams$findNeighborsDim[1])
soTregs <- FindClusters(soTregs, resolution = tregBestParams[1,"findClustersRes"], verbose = FALSE)
soTregs <- RunUMAP(soTregs, dims = 1:tregBestParams$findNeighborsDim[1], verbose = FALSE)
soTregs <- JoinLayers(soTregs, assay = "RNA")

nclust <- 5
tconvBestParams <- tconvOpts[ tconvOpts$nClusters == nclust,]
soTconvs <- RunUMAP(soTconvs, dims = 1:tconvBestParams$findNeighborsDim[1], verbose = FALSE)
soTconvs <- FindNeighbors(soTconvs, reduction = "pca", dims = 1:tconvBestParams$findNeighborsDim[1])
soTconvs <- FindClusters(soTconvs, resolution = tconvBestParams[1,"findClustersRes"], verbose = FALSE)
soTconvs <- JoinLayers(soTconvs, assay = "RNA")

soDf <- data.frame( Embeddings(soFiltered, reduction = "umap") )
soDf <- cbind( soDf[soFiltered$libid,], soFiltered@meta.data)
#pdf("../../data/2025-02-10/PaperFigures/TregTconv_UMAP_byCellType.pdf",width=6,height=3.8)
png("../../data/2025-02-10/PaperFigures/TregTconv_UMAP_byCellType.png",width=500,height=300)

ggplot( soDf, aes(x=umap_1,y=umap_2,color=cellType)) + geom_point(size=1) + labs(x="UMAP 1",y="UMAP 2",color="") + scale_color_manual( values= c("Tconventional"="red","Treg"="blue"))
dev.off()

soDf <- data.frame( Embeddings(soTregs, reduction = "umap") )
soDf <- cbind( soDf[soTregs$libid,], soTregs@meta.data)
png("../../data/2025-02-10/PaperFigures/Tregs_UMAP_T1DHC.png",width=420,height=320)
#pdf("../../data/2025-02-10/PaperFigures/Tregs_UMAP_T1DHC.pdf",width=5.4,height=4)
ggplot( soDf, aes(x=umap_1,y=umap_2,color=studyGroup)) + geom_point(size=1) + labs(x="UMAP 1",y="UMAP 2",color="",title="Tregs, 3 clusters")
dev.off()

soDf <- data.frame( Embeddings(soTconvs, reduction = "umap") )
soDf <- cbind( soDf[soTconvs$libid,], soTconvs@meta.data)
# pdf("../../data/2025-02-10/PaperFigures/Tconvs_UMAP_T1DHC.pdf",width=5.4,height=4)
png("../../data/2025-02-10/PaperFigures/Tconvs_UMAP_T1DHC.png",width=420,height=320)

ggplot( soDf, aes(x=umap_1,y=umap_2,color=studyGroup)) + geom_point(size=1) + labs(x="UMAP 1",y="UMAP 2",color="",title="Tconvs, 3 clusters")
dev.off()

### CD45 RA 06/13/25
soDf <- data.frame( Embeddings(soTregs, reduction = "umap") )
soDf$CD45RA <- as.numeric( subanno[ rownames(soDf), "Geometric.Mean..CD45RA."] )
soDf <- soDf[ order(soDf$CD45RA),]
# pdf("../../data/2025-06-10/Tregs_UMAP_CD45RA.pdf",width=5.2,height=4)
png("../../data/2025-06-10/Tregs_UMAP_CD45RA.png",width=450,height=350)
ggplot( soDf, aes(x=umap_1,y=umap_2,color=CD45RA)) + geom_point(size=1) + labs(x="UMAP 1",y="UMAP 2",title="Tregs, 3 clusters", color="CD45RA\nMFI") + scale_color_viridis( option="B")
dev.off()
soDf <- data.frame( Embeddings(soTconvs, reduction = "umap") )
soDf$CD45RA <- as.numeric( subanno[ rownames(soDf), "Geometric.Mean..CD45RA."] )
soDf <- soDf[ order(soDf$CD45RA),]
# pdf("../../data/2025-06-10/Tconvs_UMAP_CD45RA.pdf",width=5.2,height=4)
png("../../data/2025-06-10/Tconvs_UMAP_CD45RA.png",width=450,height=350)

ggplot( soDf, aes(x=umap_1,y=umap_2,color=CD45RA)) + geom_point(size=1) + labs(x="UMAP 1",y="UMAP 2",title="Tconvs, 5 clusters", color="CD45RA\nMFI") + scale_color_viridis( option="B")
dev.off()

testedTCRDf <- data.frame( read_xlsx("../../data/2025-01-10/Expanded TCRs Helmsley Treg_Tconv for specifcity testing 01-03-24.xlsx") )
testedTCRs <- testedTCRDf$...15[2:nrow(testedTCRDf)]
alphas <- testedTCRs[ seq(1,length(testedTCRs),2)]
betas <- testedTCRs[ seq(2,length(testedTCRs),2)]

### Output data to TCRDist3 format
pairDf <- pairs[ pairs$sample%in% combinedDf$libid,]
pairtab <- table(pairDf$pair)
pairDf <- pairDf[!duplicated(pairDf$pair),]
pairDf$count <- pairtab[ pairDf$pair]
pairDf$epitope <- c("islet")
pairDf <- pairDf[,c("donorID","epitope","count","TRAV","TRAJ","CDR3a","CDR3ant","TRBV","TRBJ","CDR3b","CDR3bnt","pair")]
colnames(pairDf) <- c("subject","epitope","count","v_a_gene","j_a_gene","cdr3_a_aa","cdr3_a_nucseq","v_b_gene","j_b_gene","cdr3_b_aa","cdr3_b_nucseq","clone_id")
### Now put the unpaired ones
unpairedAnno <- tcrs[ tcrs$libid %in% combinedDf$libid & ! tcrs$libid %in% pairs$libid & tcrs$chain %in% c("TRA","TRB"),]
unpairedAnno$epitope <- "islet"
a <- unpairedAnno[ unpairedAnno$chain == "TRA", c( "libid", "junction", "full_nt_sequence", "v_gene", "j_gene", "epitope", "project","donorID")]; colnames(a) <- c("libid", "cdr3_a_aa", "cdr3_a_nucseq", "v_a_gene", "j_a_gene", "epitope","project","subject")
# Pair the alphas with a dummy beta CDR3 chain
dummyA <- c("cdr3_b_aa"="CSARVFGWEGSSYNEQFF","cdr3_b_nucseq"="GGTGCTGTCGTCTCTCAACATCCGAGCTGGGTTATCTGTAAGAGTGGAACCTCTGTGAAGATCGAGTGCCGTTCCCTGGACTTTCAGGCCACAACTATGTTTTGGTATCGTCAGTTCCCGAAACAGAGTCTCATGCTGATGGCAACTTCCAATGAGGGCTCCAAGGCCACATACGAGCAAGGCGTCGAGAAGGACAAGTTTCTCATCAACCATGCAAGCCTGACCTTGTCCACTCTGACAGTGACCAGTGCCCATCCTGAAGACAGCAGCTTCTACATCTGCAGTGCTAGAGTATTCGGATGGGAGGGAAGCTCCTACAATGAGCAGTTCTTCGGGCCAGGGACACGGCTCACCGTGCTAG","v_b_gene"="TRBV20-1*01","j_b_gene"="TRBJ2-1*01")
a <- cbind(a,t(sapply(1:nrow(a), function(i) dummyA)))
a$clone_id <- paste( a$cdr3_a_nucseq, a$cdr3_b_nucseq)
a$count <- table(a$clone_id)[a$clone_id]
a <- a[!duplicated(a$clone_id),]

b <- unpairedAnno[ unpairedAnno$chain == "TRB", c( "libid", "junction", "full_nt_sequence", "v_gene", "j_gene", "epitope", "project","donorID")]; colnames(b) <- c("libid", "cdr3_b_aa", "cdr3_b_nucseq", "v_b_gene", "j_b_gene", "epitope","project","subject")
# Pair the alphas with a dummy beta CDR3 chain
dummyB <- c("cdr3_a_aa"="CAVNSPASGNQFYF","cdr3_a_nucseq"="CGGAAGGAGGTGGAGCAGGATCCTGGACCCTTCAATGTTCCAGAGGGAGCCACTGTCGCTTTCAACTGTACTTACAGCAACAGTGCTTCTCAGTCTTTCTTCTGGTACAGACAGGATTGCAGGAAAGAACCTAAGTTGCTGATGTCCGTATACTCCAGTGGTAACGAAGATGGAAGGTTTACAGCACAGCTCAATAGAGCCAGCCAGTATATTTCCCTGCTCATCAGAGACTCCAAGCTCAGTGATTCAGCCACCTACCTCTGTGCGGTGAACAGCCCCGCGAGCGGTAACCAGTTCTATTTTGGGACAGGGACAAGTTTGACGGTCATTCCAA","v_a_gene"="TRAV12-1*01","j_a_gene"="TRAJ49*01")
b <- cbind(b,t(sapply(1:nrow(b), function(i) dummyB)))
b$clone_id <- paste( b$cdr3_a_nucseq, b$cdr3_b_nucseq)
b$count <- table(b$clone_id)[b$clone_id]
b <- b[!duplicated(b$clone_id),]

cnames <- colnames(pairDf)
combo <- rbind(a[,cnames],b[,cnames],pairDf[,cnames])

combo[,c("v_a_gene","j_a_gene","v_b_gene","j_b_gene")] <- apply( combo[,c("v_a_gene","j_a_gene","v_b_gene","j_b_gene")],2, function(col) ifelse( !grepl("\\*",col), paste0(col,"*01"), col ) )

write.table( combo, "../../data/2025-04-10/P390TCRS_for_TCRDist3.csv",quote=FALSE,sep=",",col.names=TRUE,row.names=FALSE)

# Remove the dummy sequences from combo
## Set the dummy ones to 'dummy' now
combo$cdr3_a_aa[ !combo$barcode %in% pairs$sample & combo$cdr3_a_aa == dummyB["cdr3_a_aa"] ] <- "dummy"
combo$cdr3_b_aa[ !combo$barcode %in% pairs$sample & combo$cdr3_b_aa == dummyA["cdr3_b_aa"] ] <- "dummy"
#saveRDS(combo,"combo.RDS")

for( i in 1:length(alphas) ){
  a <- alphas[i]
  b <- betas[i]
  print( paste(i,a,b))
  
  libs <- pairs$sample[ pairs$CDR3a == a & pairs$CDR3b == b]
  soDf$anno <- soDf$libid %in% libs
  soDf <- soDf[ order(soDf$anno),]
  project <- soDf[libs,"project"][1]
  p <- ggplot( soDf, aes(x=umap_1,y=umap_2,size=anno, color=seurat_clusters) ) + geom_point() + scale_size_manual( values=c("TRUE"=3,"FALSE"=0.1)) + labs(x="UMAP 1",y="UMAP 2",title=paste0(project,", clonotype ",i,": ",length(libs)," cells\n",a,"\n",b))
  png( paste0("../../data/2025-01-10/TestedTCRUMAPs/Clone",i,"_",a,"_",b,".png"),width=585,height=500)
  print(p)
  dev.off()
}

### Show specific and non-specific clonotypes per cell type
testedTCRDf <- data.frame( read_xlsx("../../data/2025-01-10/TCR pairs tested 01-10-25.xlsx") )
for( celltype in c("Tconventional","Treg") ){
  print(celltype)
  if( celltype == "Tconventional" ){
    soDf <- data.frame( Embeddings(soTconvs, reduction = "umap") )
    soDf <- cbind( soDf[soTconvs$libid,], soTconvs@meta.data)
    nclust <- 5
  } else{
    soDf <- data.frame( Embeddings(soTregs, reduction = "umap") )
    soDf <- cbind( soDf[soTregs$libid,], soTregs@meta.data)
    nclust <- 3
  }
  soDf$specificity <- "untested"
  
  testedDf <- testedTCRDf[ testedTCRDf$CD4Type == celltype,]
  nonSpecificLibs <- unique( pairs$sample[ pairs$CDR3pair %in% testedDf$CDR3pair[ testedDf$Specificty.testing == "non-specific"] ] )
  specificLibs <- unique( pairs$sample[ pairs$CDR3pair %in% testedDf$CDR3pair[ testedDf$Specificty.testing != "non-specific"] ] )
  soDf[ specificLibs, "specificity"] <- "specific"
  soDf[ nonSpecificLibs, "specificity"] <- "non-specific"
  soDf <- soDf[ order(soDf$specificity != "untested"),]
  
  p <- ggplot( soDf, aes(x=umap_1,y=umap_2,color=seurat_clusters,size=specificity,shape=specificity)) + geom_point() + scale_size_manual( values=c("untested"=0.01,"non-specific"=3,"specific"=3)) + scale_shape_manual( values=c("untested"=20,"non-specific"=1,"specific"=19)) + labs(color="cluster",x="UMAP 1",y="UMAP 2",title=paste0(celltype, " ", nclust,"\nTested Specificities"))
  png( paste0("../../data/2025-01-10/", celltype,nclust,"_specificity_UMAP.png"),width=500,height=400 )
  print(p)
  dev.off()
}

# Treg-Tconv sharing in P390
design$CD4Type <- ifelse( design$sort %in% c("CD154+CD69+ CD4 T cells","CD154+CD69+ CD4 T cells ","CD154+CD69+ CDRA+CD95+CCR7lo CD4 T cells"), "Tconventional","Treg")
pairsTreg <- pairs[ design[ pairs$sample, "CD4Type"] == "Treg",]
pairsTconv <- pairs[ design[ pairs$sample, "CD4Type"] == "Tconventional",]

tregTconvPairs <- unique( intersect( pairsTreg$CDR3pair, pairsTconv$CDR3pair) )
matchingLibs <- unique( pairs$sample[ pairs$CDR3pair %in% tregTconvPairs] )
table( so@meta.data$mismatched, ifelse( so@meta.data$libid %in% matchingLibs, "matchedTCR","other"))


# Heat map of DEGs between Treg and Tconv with the new Seurat clustering
commoncols <- intersect( colnames(soTregs@meta.data ), colnames(soTconvs@meta.data)  )
combinedDf <- rbind( soTregs@meta.data[,commoncols], soTconvs@meta.data[,commoncols])
combinedDf$cluster <- paste0( ifelse(combinedDf$libid %in% soTregs$libid, "Treg","Tconv"), "_", as.character( combinedDf$seurat_clusters ) )
combinedDf$donorId <- design_qc[ combinedDf$libid, "donorId"]
combinedDf$donorType <- paste0( combinedDf$CD4Type, "_", combinedDf$donorId)
df <- combinedDf; df$group <- df$cluster
groups <- unique(df$group)

# Combine counts of all libraries that fall into each grouping, excluding iNKT cells, MAit cells, and cells that might not be sorted correctly "toFilter".
bulk_pc_norm <- sapply( groups, function(group) rowSums(counts_pc[,df$libid[ df$group == group ]] ) )
g <- rownames(counts_pc)[ rowMeans(counts_pc[,df$libid]>0) >= 0.3]
# g <- rownames(bulk_pc_norm)[rowMeans(bulk_pc_norm > 0) >= 0.1]
bulk_pc_norm <- bulk_pc_norm[g,]
bulk_pc_norm <- normalize_counts(bulk_pc_norm,"tmm")
designBulk <- data.frame( t(sapply(colnames(bulk_pc_norm), function(s) strsplit(s,"_")[[1]])) )
colnames(designBulk) <- c("type","clusterNumber")
designBulk$cluster <- rownames(designBulk)
tregDE <- tregDE[ order(tregDE$P.Value),]
ens <- rownames(tregDE)[ tregDE$adj.P.Val <= 0.05][1:50]

tp <- t(scale(t(log2(1+bulk_pc_norm[ens,]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
tconvCols <-c("#F8766D","#A3A500","#00BF7D","#00B0F6","#E76BF3"); names(tconvCols) <- paste0( "Tconv_",as.character(0:4) )
tregCols <-c("#F8766D","#00BF7D","#00B0F6"); names(tregCols) <- paste0( "Treg_",as.character(0:2) )
cols <- c(tconvCols,tregCols)
sortCols <- c("Tconv"="blue","Treg"="red")
ha <- HeatmapAnnotation(df=designBulk[,c("type","cluster")],col=list(type=sortCols,cluster=cols))
col_fun = colorRamp2(c(-3, 0, 3), c("blue", "white", "red"))
png(paste0("../../data/2025-01-10/TregTconvDE_SeuratClusters_heatmap.png"), width=350,height=800)
Heatmap(tp,show_column_names=FALSE,column_split=designBulk$type,top_annotation=ha,,column_title="Top 50 Treg vs. Tconv DE Genes\nBy Seurat Clustering",name="z-score\nlog\nexpression")
dev.off()

### Make heatmap of donor and type, not by cluster

ens <- sigs
libs <- rownames(designBulk); libs <- libs[order(designBulk$type)]
tp <- t(scale(t(log2(1+bulk_pc_norm[ens,libs]))))
rownames(tp) <- ens2hgnc[ rownames(tp)]
ha <- HeatmapAnnotation(df=list(type=designBulk[libs,"type"]), col=list("type"=c("Tconventional"="red","Treg"="blue")))
pdf("../../data/2023-04-17/TregVTconv_Top60_heatmap.pdf", width=9,height =9)
Heatmap(tp,show_column_names=FALSE,cluster_columns=FALSE,name="scaled\nlog2\nexpression", top_annotation=ha, cluster_rows=TRUE,column_title="Top 60 genes DE between Treg and Tconv" )
dev.off()



# Numbers of Tconv and Treg by HC and T1D with the new Seurat clustering
df$donorType <- paste0( df$donorId,"_",gsub("Tconventional","Tconv",df$CD4Type ) )
clusterTab <- data.frame( table(df$cluster, df$donorId) ); colnames(clusterTab) <- c("typeCluster","donorId","count")
clusterTab[,c("CD4Type","clusterNumber")] <- t(sapply( as.character(clusterTab$typeCluster), function(s) strsplit(s,"_")[[1]]))
clusterTab$studyGroup <- designBySrid[ clusterTab$donorId,"studyGroup"]
clusterTab$donorType <- paste0( clusterTab$donorId,"_",clusterTab$CD4Type)
donorTab <- table(df$donorType)
clusterTab$prop <- clusterTab$count/donorTab[clusterTab$donorType]
clusterTab$prop[is.na(clusterTab$prop)] <- 0
clusterTab$logit <- logitTransform( clusterTab$prop)

typeClusters <- unique(clusterTab$typeCluster)
pvals <- data.frame( cluster=typeClusters, P.Value = sapply( typeClusters, function(tc) clusterTab %>% filter(typeCluster == tc) %>% t.test(logit ~ studyGroup, data = .) %>% .$p.value ) )
pvals$adj.P.Val <- p.adjust( pvals$P.Value, method="BH")
pvals <- pvals[order(pvals$P.Value),]
rownames(pvals) <- pvals$cluster

clusterTab$studyGroup <- ifelse(clusterTab$studyGroup == "T1D","T1D","HC")
clusterTab$anno <- paste0( clusterTab$clusterNumber,"\n","padj: ", signif(pvals[ paste0("Tconv_",clusterTab$clusterNumber), "P.Value"],3))
clusterTab$anno <- paste0( clusterTab$clusterNumber,"\n","padj: ", signif(pvals[ paste0("Tconv_",clusterTab$clusterNumber), "adj.P.Val"],3))

#pdf("../../data/2025-02-10/PaperFigures/SeuratClusterProportions_Tconventional_ByT1D.pdf",width=8,height=5)
png("../../data/2025-02-10/PaperFigures/SeuratClusterProportions_Tconventional_ByT1D.png",width=700,height=400)

ggplot(clusterTab[ clusterTab$CD4Type == "Tconv",], aes(x=studyGroup,y=prop)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=1) + facet_wrap(~anno,nrow=1) + labs(x="",y="proportion",title="Tconv Proportion in Clusters\nby T1D Disease Status")
dev.off()
# pdf("../../data/2025-02-10/PaperFigures/SeuratClusterProportions_Treg_ByT1D.pdf",width=5,height=5)
png("../../data/2025-02-10/PaperFigures/SeuratClusterProportions_Treg_ByT1D.png",width=400,height=400)

ggplot(clusterTab[ clusterTab$CD4Type == "Treg",], aes(x=studyGroup,y=prop)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=1) + facet_wrap(~anno,nrow=1) + labs(x="",y="proportion",title="Treg Proportion in Clusters\nby T1D Disease Status")
dev.off()

### 05/06/25 Now do the same as above, but expanded
# Numbers of Tconv and Treg by HC and T1D with the new Seurat clustering
df <- combinedDf; df$group <- df$cluster
df <- df[ df$libid %in% expandedLibs,]
df$donorType <- paste0( df$donorId,"_",gsub("Tconventional","Tconv",df$CD4Type ) )
clusterTab <- data.frame( table(df$cluster, df$donorId) ); colnames(clusterTab) <- c("typeCluster","donorId","count")
clusterTab[,c("CD4Type","clusterNumber")] <- t(sapply( as.character(clusterTab$typeCluster), function(s) strsplit(s,"_")[[1]]))
clusterTab$studyGroup <- designBySrid[ clusterTab$donorId,"studyGroup"]
clusterTab$donorType <- paste0( clusterTab$donorId,"_",clusterTab$CD4Type)
donorTab <- table(df$donorType)
clusterTab$prop <- clusterTab$count/donorTab[clusterTab$donorType]
clusterTab$prop[is.na(clusterTab$prop)] <- 0
clusterTab$logit <- logitTransform( clusterTab$prop)

typeClusters <- unique(clusterTab$typeCluster)
pvals <- data.frame( cluster=typeClusters, P.Value = sapply( typeClusters, function(tc) clusterTab %>% filter(typeCluster == tc) %>% t.test(logit ~ studyGroup, data = .) %>% .$p.value ) )
pvals$adj.P.Val <- p.adjust( pvals$P.Value, method="BH")
pvals <- pvals[order(pvals$P.Value),]
rownames(pvals) <- pvals$cluster
clusterTab$studyGroup <- ifelse(clusterTab$studyGroup == "T1D","T1D","HC")
clusterTab$anno <- paste0( clusterTab$clusterNumber,"\n","padj: ", signif(pvals[ paste0("Tconv_",clusterTab$clusterNumber), "P.Value"],3))
clusterTab$anno <- paste0( clusterTab$clusterNumber,"\n","padj: ", signif(pvals[ paste0("Tconv_",clusterTab$clusterNumber), "adj.P.Val"],3))
png("../../data/2025-02-10/PaperFigures/SeuratExpandedClusterProportions_Tconventional_ByT1D.png",width=800,height=500)
ggplot(clusterTab[ clusterTab$CD4Type == "Tconv",], aes(x=studyGroup,y=prop)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=1) + facet_wrap(~anno,nrow=1) + labs(x="",y="proportion",title="Tconv Proportion in Clusters\nby T1D Disease Status")
dev.off()
png("../../data/2025-02-10/PaperFigures/SeuratExpandedClusterProportions_Treg_ByT1D.png",width=500,height=500)
ggplot(clusterTab[ clusterTab$CD4Type == "Treg",], aes(x=studyGroup,y=prop)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=1) + facet_wrap(~anno,nrow=1) + labs(x="",y="proportion",title="Treg Proportion in Clusters\nby T1D Disease Status")
dev.off()

z <- table( df$donorId, df$cluster )
z <- cbind(z,designByDonor[ rownames(z),"studyGroup"])
colnames(z)[ncol(z)] <- "studyGroup"
write.table(z,"../../data/2025-01-10/ClusterCountsByDonorAndCluster.txt",quote=FALSE,col.names=NA,sep="\t")

# Compute p-values for differences between T1D and non-T1D
clusterTab <- clusterTab[order(clusterTab$typeCluster, clusterTab$srid),]
clusters <- unique(clusterTab$typeCluster)
minval <- min(clusterTab$prop[clusterTab$prop!=0])/1
clusterTab$logitNormed <- log1p( (clusterTab$prop+minval)/(1-clusterTab$prop+minval))
pvals <- data.frame(cluster=clusters,P.Value=sapply( clusters, function(clust) t.test(clusterTab$logitNormed[clusterTab$studyGroup=="HC" & clusterTab$typeCluster == clust],clusterTab$logitNormed[clusterTab$studyGroup=="T1D" & clusterTab$typeCluster == clust])$p.value))
pvals <- pvals[order(pvals$P.Value),]
pvals$adj.P.Val <- p.adjust(pvals$P.Value, method="BH")
write.table(pvals,"../../data/2025-01-10/T1DvHC_SeuratClusters_pvalues.txt",quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)

inktMaitPairs <- pairs[ pairs$sample %in% iNKTMaitLibids,]
table( tregTconvPairs %in% inktMaitPairs$CDR3pair)
```

```{r 03/19/25 Compare Thomas's clusters with mine}

tconvMarkers10x <- read.csv("../../data/2025-02-10/20250312_top20_genes_per_cluster_Tconv.csv",header=TRUE,row.names=1)
colnames(tconvMarkers10x) <- paste0("Tconv10x_",(1:ncol(tconvMarkers10x))-1 )
tregMarkers10x <- read.csv("../../data/2025-02-10/202503312_top20_genes_per_cluster_Treg.csv",header=TRUE, row.names=1)
colnames(tregMarkers10x) <- paste0("Treg10x_",(1:ncol(tregMarkers10x))-1 )
markers10x <- cbind(tconvMarkers10x,tregMarkers10x)
markers10xEns <- apply(markers10x,2, function(gs) names(ens2hgnc)[ens2hgnc %in% gs & names(ens2hgnc) %in% rownames(counts_pc_norm)])
subcounts <- scale(t(log2(1+counts_pc_norm[unique(do.call(c,markers10xEns)),combinedDf$libid])))

markers10xExp <- sapply( markers10xEns, function(l) rowMeans(subcounts[,l]))

combinedDf[,colnames(markers10xExp)] <- markers10xExp[rownames(combinedDf),]
tregDf <- combinedDf[combinedDf$CD4Type == "Treg", c("seurat_clusters",colnames(markers10xExp)[grepl("Treg",colnames(markers10xExp))])  ]
tregDf <- melt(tregDf, id.vars = c("seurat_clusters")); colnames(tregDf) <- c("seurat_clusters","clusterSig10x","value")
tconvDf <- combinedDf[combinedDf$CD4Type == "Tconventional", c("seurat_clusters",colnames(markers10xExp)[grepl("Tconv",colnames(markers10xExp))])  ]
tconvDf <- melt(tconvDf, id.vars = c("seurat_clusters"));  colnames(tconvDf) <- c("seurat_clusters","clusterSig10x","value")

png("../../data/2025-02-10/Treg_10xClusterSigs_v_P390Clusters.png",width=600,height=300)
ggplot(tregDf, aes(x=seurat_clusters,y=value)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=0.05) + facet_wrap(~clusterSig10x,nrow=1, scales="free") + labs(title="Treg P390 Clusters vs. 10X Cluster Signatures",x="cluster",y="mean scaled log expression")
dev.off()

png("../../data/2025-02-10/Tconv_10xClusterSigs_v_P390Clusters.png",width=600,height=500)
ggplot(tconvDf, aes(x=seurat_clusters,y=value)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=0.05) + facet_wrap(~clusterSig10x,nrow=2, scales="free") + labs(title="Tconv P390 Clusters vs. 10X Cluster Signatures",x="cluster",y="mean scaled log expression")
dev.off()

tconvSummary <- reshape2::dcast( tconvDf, seurat_clusters ~ clusterSig10x, value.var="value", fun.aggregate = mean); rownames(tconvSummary ) <- tconvSummary[,1]; tconvSummary  <- tconvSummary[,2:ncol(tconvSummary )]
png("../../data/2025-02-10/Tconv_10xClusterSigs_v_P390Clusters_heatmap.png",width=350,height=320)
Heatmap(tconvSummary,cluster_rows=FALSE,cluster_columns=FALSE,name="mean\nsignature",column_title="Tconv, 10x Signature on P390 Clusters")
dev.off()

tregSummary <- reshape2::dcast( tregDf, seurat_clusters ~ clusterSig10x, value.var="value", fun.aggregate = mean); rownames(tregSummary ) <- tregSummary[,1]; tregSummary  <- tregSummary[,2:ncol(tregSummary )]
png("../../data/2025-02-10/Treg_10xClusterSigs_v_P390Clusters_heatmap.png",width=350,height=320)
Heatmap(tregSummary,cluster_rows=FALSE,cluster_columns=FALSE,name="mean\nsignature",column_title="Treg, 10x Signature on P390 Clusters")
dev.off()

```

```{r 02/19/24 Using TCRGraph to identify clonotypes}
library(tcrGraph)

consistentLibs <- soFiltered$libid
matchcol <- "full_nt_sequence"
matchcol <- "ntDonor"

# Get rid of doublets and cells whose rna phenotype don't match the sort
subTcrs <- tcrs[ tcrs$libid %in% consistentLibs & !tcrs$libid %in% c(iNKTMaitLibids,betaDoublets,alphaTriplets),]
subTcrs$ntDonor <- paste0( subTcrs$full_nt_sequence,"-",subTcrs$donorID)
# Make graph
ntGraph <- makeTcrGraph( subTcrs,link=matchcol )

# Call the clones from the graph
ntCloneDf <- getClonesFromTcrGraph( ntGraph, maxA = 10, maxB = 10, maxD = -1, maxG = -1, format = "compressed", link = matchcol); rownames(ntCloneDf) <- ntCloneDf$cloneId

betaNts <- unique( subTcrs[ subTcrs$chain == "TRB",matchcol])
alphaNts <- unique( subTcrs[ subTcrs$chain == "TRA",matchcol])
summarizeClone <- function( cloneDfRow, matchcol="full_nt_sequence" ){
  numLibs <- length( strsplit( cloneDfRow["libs"],",")[[1]] )
  vgenes <- strsplit( cloneDfRow["vGenes"],"," )
  numAlphaVGenes <- sum( grepl("TRA",vgenes))
  numBetaVGenes <- sum( grepl("TRB",vgenes))

  jgenes <- strsplit( cloneDfRow["jGenes"],"," )
  numAlphaJGenes <- sum( grepl("TRA",jgenes))
  numBetaJGenes <- sum( grepl("TRB",jgenes))

  nts <- gsub(" ","",strsplit( cloneDfRow[matchcol],",")[[1]])
  numANts <- sum(nts %in% alphaNts)
  numBNts <- sum(nts %in% betaNts)
  
  return( c(cloneId=as.character(cloneDfRow["cloneId"]),libCount=numLibs,AVCount=numAlphaVGenes,BVCount=numBetaVGenes,AJCount=numAlphaJGenes,BJCount=numBetaJGenes, aCount=numANts, bCount=numBNts))
}
cloneSummary <- data.frame(t(apply( ntCloneDf, 1, function(r) summarizeClone(r, matchcol=matchcol ))))
cloneSummary$weird <- cloneSummary$aCount > 2 | cloneSummary$bCount > 1
# Print out a table of clonotypes with the alpha and beta count info
print(table(paste0("a:",cloneSummary$aCount), paste0("b:",cloneSummary$bCount)))

### Plot just the anomalous ones
weirdClones <- cloneSummary$cloneId[ cloneSummary$weird]
weirdLibs <- unique( do.call(c,lapply(ntCloneDf[weirdClones,]$libs, function(s) strsplit(s,", ")[[1]])) )
weirdNtGraph <- makeTcrGraph( subTcrs[subTcrs$libid %in% weirdLibs,],link="full_nt_sequence" )
p <- plot(
  weirdNtGraph,
  chainPalette = c("red", "blue", "purple", "magenta"),
  main = "TCR Clones Plot"
)


## now do it for alpha and beta trinities separately'
subTcrs$trinity <- paste( subTcrs$v_gene, subTcrs$junction, subTcrs$j_gene,sep="-")
aGraph <- makeTcrGraph( subTcrs[ subTcrs$chain == "TRA",],link="trinity" )
bGraph <- makeTcrGraph( subTcrs[ subTcrs$chain == "TRB",],link="trinity" )
aCloneDf <- getClonesFromTcrGraph( aGraph, maxA = 10, maxB = 10, maxD = -1, maxG = -1, format = "compressed", link = "trinity"); rownames(aCloneDf) <- aCloneDf$cloneId
bCloneDf <- getClonesFromTcrGraph( bGraph, maxA = 10, maxB = 10, maxD = -1, maxG = -1, format = "compressed", link = "trinity"); rownames(bCloneDf) <- bCloneDf$cloneId

betaNts <- unique( tcrs$trinity[ tcrs$chain == "TRB"])
alphaNts <- unique( tcrs$trinity[ tcrs$chain == "TRA"])
aSummary <- data.frame(t(apply( aCloneDf, 1, function(r) summarizeClone(r,matchcol="trinity") )))
bSummary <- data.frame(t(apply( bCloneDf, 1, function(r) summarizeClone(r,matchcol="trinity") )))






```

```{r 03/25/25 ROAST on pseudobulk cluster analysis}

### TCONVS
soTconvs$donorID <- design[ soTconvs$libid,"donorID"]
soTconvs$group <- paste0(design_qc$donorId, "_", soTconvs$seurat_clusters)
groups <- unique(soTconvs$group)

libsByGroup <- lapply(groups, function(group) soTconvs$libid[ soTconvs$group == group])
names(libsByGroup) <- groups
libsByGroup <- libsByGroup[ sapply(libsByGroup,length) > 0]

bulk_pc_norm <- sapply( libsByGroup, function(libs) rowSums(counts_pc[,c(libs,libs)] )/2 )
bulk_pc_norm <- bulk_pc_norm[ rowMeans(bulk_pc_norm > 0) >= 0.1, ]

bulk_pc_norm <- normalize_counts(bulk_pc_norm,"tmm")
design_bulk <- data.frame( t( sapply( colnames(bulk_pc_norm), function(s) strsplit(s,"_")[[1]]) ) )
colnames(design_bulk) <- c("donorID","cluster")

design_mat <- model.matrix(~0+cluster+donorID,data=design_bulk)
colnames(design_mat) <- gsub("cluster","c",colnames(design_mat))
colnames(design_mat) <- gsub("donorID","",colnames(design_mat))

clusts <- colnames(design_mat)[ grepl("c",colnames(design_mat))]
cont.matrix <- matrix(0,ncol(design_mat),length(clusts))
rownames(cont.matrix) <- colnames(design_mat)
for( i in 1:length(clusts) ){
  clust <- clusts[i]
  cont.matrix[clusts,i] <- -1/(length(clusts)-1)
  cont.matrix[clusts[i],i] <- 1
}
colnames(cont.matrix) <- clusts

#vwts <- voomWithQualityWeights(bulk_pc_norm[ ,rownames(design_mat)], design= design_mat, plot=T, span=0.1)
#saveRDS(vwts,"Tconv5_vwts.RDS")
vwts <- readRDS("Tconv5_vwts.RDS")
vfit <- lmFit(vwts, design = design_mat)
vfit_eb <- eBayes(vfit)
vfit_c <- contrasts.fit(vfit, cont.matrix)
vfit_c_eb <- eBayes(vfit_c)

clustcomps <- lapply( 1:ncol(cont.matrix), function(i) topTable (vfit_c_eb, coef = i, number=Inf, sort.by="P")  )
names(clustcomps) <- colnames(cont.matrix)
for( i in 1:length(clustcomps) ){ 
  clustcomps[[i]]$HGNC.symbol <- ens2hgnc[ rownames(clustcomps[[i]])]
  clustcomps[[i]]$cluster <- names(clustcomps)[i]
  clustcomps[[i]]$Ensemble.ID <- rownames(clustcomps[[i]])

}
lapply(clustcomps, function(l) table( l$adj.P.Val <= 0.05))

library(msigdbr)
h = data.frame( msigdbr(species = "Homo sapiens", category = "H") )
hallmark <- unique(h$gs_name)
hallmark_list <- lapply(hallmark, function(hname) h$human_gene_symbol[ h$gs_name == hname])
names(hallmark_list) <- hallmark
tconv5ClusterRoast_h <- lapply( colnames(cont.matrix), function(comp) roast(
      y=vwts,
      index=ids2indices(hallmark_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,comp],
      nrot = 8000) )
names(tconv5ClusterRoast_h) <- colnames(cont.matrix)
lapply(tconv5ClusterRoast_h, function(l) head(l[l$Direction == "Up" & l$FDR <= 0.05,]))

sigs <- unique( do.call(c, lapply(tconv5ClusterRoast_h, function(l) rownames(l)[ l$FDR <= 0.05 & l$Direction == "Up"] ) ) )
getRoastDotplot <- function(roasts){
  sigs <- unique( do.call(c, lapply(roasts, function(l) rownames(l)[ l$FDR <= 0.05 & l$Direction == "Up"] ) ) )
  comps <- names(roasts)
  for( i in 1:length(roasts) ){
    roasts[[i]] <- roasts[[i]][sigs,]
    roasts[[i]]$cluster <- names(roasts)[i]
    roasts[[i]]$NGenesChanged <- roasts[[i]]$NGenes*apply(roasts[[i]][,c("PropDown","PropUp")],1,max)
    roasts[[i]]$geneset <- gsub("HALLMARK_","",rownames(roasts[[i]]))
  }
  df <- do.call(rbind,roasts)
}
df <- getRoastDotplot( tconv5ClusterRoast_h)

### Do Kegg
keggs = data.frame( msigdbr(species = "Homo sapiens",  category = "C2", subcategory = "CP:KEGG") )
hallmark <- unique(keggs$gs_name)
hallmark_list <- lapply(hallmark, function(hname) keggs$human_gene_symbol[ keggs$gs_name == hname])
names(hallmark_list) <- hallmark
tconv5ClusterRoast_kegg <- lapply( colnames(cont.matrix), function(comp) roast(
      y=vwts,
      index=ids2indices(hallmark_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,comp],
      nrot = 8000) )
names(tconv5ClusterRoast_kegg) <- colnames(cont.matrix)
lapply(tconv5ClusterRoast_kegg, function(l) head(l[l$Direction == "Up" & l$FDR <= 0.05,]))
sigs <- unique( do.call(c, lapply(tconv5ClusterRoast_kegg, function(l) rownames(l)[ l$FDR <= 0.00001 & l$Direction == "Up"] ) ) )

### Is this true??
hallmark_enslist <- lapply( hallmark_list, function(gs) names(ens2hgnc)[ ens2hgnc %in% gs & names(ens2hgnc) %in% rownames(counts_pc_norm)])
hallmarkExp <- sapply(hallmark_enslist, function(ens) rowMeans(scale(t(log2(1+counts_pc_norm[ens,soTconvs$libid]))), na.rm=TRUE))
md <- soTconvs@meta.data
md <- cbind(md,hallmarkExp[soTconvs$libid,])
ggplot(md, aes(x=seurat_clusters,y=HALLMARK_INTERFERON_ALPHA_RESPONSE)) + geom_boxplot(outlier.color=NA)+ geom_quasirandom(size=0.2) + labs(y="mean scaled log expression",title="5 Tconv Clusters\nHallmark Interferon Alpha Response")

# Find a good order for the x-axis
# Order the features so they're cluster
df <- getRoastDotplot( tconv5ClusterRoast_h)
df <- df[order(df$PValue),]
top50 <- df[!duplicated(df$geneset),"geneset"][1:50]
df <- df[df$geneset %in% top50,]
df$geneset <- tolower( gsub("KEGG ","",gsub("_"," ",df$geneset) ) )
wideFDR <- reshape2::dcast( df, cluster ~ geneset, value.var="FDR")
wideFDR <- wideFDR[,2:ncol(wideFDR)]; wideFDR <- -log10(wideFDR)
wideDIR <- reshape2::dcast( df, cluster ~ geneset, value.var="Direction"); wideDIR <- wideDIR[,2:ncol(wideDIR)];
wideFDR <- wideFDR*ifelse(wideDIR == "Up",1,-1)
dist_matrix <- dist(t(wideFDR))
# Perform hierarchical clustering
hc <- hclust(dist_matrix)
# Get the order of columns based on hierarchical clustering
column_order <- hc$order
setnames <- names(dist_matrix)[column_order]
df$geneset <- factor(df$geneset, levels=setnames)
#pdf("../../data/2025-02-10/PaperFigures/Tconv5_Hallmark_Roast_Dotplot.pdf",width=9,height=11)
png("../../data/2025-02-10/PaperFigures/Tconv5_Hallmark_Roast_Dotplot.png",width=600,height=1000)
ggplot( df, aes(x=cluster,y=geneset,size=NGenesChanged,color=ifelse(Direction=="Up",-1,1)*log10(FDR))) + geom_point() + labs(color="sign\nand\nlog10(FDR)",title="Tconv 5 Clusters\nTop 50 Hallmark Pathways") + scale_color_gradient2( name = waiver(),high = "red",mid = "grey",low = "blue",midpoint = 0,space = "Lab",na.value = "grey50",transform = "identity",guide = "colourbar",aesthetics = "color" ) 
dev.off()





### Tregs
soTregs$donorID <- design[ soTregs$libid,"donorID"]
soTregs$group <- paste0(design_qc$donorId, "_", soTregs$seurat_clusters)
groups <- unique(soTregs$group)

libsByGroup <- lapply(groups, function(group) soTregs$libid[ soTregs$group == group])
names(libsByGroup) <- groups
libsByGroup <- libsByGroup[ sapply(libsByGroup,length) > 0]

bulk_pc_norm <- sapply( libsByGroup, function(libs) rowSums(counts_pc[,c(libs,libs)] )/2 )
bulk_pc_norm <- bulk_pc_norm[ rowMeans(bulk_pc_norm > 0) >= 0.1, ]

bulk_pc_norm <- normalize_counts(bulk_pc_norm,"tmm")
design_bulk <- data.frame( t( sapply( colnames(bulk_pc_norm), function(s) strsplit(s,"_")[[1]]) ) )
colnames(design_bulk) <- c("donorID","cluster")

design_mat <- model.matrix(~0+cluster+donorID,data=design_bulk)
colnames(design_mat) <- gsub("cluster","c",colnames(design_mat))
colnames(design_mat) <- gsub("donorID","",colnames(design_mat))

clusts <- colnames(design_mat)[ grepl("c",colnames(design_mat))]
cont.matrix <- matrix(0,ncol(design_mat),length(clusts))
rownames(cont.matrix) <- colnames(design_mat)
for( i in 1:length(clusts) ){
  clust <- clusts[i]
  cont.matrix[clusts,i] <- -1/(length(clusts)-1)
  cont.matrix[clusts[i],i] <- 1
}
colnames(cont.matrix) <- clusts

vwts <- voomWithQualityWeights(bulk_pc_norm[ ,rownames(design_mat)], design= design_mat, plot=T, span=0.1)
saveRDS(vwts,"Treg3_vwts.RDS")
#vwts <- readRDS("Tconv5_vwts.RDS")
vfit <- lmFit(vwts, design = design_mat)
vfit_eb <- eBayes(vfit)
vfit_c <- contrasts.fit(vfit, cont.matrix)
vfit_c_eb <- eBayes(vfit_c)

clustcomps <- lapply( 1:ncol(cont.matrix), function(i) topTable (vfit_c_eb, coef = i, number=Inf, sort.by="P")  )
names(clustcomps) <- colnames(cont.matrix)
for( i in 1:length(clustcomps) ){ 
  clustcomps[[i]]$HGNC.symbol <- ens2hgnc[ rownames(clustcomps[[i]])]
  clustcomps[[i]]$cluster <- names(clustcomps)[i]
  clustcomps[[i]]$Ensemble.ID <- rownames(clustcomps[[i]])

}
lapply(clustcomps, function(l) table( l$adj.P.Val <= 0.05))

# KEGG
hallmark <- unique(keggs$gs_name)
hallmark_list <- lapply(hallmark, function(hname) keggs$human_gene_symbol[ keggs$gs_name == hname])
names(hallmark_list) <- hallmark
tregs3ClusterRoast_kegg <- lapply( colnames(cont.matrix), function(comp) roast(
      y=vwts,
      index=ids2indices(hallmark_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,comp],
      nrot = 8000) )
names(tregs3ClusterRoast_kegg) <- colnames(cont.matrix)
lapply(tregs3ClusterRoast_kegg, function(l) head(l[l$Direction == "Up" & l$FDR <= 0.05,]))
sigs <- unique( do.call(c, lapply(tregs3ClusterRoast_kegg, function(l) rownames(l)[ l$FDR <= 0.00001 & l$Direction == "Up"] ) ) )

# HALLMARK
hallmark <- unique(h$gs_name)
hallmark_list <- lapply(hallmark, function(hname) h$human_gene_symbol[ h$gs_name == hname])
names(hallmark_list) <- hallmark
tregs3ClusterRoast_h <- lapply( colnames(cont.matrix), function(comp) roast(
      y=vwts,
      index=ids2indices(hallmark_list, identifiers=gene_key$HGNC.symbol[match(rownames(vwts), gene_key$Ensembl.Gene.ID)]),
      design=design_mat,
      contrast= cont.matrix[,comp],
      nrot = 8000) )
names(tregs3ClusterRoast_h) <- colnames(cont.matrix)
lapply(tregs3ClusterRoast_h, function(l) head(l[l$Direction == "Up" & l$FDR <= 0.05,]))
sigs <- unique( do.call(c, lapply(tregs3ClusterRoast_h, function(l) rownames(l)[ l$FDR <= 0.00001 & l$Direction == "Up"] ) ) )


# Find a good order for the x-axis
# Order the features so they're cluster
df <- getRoastDotplot( tregs3ClusterRoast_kegg)
df <- df[order(df$PValue),]
top50 <- df[!duplicated(df$geneset),"geneset"][1:50]
df <- df[df$geneset %in% top50,]
df$geneset <- tolower( gsub("HALLMARK_","",gsub("KEGG ","",gsub("_"," ",df$geneset) ) ) )
wideFDR <- reshape2::dcast( df, cluster ~ geneset, value.var="FDR")
wideFDR <- wideFDR[,2:ncol(wideFDR)]; wideFDR <- -log10(wideFDR)
wideDIR <- reshape2::dcast( df, cluster ~ geneset, value.var="Direction"); wideDIR <- wideDIR[,2:ncol(wideDIR)];
wideFDR <- wideFDR*ifelse(wideDIR == "Up",1,-1)
dist_matrix <- dist(t(wideFDR))
# Perform hierarchical clustering
hc <- hclust(dist_matrix)
# Get the order of columns based on hierarchical clustering
column_order <- hc$order
setnames <- names(dist_matrix)[column_order]
df$geneset <- factor(df$geneset, levels=setnames)
#pdf("../../data/2025-02-10/PaperFigures/Tconv5_Hallmark_Roast_Dotplot.pdf",width=9,height=11)
png("../../data/2025-02-10/PaperFigures/Treg3_Kegg_Roast_Dotplot.png",width=700,height=1000)
ggplot( df, aes(x=cluster,y=geneset,size=NGenesChanged,color=ifelse(Direction=="Up",-1,1)*log10(FDR))) + geom_point() + labs(color="sign\nand\nlog10(FDR)",title="Treg 3 Clusters\nTop 50 Kegg Pathways") + scale_color_gradient2( name = waiver(),high = "red",mid = "grey",low = "blue",midpoint = 0,space = "Lab",na.value = "grey50",transform = "identity",guide = "colourbar",aesthetics = "color" ) 
dev.off()

```

```{r 04/10/25 Treg vs. Tconv Proliferation}
### Is this true??
hallmark_enslist <- lapply( hallmark_list, function(gs) names(ens2hgnc)[ ens2hgnc %in% gs & names(ens2hgnc) %in% rownames(counts_pc_norm)])
hallmarkExp <- sapply(hallmark_enslist, function(ens) rowMeans(scale(t(log2(1+counts_pc_norm[ens,combinedDf$libid]))), na.rm=TRUE))
combinedDf[,colnames(hallmarkExp)] <- hallmarkExp

combinedDf$cluster <- gsub("_Treg","_",gsub("_Tconv","_",combinedDf$cluster))
for( gset in c("HALLMARK_MYC_TARGETS_V1","HALLMARK_MYC_TARGETS_V2","HALLMARK_E2F_TARGETS","HALLMARK_G2M_CHECKPOINT") ){
  print(gset)
  combinedDf$gset <- combinedDf[,gset]
  p <- ggplot(combinedDf, aes(x=gsub("_","\n",cluster),y=gset)) + geom_boxplot(outlier.color=NA)+ geom_quasirandom(size=0.2) + labs(y="mean scaled log expression",title=paste0("Treg+Tconv Clusters\n",gsub("_"," ",gsub("HALLMARK_","",gset))),x="cluster")
  png( paste0("../../data/2025-04-10/",gset,"_boxplot.png"),width=500,height=400 )
  print(p)
  dev.off()
}

h <- gsub("HALLMARK ","",gsub("_"," ",names(hallmark_enslist)))

```

```{r 04/15/25 TCR analysis and other stuff}
# Email from Karen 04/14/25

# 1 How many TCRs for Treg and Tconv cells were used for analysis? From the upset plot I count 82 expanded Treg TCR pairs and 90 Tconv TCR pairs, is this correct?
## get expanded pairs
pairs$donorID <- design[ pairs$sample, "donorID"]
pairs$pairDonor <- paste( pairs$CDR3ant, pairs$CDR3bnt, pairs$donorID )
pairs$pair <- paste( pairs$CDR3ant, pairs$CDR3bnt )
subpairs <- pairs[ pairs$sample %in% soFiltered$libid,]
z <- subpairs[duplicated(subpairs$pairDonor),]
expandedPairs <- unique(z$pairDonor)
z$expanded <- z$pairDonor %in% expandedPairs
a <- z[!duplicated(z$pairDonor),]

## Two ways to count
## way 1
so <- soTregs
subpairs <- pairs[ pairs$sample %in% so$libid,]
subpairs$pairnt <- paste( subpairs$CDR3ant, subpairs$CDR3bnt, subpairs$donorID) # Combine cdr3 a and b nucleotide sequences
subpairs$cluster <- so@meta.data[ subpairs$sample, clusterCol ]
expandedPairs <- subpairs[ subpairs$pairnt %in% subpairs$pairnt[duplicated(subpairs$pairnt)],]

# 2 For 10X we compared TCR pair nucleotide sequences and defined clonally expanded cells as those that share TCR pairs. For P390 we start with clonal expansion/sharing based on TRA and TRB chains. I think we need to show a circos plot of expanded/shared pairs for Treg and Tconv before we delve into chains to harmonize TCR analysis of P589 andP390. Could you please make a circos plot of clonal expansion/sharing based on TCR pairs that is colored by Treg and Tconv in the outer ring?

# 3 TRA chain sharing between Treg and Tconv cells- how many TRA chains were shared between Treg and Tconv cells in the circos plot? Where these TRA chains paired with different TRB chains or were they from cells that only had TRA chain sequences recovered? Were these Treg-Tconv shared TRA chains within a subject and how many subjects?  
subalphas <- tcrs[ tcrs$libid %in% soFiltered$libid & tcrs$chain == "TRA",]
subbetas <- tcrs[ tcrs$libid %in% soFiltered$libid & tcrs$chain == "TRB",]
interTypeAlphas <- unique( intersect( subalphas$full_nt_sequence[ subalphas$CD4Type == "Treg"], subalphas$full_nt_sequence[ subalphas$CD4Type == "Tconventional"] ) )
interTypeBetas <- unique( intersect( subbetas$full_nt_sequence[ subbetas$CD4Type == "Treg"], subbetas$full_nt_sequence[ subbetas$CD4Type == "Tconventional"] ) )
interTypePairs <- pairs[ pairs$sample %in% soFiltered$libid,]
interTypePairs <- unique(intersect( interTypePairs$CDR3pair[ interTypePairs$CD4Type == "Treg"],interTypePairs$CDR3pair[ interTypePairs$CD4Type == "Tconv"]))

subdf <- subalphas[subalphas$full_nt_sequence %in% interTypeAlphas,]
table(subdf$donorID, subdf$CD4Type,as.numeric(as.factor(subdf$full_nt_sequence)))

## Expansion by cluster
# 4 Can you please determine if there is any difference in clonal expansion between T1D and HC by Seurat cluster for Tregs and Tconv cells?
## 2025-02-04 Proportion Expanded Plots
pairs$donorID <- design[pairs$sample,"donorID"]
pairs$pairDonor <- paste0( pairs$pair,"_",pairs$donorID)
expandedPairDonors <- unique(pairs$pairDonor[duplicated(pairs$pairDonor)])
pairs$expanded <- pairs$pairDonor %in% expandedPairDonors
pairs <- pairs[ order(!pairs$expanded),]
samples <- pairs[ !duplicated(pairs$sample),]
samples$CD4Type <- ifelse( design_qc[ samples$sample,"CD4Type"] == "Treg","Treg","Tconv")
samples$studyGroup <- design_qc[ samples$sample,"studyGroup"]
samples$cluster <- gsub("_Tconv","_",gsub("_Treg","_",combinedDf[samples$sample,"cluster"]))
samples <- samples[!is.na(samples$cluster),]

isExpanded <- function(pairs){
  expandedPairs <- unique( pairs$pairDonor[ duplicated(pairs$pairDonor)] )
  return( pairs$pairDonor %in% expandedPairs )
}

expanded <- samples[samples$expanded,]
propExpanded <- data.frame( table(expanded$donorID,expanded$cluster)); colnames(propExpanded) <- c("donorID","cluster","count") 
propExpanded$CD4Type <- sapply( as.character(propExpanded$cluster), function(s) strsplit(s,"_")[[1]][1])
propExpanded$proportion <- propExpanded$count/table( paste(expanded$donorID, expanded$CD4Type) )[ paste( propExpanded$donorID,propExpanded$CD4Type)]
propExpanded$studyGroup <- designByDonor[ propExpanded$donorID,"studyGroup"]
propExpanded$groupType <- paste0( propExpanded$studyGroup, "\n",ifelse(propExpanded$CD4Type == "Treg","Treg","Tconv") )
png("../../data/2025-04-10/PropExpandedByCluster1.png",width=700,height=500)
ggplot( propExpanded, aes(x=studyGroup,y=proportion)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=1) + scale_color_manual( values=sortCols) + guides(color="none") + labs(x="",title="Expanded cells, proportion by cluster by Donor\nT1D vs. HC p-values") + facet_wrap(~cluster,nrow=2) 
dev.off()

propExpanded$logit <- logitTransform( propExpanded$proportion)
expandedModel <- lm( logit ~ cluster*studyGroup, data=propExpanded)
## t.test
pvals <- sapply( c("Tconv","Treg"), function(celltype) propExpanded %>% filter(CD4Type == celltype) %>% t.test(logit ~ studyGroup, data = .) %>% .$p.value )
propExpanded$anno <- paste0( propExpanded$CD4Type,"\np-value: ",signif(pvals[propExpanded$CD4Type],3))
# pdf("../../data/2025-02-10/PaperFigures/T1DvHC_propExpanded_byType.pdf",width=6,height=6)
ggplot( propExpanded, aes(x=studyGroup,y=proportion, color=CD4Type)) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=1) + scale_color_manual( values=sortCols) + guides(color="none") + labs(x="",title="Proportion Expanded by Donor\nT1D vs. HC p-values") + facet_wrap(~anno) 
# dev.off()

# Alex:
# Figure S4H, S4I report the FDR cutoff and % cells with gene expression for these heatmaps

# Figure 5B New circos plots for Treg and Tconv individually comparing expansion and sharing between HC and T1D for each cell type adn chain(TRA and TRB separately like 5A)


# Figure 6A UMAP plot of Tregs with cells highlighted that express the TCR pair TRAV35_CAGPGTSGGSYIPTF_TRAJ6 | TRBV7-8_CASSLAPLGGSSGNTIYF_TRBJ1-3 (all other cells colored by cluster but not highlighted)
libsToHighlight <- pairs$sample[ pairs$CDR3a == "CAGPGTSGGSYIPTF" & pairs$CDR3b == "CASSLAPLGGSSGNTIYF"]
soDf <- data.frame( Embeddings(soTregss, reduction = "umap") )
soDf$anno <- ifelse( soDf$libid %in% libsToHighlight, "CAGPGTSGGSYIPTF\nCASSLAPLGGSSGNTIYF", "other")
clustercols <- gg_color_hue(length(unique(soDf$seurat_clusters)))
pdf("../../data/2025-04-10/UMAP_CAGPGTSGGSYIPTF-CASSLAPLGGSSGNTIYF.pdf",width=7.8,height=4)
ggplot( soDf, aes(x=umap_1,y=umap_2,color=seurat_clusters,size=soDf$anno)) + geom_point() + scale_size_manual( values=c("other"=0.1, "CAGPGTSGGSYIPTF\nCASSLAPLGGSSGNTIYF" = 4 )) + labs(x="UMAP 1",y="UMAP 2",color="cluster",size="") 
dev.off()

### Cell typist
tp <- counts_pc_filtered
rownames(tp) <- ens2hgnc[rownames(tp)]
write.table( tp,"../../../P338_TN10/data/2024-09-05/P390_counts_pc_filtered.csv",quote=FALSE,sep=",",col.names=NA)
predictions <- read.table("../../../P338_TN10/data/2024-09-05/P390_AllenAIFIL3predicted_labels.csv",header=TRUE,sep=","); rownames(predictions) <- predictions[,1]
predictions$CD4 <- predictions$predicted_labels; predictions$CD4[ !( grepl("CD4",predictions$predicted_labels) | grepl("Treg", predictions$predicted_labels) | grepl("T cell", predictions$predicted_labels))] <- "Other"


combinedDf$cellTypist <- predictions[combinedDf$libid, "CD4"]

if(TRUE){
  soDf <- data.frame( Embeddings(soTconvs, reduction = "umap") )
  soDf <- cbind( soDf[soTconvs$libid,], soTconvs@meta.data)
} else{
  soDf <- data.frame( Embeddings(soTregs, reduction = "umap") )
  soDf <- cbind( soDf[soTregs$libid,], soTregs@meta.data)
}
soDf$cellTypist <- predictions[soDf$libid, "CD4"]
ggplot( soDf, aes(x=umap_1,y=umap_2,color=cellTypist)) + geom_point() + facet_wrap(~ifelse(cellTypist!="Other","T-cell","Other"))

```

```{r 04/16/25 Reference Mapping to 10X P589}

library(Seurat)
tconvP589 <- readRDS("~/Library/CloudStorage/Box-Box/P390_Treg_Tconv/data/2025-06-10/P589-1_autoreactive_CD4_Tcell_10X.2025-06-13_seuratTconv.rds")
tregP589 <- readRDS("~/Library/CloudStorage/Box-Box/P390_Treg_Tconv/data/2025-06-10/P589-1_autoreactive_CD4_Tcell_10X.2025-06-13_seuratTreg.rds")

# Step 2: Find anchors between the two datasets
anchors <- FindTransferAnchors(
  reference = tregP589,  # Reference dataset
  query = soTregs,         # Query dataset
  dims = 1:10              # Use the first 30 dimensions (adjust as needed)
)
tregP589$seurat_clusters_10x <- tregP589$seurat_clusters
# Step 3: Transfer cluster labels from seuratTreg to soTregs
soTregsLabels <- TransferData(
  anchorset = anchors,
  refdata = tregP589$seurat_clusters_10x,  # Cluster labels from seuratTreg
  dims = 1:10                            # Use the same dimensions as above
)
soTregs@meta.data[,"clusters_10x"] <- soTregsLabels[soTregs$libid,"predicted.id"]
# pdf("../../data/2025-06-10/Treg_P39010xLabelTransfer_UMAP.pdf",width=4.5,height=4)
png("../../data/2025-06-10/Treg_P39010xLabelTransfer_UMAP.png",width=400,height=370)

DimPlot(soTregs, label = FALSE, repel = TRUE, group.by = "clusters_10x") + labs(title="P390 Tregs\n10X Cluster Annotation",color="10x\ncluster")
dev.off()

# Step 2: Find anchors between the two datasets
anchors <- FindTransferAnchors(
  reference = tconvP589,  # Reference dataset
  query = soTconvs,         # Query dataset
  dims = 1:10              # Use the first 30 dimensions (adjust as needed)
)
tconvP589$seurat_clusters_10x <- tconvP589$seurat_clusters
# Step 3: Transfer cluster labels from seuratTreg to soTregs
soTconvLabels <- TransferData(
  anchorset = anchors,
  refdata = tconvP589$seurat_clusters_10x,  # Cluster labels from seuratTreg
  dims = 1:10                            # Use the same dimensions as above
)
soTconvs@meta.data[,"clusters_10x"] <- soTconvLabels[soTconvs$libid,"predicted.id"]
# pdf("../../data/2025-06-10/Tconv_P39010xLabelTransfer_UMAP.pdf",width=4.5,height=4)
png("../../data/2025-06-10/Tconv_P39010xLabelTransfer_UMAP.png",width=400,height=370)
DimPlot(soTconvs, label = FALSE, repel = TRUE, group.by = "clusters_10x") + labs(title="P390 Tconvs\n10X Cluster Annotation",color="10x\ncluster")
dev.off()
```

```{r 05/12/25 TCRDist analysis}
library(igraph)
library(msa)
combo <- readRDS("combo.RDS")
library(igraph)

nt2aa <- tcrs[!duplicated(tcrs$full_nt_sequence),"junction"]; names(nt2aa) <- tcrs[!duplicated(tcrs$full_nt_sequence),"full_nt_sequence"]
## If there are multiple nucleotide sequences that can generate the same amino acid sequence,
## collapse them in the matrix to just the aa sequence, and use the minimum TCRdistance that you find. 
combineDupsMinDist <- function(mat){
  #mat <- alphaDistmat
  mat <- mat[!grepl("\\.",colnames(mat)),!grepl("\\.",colnames(mat))]
  rownames(mat) <- colnames(mat)
  cnames <-colnames(mat); cnames <- cnames[cnames %in% names(nt2aa)]
  mat <- mat[cnames,cnames]
  cnames <- nt2aa[cnames]
  dupcols <- unique( cnames[duplicated(cnames)] )
  for( dc in dupcols ){
    i <- which(cnames == dc)
    r <- mat[ i, ]
    m <- apply(r,2,min)
    mini <- min(i)
    mat[mini,] <- m; mat[,mini] <- m
  }
  mat <- mat[!duplicated(cnames),!duplicated(cnames)]
  rownames(mat) <- cnames[!duplicated(cnames)]; colnames(mat) <- rownames(mat)
  return(mat)
}

alphaDistmat <- read.table("../../data/2025-08-07/P390_nt_alphaMat.csv", header=TRUE,sep=",")
alphaDistmat <- combineDupsMinDist( alphaDistmat)
betaDistmat <- read.table("../../data/2025-08-07/P390_nt_betaMat.csv", header=TRUE,sep=",") 
betaDistmat <- combineDupsMinDist( betaDistmat)
## Turn the distance matrices into a graph adjacency matrix
pruneDmat <- function(dmat,thresh,removeSingletons=TRUE){
  dmat <- ifelse( dmat <= thresh, 1, 0)
  diag(dmat) <- 0
  if(removeSingletons){
    table(rowSums(dmat)>0)
    rows <- rowSums(dmat)>0
  }
  else{
    rows <- rownames(dmat)
  }
  return(dmat[rows,rows])
}
threshes <- seq(12,24,2)
threshes <- c(threshes,48)
betaDistmats <- lapply( threshes, function(thresh) pruneDmat( betaDistmat, thresh ) ); names(betaDistmats) <- as.character(threshes)
alphaDistmats <- lapply( threshes, function(thresh) pruneDmat( alphaDistmat, thresh ) ); names(alphaDistmats) <- as.character(threshes)


#### count donors per junction
pasteCollapse <- function(s){
  s <- s[order(s)]
  paste( s[!duplicated(s)], collapse=",")
}
donorsByAlpha <- aggregate( combo$subject,by=list(combo$cdr3_a_aa),FUN=pasteCollapse)
donorsByBeta <- aggregate( combo$subject,by=list(combo$cdr3_b_aa),FUN=pasteCollapse);
donorsByJunction <- rbind(donorsByAlpha, donorsByBeta)
colnames(donorsByJunction) <- c("junction","subject")
rownames(donorsByJunction) <- donorsByJunction$junction
junctionDonorTab <- rbind(table(combo$cdr3_a_aa, combo$subject),table(combo$cdr3_b_aa, combo$subject))

## Network Plots
junctionTable <- table(tcrs$junction[tcrs$libid %in% combinedDf$libid])

########
### Generate igraph
thresh <- "24"
chain <- "Alpha"
print(thresh)

if( chain == "Beta" ){
  junctions <- unique(combo$cdr3_b_aa)
  bDmat <- betaDistmats[[thresh]]
  junctions <- junctions[ junctions %in% rownames(bDmat)]
# Only use junctions that are connected to other ones
  junctions <- junctions[ rowSums(bDmat[junctions,junctions])>0]
  bDmat <- bDmat[junctions,junctions]
} else{
  junctions <- unique(combo$cdr3_a_aa)
  bDmat <- alphaDistmats[[thresh]]
  junctions <- junctions[ junctions %in% rownames(bDmat)]
# Only use junctions that are connected to other ones
  junctions <- junctions[ rowSums(bDmat[junctions,junctions])>0]
  bDmat <- bDmat[junctions,junctions]
}
vertexCols <-gg_color_hue( ncol( junctionDonorTab) ); names( vertexCols) <- colnames(junctionDonorTab)

bgraph <- graph_from_adjacency_matrix(
  bDmat[junctions,junctions],
  mode = c("max"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NA
)

bcomps <- igraph::components( bgraph )$membership
# Only show components with more than 2 members
if(TRUE){
  comptab <- table(bcomps)
  comps <- names(comptab)[ comptab > 4 ]
  junctions <- names(bcomps)[bcomps %in% comps]
  bgraph <- graph_from_adjacency_matrix(
  bDmat[junctions,junctions],
  mode = c("max"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NA)
  bcomps <- igraph::components( bgraph )$membership
}
toShow <- junctions[!duplicated(bcomps[junctions])]
labels <- ifelse( junctions %in% toShow, bcomps[junctions], "")

piecols <- lapply( junctions, function(j) junctionDonorTab[j,] )

#p <- plot(bgraph, vertex.size=3, vertex.label="",main="Beta Junctions\nTCRDist Threshold: 12")
#p <- 
#plot(bgraph, vertex.size=junctionTable[junctions]+4, vertex.label=labels,main= paste0(chain," Junctions\nTCRDist Threshold: ",thresh,"\nMultiple Epitopes"), vertex.color=vcols,vertex.label.dist=2 )
plotdir <- "../../data/2025-08-07"
#png( paste0(plotdir,"/TCRDistIgraph_",chain,"_",thresh,".png"), width=500,height=500 )
pdf( paste0(plotdir,"/TCRDistIgraph_",chain,"_",thresh,".pdf"), width=5,height=5 )
p <- plot(bgraph, vertex.size=junctionTable[junctions]+4, vertex.label=labels,main= paste0(chain," Junctions\nTCRDist Threshold: ",thresh,"\nMultiple Epitopes"), vertex.pie.color= list(vertexCols), vertex.pie = piecols, vertex.label.dist=2, vertex.shape="pie" )
print(p)
dev.off()
#legend("topleft",legend=names(vertexCols),col=vertexCols, pch=19)

### Plot top 2 components
comps <- bcomps
comptab <- table( comps ); comptab <- comptab[rev(order(comptab))]
vcols <- c("Tconventional"="red","Treg"="blue","Tconventional,Treg"="purple")
# for( comp in names(comptab)[1:2] ){
#for( comp in pvalDf$component[ pvalDf$adj.P.Val <= 0.2] ){
for( comp in c("9","11")){
  junctions <- names(comps)[ comps == comp]
  print(comp)
  bgraph <- graph_from_adjacency_matrix(
  bDmat[junctions,junctions],
  mode = c("max"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NA)
  
  piecols <- lapply( junctions, function(j) junctionDonorTab[j,] )

  
  plotdir <- "../../data/2025-08-07/"
  # png( paste0(plotdir,chain,"Igraph",thresh,"_component",comp,suffix,".png"),width=800,height=800)
  # png( paste0(plotdir,chain,"Igraph",thresh,"_component",comp,suffix,"_TregTconvColor.png"),width=800,height=800)
  pdf( paste0(plotdir,chain,"Igraph",thresh,"_component",comp,suffix,"_TregTconvColor.pdf"),width=5,height=5)

  #p <- plot(bgraph, vertex.size=3, vertex.label="",main="Beta Junctions\nTCRDist Threshold: 12")
  #p <- plot(bgraph, vertex.size=junctionTable[junctions]+5,main= paste0(chain," Junctions, component ",comp,"\nTCRDist Threshold: ",thresh), vertex.pie.color= list(vertexCols), vertex.pie = piecols,vertex.label.dist=2,vertex.shape="pie" )
  # p <- plot(bgraph, vertex.size=junctionTable[junctions]+5,main= paste0(chain," Junctions, component ",comp,"\nTCRDist Threshold: ",thresh), vertex.pie.color= list(vertexCols), vertex.color = vcols[ junctionTypes[junctions] ] ,vertex.label.dist=2 )
  p <- plot(bgraph, vertex.size=junctionTable[junctions]+5,main= paste0(chain," Junctions, component ",comp,"\nTCRDist Threshold: ",thresh), vertex.color = vcols[ junctionTypes[junctions] ] ,vertex.label.dist=2 )
  print(p)
  dev.off()
  
  alignedJunctions <- msa( junctions,type="protein")
  logoplot <- ggseqlogo( data = as.character(alignedJunctions) ) + labs(title=paste0(length(junctions), " ", chain," chains"))
  png( paste0(plotdir,chain,"Logo",thresh,"_component",comp,suffix,".png"),width=500,height=200)
  print(logoplot)
  dev.off()

}

### Count how many cells in each project exist in each component
comps <- unique( bcomps )
complist <- lapply(comps, function(comp) names(bcomps)[ bcomps == comp] ); names(complist) <- comps
tcrs$donorTypeGroup <- paste( tcrs$donorID, tcrs$CD4Type, tcrs$studyGroup, sep="_")
projects <- unique(tcrs$donorTypeGroup)
subTcrs <- tcrs[ tcrs$libid %in% combinedDf$libid,]
componentProjectCount <- sapply(projects, function(project) sapply(complist, function(clist) sum(subTcrs$donorTypeGroup == project & subTcrs$junction %in% clist)  ))
d <- data.frame(t(sapply(colnames(componentProjectCount), function(s) strsplit(s,"_")[[1]])))
colnames(d) <- c("donorID","CD4Type","studyGroup")
d <- d[order(d$CD4Type, d$studyGroup),]
d$sortGroup <- paste0(d$CD4Type, ", ", d$studyGroup)
t1dcols <- c("Control"="lightblue","T1D"="orange")
sortcols <- c("Treg"="blue","Tconv"="red","Tconventional"="red")

# pdf( paste0("../../data/2025-08-07/P390",chain,"MetacloneHeatmap.pdf"),width=5, height=5.5)
png( paste0("../../data/2025-08-07/P390",chain,"MetacloneHeatmap.png"),width=450, height=500)
ha <- HeatmapAnnotation(df=d[,c("CD4Type","studyGroup")], col=list(studyGroup=t1dcols,CD4Type=sortcols))
Heatmap(componentProjectCount[,rownames(d)],show_row_names=TRUE,show_column_names=FALSE,top_annotation=ha,name="cell count", column_title=paste0("Counts of Cells in each\n",chain," Metaclonotype"), cluster_columns=FALSE,show_row_dend=FALSE)
dev.off()
```

```{r 05/14/25 Permuting treg/tconv labels to compare component occupancy by Treg/Tconv}
subTcrs <- tcrs[tcrs$libid %in% combinedDf$libid,]
junctionTypeDf <- aggregate( subTcrs$CD4Type,by=list(subTcrs$junction),FUN=pasteCollapse)
junctionTypes <- junctionTypeDf$x; names(junctionTypes) <- junctionTypeDf$Group.1
donorTypeJunctionTab <- table( paste0(subTcrs$donorID,"_",subTcrs$CD4Type,"_",subTcrs$junction,"_",subTcrs$studyGroup))
tcrCountDf <- data.frame( t(sapply( names(donorTypeJunctionTab ), function(s) strsplit(s,"_")[[1]] ))); colnames(tcrCountDf) <- c("donorID","CD4Type","junction","studyGroup")
tcrCountDf$count <- donorTypeJunctionTab
tcrCountDf$component <- bcomps[tcrCountDf$junction]; tcrCountDf$component[is.na(tcrCountDf$component)] <- 'other'
# Filter out components that don't have at least 6 projects contributing
clonDonorTab <- table( tcrCountDf$component[!duplicated(paste(tcrCountDf$donorID,tcrCountDf$CD4Type,tcrCountDf$component))])
toTest <- names(clonDonorTab)[clonDonorTab >= 10]

# tcrCountDf <- tcrCountDf[!is.na(tcrCountDf$component),]

compCountDf <- tcrCountDf[!duplicated( paste(tcrCountDf$donorID,tcrCountDf$CD4Type,tcrCountDf$junction)),]
compCountDf$count <- table( paste(tcrCountDf$donorID,tcrCountDf$CD4Type,tcrCountDf$junction) )[ paste(compCountDf$donorID,compCountDf$CD4Type,compCountDf$junction) ]

toTest <- toTest[toTest != "other"]
comps <- unique(compCountDf$component)
fisherPvals <- sapply(toTest, function(comp) fisher.test( table(compCountDf$component == comp, compCountDf$CD4Type))$p.value )
fisherPvals <- data.frame(component=toTest, P.Value=fisherPvals, adj.P.Val= p.adjust(fisherPvals,method="BH"))
fisherPvals[,c("tconvClonotypes","tregClonotypes")] <- t(sapply(toTest, function(comp) table(compCountDf$component == comp, compCountDf$CD4Type)["TRUE",] ))
fisherPvals  <- fisherPvals[order(fisherPvals$P.Value),]
maxval <- max( c(fisherPvals$tconvClonotypes, fisherPvals$tregClonotypes)) + 1

## Expected slope of line
slope <- sum(tcrCountDf$CD4Type == "Treg")/sum(tcrCountDf$CD4Type == "Tconventional")
fisherPvals$FDR <- ifelse( fisherPvals$adj.P.Val <= 0.1, "<=10%",">10%") 
ggplot(fisherPvals, aes(x=tconvClonotypes,y=tregClonotypes,color=FDR)) + geom_point() + geom_abline( slope=slope,linetype="dashed",color="grey") + labs(x="Tconv clonotypes in metaclonotype",y="Treg clonotypes in metaclonotype",title="Alpha Metaclonotypes (>= 5 sequences)\nin at least 10 DonorXCelltypes",color="Fisher\nTest\nFDR") + ylim( c(0,maxval)) + xlim( c(0,maxval)) + scale_color_manual(values=c("<=10%"="red",">10%"="black")) + geom_text_repel(data=fisherPvals,fontface="bold", label=fisherPvals$component, size=4, color="black") 

##### Now do the same, but for T1D vs. HC
#####
#####
##### 
donorTypeJunctionTab <- table( paste0(subTcrs$donorID,"_",subTcrs$junction,"_",subTcrs$studyGroup))
tcrCountDf <- data.frame( t(sapply( names(donorTypeJunctionTab ), function(s) strsplit(s,"_")[[1]] ))); colnames(tcrCountDf) <- c("donorID","junction","studyGroup")
tcrCountDf$count <- donorTypeJunctionTab
tcrCountDf$component <- bcomps[tcrCountDf$junction]; tcrCountDf$component[is.na(tcrCountDf$component)] <- 'other'
# Filter out components that don't have at least 6 projects contributing
clonDonorTab <- table( tcrCountDf$component[!duplicated(paste(tcrCountDf$donorID,tcrCountDf$component))])
toTest <- names(clonDonorTab)[clonDonorTab >= 5]

# tcrCountDf <- tcrCountDf[!is.na(tcrCountDf$component),]

compCountDf <- tcrCountDf[!duplicated( paste(tcrCountDf$donorID,tcrCountDf$component)),]
compCountDf$count <- table( paste(tcrCountDf$donorID,tcrCountDf$component) )[ paste(compCountDf$donorID,compCountDf$component) ]

comps <- unique(compCountDf$component)
fisherPvals <- sapply(toTest, function(comp) fisher.test( table(compCountDf$component == comp, compCountDf$studyGroup))$p.value )
fisherPvals <- data.frame(component=toTest, P.Value=fisherPvals, adj.P.Val= p.adjust(fisherPvals,method="BH"))
fisherPvals[,c("controlClonotypes","T1DClonotypes")] <- t(sapply(toTest, function(comp) table(compCountDf$component == comp, compCountDf$studyGroup)["TRUE",] ))
fisherPvals  <- fisherPvals[order(fisherPvals$P.Value),]
maxval <- max( c(fisherPvals$tconvClonotypes, fisherPvals$tregClonotypes)) + 1

## Expected slope of line
slope <- sum(tcrCountDf$CD4Type == "Treg")/sum(tcrCountDf$CD4Type == "Tconventional")
fisherPvals$FDR <- ifelse( fisherPvals$adj.P.Val <= 0.1, "<=10%",">10%") 
ggplot(fisherPvals, aes(x=tconvClonotypes,y=tregClonotypes,color=FDR)) + geom_point() + geom_abline( slope=slope,linetype="dashed",color="grey") + labs(x="Tconv clonotypes in metaclonotype",y="Treg clonotypes in metaclonotype",title="Alpha Metaclonotypes (>= 5 sequences)\nin at least 10 DonorXCelltypes",color="Fisher\n Test\nFDR") + ylim( c(0,maxval)) + xlim( c(0,maxval)) + scale_color_manual(values=c("<=10%"="red",">10%"="black")) + geom_text_repel(data=fisherPvals,fontface="bold", label=fisherPvals$component, size=4, color="black") 
```

```{r 09/26/24 get alpha and beta graph}
thresh <- "16"
dmat_a <- alphaDistmats[[thresh]]
dmat_b <- betaDistmats[[thresh]]

# Make an adjacency matrix of sequence similarity between
# chain types and co-occurrence between chain types
getABMatrix <- function(thresh, connectPairs=TRUE, dmat_a,dmat_b){
  #dmat_a <- pruneDmat( dmat_a, thresh)
  #dmat_b <- pruneDmat( dmat_b, thresh)
  as <- rownames(dmat_a)
  bs <- rownames(dmat_b)
  N <- length(as) + length(bs)
  abmat <- matrix(0,N,N)
  rownames(abmat) <- c(as,bs)
  colnames(abmat) <- rownames(abmat)
  abmat[ as,as] <- dmat_a
  abmat[bs,bs] <- dmat_b
  
  abmat[abmat==1] <- 1
  subpairs <- combo
  if( connectPairs){
    pairsub <- subpairs[ subpairs$cdr3_a_aa %in% as & subpairs$cdr3_b_aa %in% bs,]
    for( r in 1:nrow(pairsub) ){
      abmat[ pairsub[r,"cdr3_a_aa"], pairsub[r,"cdr3_b_aa"] ] <- 1.5
      abmat[ pairsub[r,"cdr3_b_aa"], pairsub[r,"cdr3_a_aa"] ] <- 1.5
    }
  }
  return(abmat)
}
abmat12 <- getABMatrix(thresh, TRUE, dmat_a,dmat_b)

vcolors <- ifelse( rownames(abmat12) %in% tcrs$junction[ tcrs$chain == "TRA"], "red","blue")

graphab <- graph_from_adjacency_matrix( abmat12, mode = "undirected",weighted = NULL, diag = TRUE,  add.colnames = NULL, add.rownames = NA)


#plot(graphab, vertex.label="",main=paste0("beta and alpha junctions\nthreshold ",thresh), vertex.size=sqrt(allTCRs[rownames(abmat12)])+4, vertex.color = vcolors )

plot(graphab, vertex.label="",main=paste0("beta and alpha junctions\nthreshold ",thresh), vertex.size=sqrt(junctionTable[rownames(abmat12)])+4, vertex.color = vcolors )

removeDups <- function(mat){
  mat <- mat[!grepl("\\.",colnames(mat)),!grepl("\\.",colnames(mat))]
  rownames(mat) <- colnames(mat)
  return(mat)
}

ad <- read.csv("../../data/2024-10-25/P487_data_GAD65_alexjalphaCDR3mat.csv"); ad <- ad[,2:ncol(ad)]; rownames(ad) <- colnames(ad)
#ad <- read.csv("../../data/2024-10-25/P487_data_GAD65_alexjbetaCDR3mat.csv");  rownames(ad) <- colnames(ad)

ad <- removeDups(ad)
amat <-  pruneDmat( ad, 4 ) 
grapha <- graph_from_adjacency_matrix( amat, mode = "undirected",weighted = NULL, diag = TRUE,  add.colnames = NULL, add.rownames = NA)
plot(grapha)
```

```{r 05/16/25 read in 10X TCR data}
getFullNtSequence <- function(a){
  return( paste0(a$fwr1_nt, a$cdr1_nt, a$fwr2_nt, a$cdr2_nt, a$fwr3_nt, a$cdr3_nt, a$fwr4_nt) )
}
anno1 <- read.csv("../../data/2025-05-13/P589_10X_TCR_Data/all_contig_annotations_pool589-1_1.csv")
anno1$full_nt_sequence <- getFullNtSequence(anno1)

anno1$barcode <- paste0("1_",anno1$barcode)
anno2 <- read.csv("../../data/2025-05-13/P589_10X_TCR_Data/all_contig_annotations_pool589-1_2.csv")
anno2$full_nt_sequence <- getFullNtSequence(anno2)

anno2$barcode <- paste0("2_",anno2$barcode)
anno589 <- rbind(anno1,anno2)
anno589 <- anno589[nchar(anno589$cdr3) > 5,]
anno589 <- anno589[anno589$productive == "true",]
pairedBarcodes <- intersect( anno589$barcode[ anno589$chain == "TRA"], anno589$barcode[ anno589$chain == "TRB"] )
 
a <- sapply( anno589$barcode, function(s) strsplit(s,"-")[[1]][2])

anno589$donor <- "na"

getCdr3Info <- function(cdr3){
  full_nt_tab <- table( anno589[ anno589$cdr3 == cdr3, "full_nt_sequence"] )
  full_nt_sequence <- names(full_nt_tab)[ full_nt_tab == max(full_nt_tab)][1]
  r <- anno589[  anno589$full_nt_sequence ==full_nt_sequence, c("full_nt_sequence","donor","raw_clonotype_id","chain","v_gene","j_gene")][1,]

  r$nbarcodes <- sum(anno589$cdr3 == cdr3 )
  r$nbarcodesNt <- sum(anno589$full_nt_sequence == full_nt_sequence )

  r$ndonors <- length( unique( anno589$donor[ anno589$cdr3 == cdr3]))
  return(r)
}
infoString <- function(cdr3){
  # Get the most expanded cell with this cdr3 and take it's full_nt_sequence
  full_nt_tab <- table( anno589[ anno589$cdr3 == cdr3, "full_nt_sequence"] )
  full_nt_sequence <- names(full_nt_tab)[ full_nt_tab == max(full_nt_tab)][1]
    
  nbarcodes <- sum(anno589$cdr3 == cdr3 )
  nbarcodesNt <- sum(anno589$full_nt_sequence == full_nt_sequence )

  ndonors <- length( unique( anno589$donor2[ anno589$cdr3 == cdr3]))
  chain <- unique( anno589$chain[ anno589$cdr3 == cdr3]) 
  return( paste0(chain, ": ", cdr3, ", barcodes: ", nbarcodes, ", donors: ", ndonors, ", barcodes_nt: ",nbarcodesNt))
}
chainSharing <- function(cid){
  print(cid)
  for( cdr3 in unique(anno589$cdr3[ anno589$raw_clonotype_id == cid]) ){
    print(infoString(cdr3))
  }
}
getPairs <- function(cid){
  #print(cid)
  #print(cid)
  cdr3s <- data.frame( t(sapply( unique(anno589$cdr3[ anno589$barcode == cid]), getCdr3Info)) )
  a <- cdr3s[ cdr3s$chain == "TRA",]
  b <- cdr3s[ cdr3s$chain == "TRB",]
  df <- data.frame()
  i <- 1
  for( ai in 1:nrow(a) ){
    for( bi in 1:nrow(b)){
      cdr3a <- rownames(a)[ai]
      cdr3b <- rownames(b)[bi]
      
      nbarcodes_pair <- length(unique(intersect(anno589$barcode[ anno589$cdr3 == cdr3a], anno589$barcode[ anno589$cdr3 == cdr3b])))
      
      r <- data.frame(sample=paste0(cid,".",i), cdr3_a_aa = cdr3a, cdr3_a_nt = as.character(a[ai,"full_nt_sequence"]), cdr3_b_aa = cdr3b, cdr3_b_nt = as.character(b[bi,"full_nt_sequence"]), nbarcodes_pair = nbarcodes_pair,v_a_gene=as.character(a[ai,"v_gene"]), j_a_gene=as.character(a[ai,"j_gene"]), v_b_gene=as.character(b[bi,"v_gene"]), j_b_gene=as.character(b[bi,"j_gene"]) )
      i <- i+1
      r$description <- paste0( infoString(cdr3a), ". ", infoString(cdr3b))
      df <- rbind(df,r)
      
    }
  }
  return(df)
}
pairs589 <- lapply(pairedBarcodes,getPairs)

pairs589 <- do.call( rbind, pairs589)
pairs589$sample <- sapply(pairs589$sample, function(s) strsplit(s,"\\.")[[1]][1])
saveRDS(pairs589,"pairs589.RDS")

pairs589 <- readRDS("pairs589.RDS")

## Remove duplicates and add the count
combo <- pairs589
combo[,c("v_a_gene","j_a_gene","v_b_gene","j_b_gene")] <- apply( combo[,c("v_a_gene","j_a_gene","v_b_gene","j_b_gene")],2, function(col) ifelse( !grepl("\\*",col), paste0(col,"*01"), col ) )

combo$pair <- paste0(combo$cdr3_a_nt,"_",combo$cdr3_b_nt)
combo$clone_id <- combo$pair
nodup <- combo[ !duplicated(combo$clone_id),]
combo$libid <- combo$sample
colnames(combo) <- c("sample","cdr3_a_aa","cdr3_a_nt","cdr3_b_aa","cdr3_b_nt","nbarcodes_pair","description","pair","clone_id","libid") 
# All of them

write.table(nodup[,! colnames(nodup) == "description"],"../../data/2025-05-13/P589_data_for_TCRDist.csv",quote=FALSE,sep=",",col.names=TRUE,row.names=FALSE)
# Just the Ara positive ones

combo <- read.csv( "../../data/2025-04-10/P390TCRS_for_TCRDist3.csv",header=TRUE,sep="," )
combo589 <- read.csv("../../data/2025-05-13/P589_data_for_TCRDist.csv",header=TRUE,sep=",")
combo589[c("subject","count","cdr3_a_nucseq","cdr3_b_nucseq")] <- combo589[,c("sample","nbarcodes_pair","cdr3_a_nt","cdr3_b_nt")]
cnames <- intersect(colnames(combo),colnames(combo589))
combined <- rbind(combo, combo589)


```

```{r 05/21/25 TCRDist analysis on 10x data}
library(igraph)
library(msa)
library(igraph)

# read in metadata
md589 <- readRDS("../../data/2025-05-13/P589_10X_TCR_Data/seuratMetaData.rds")
combo <- readRDS("pairs589.RDS")
pairs589 <- combo

pairs589$sample <- sapply(pairs589$sample, function(s) strsplit(s,"\\.")[[1]][1])
pairs589$sample <- gsub("-1-1","-1",pairs589$sample)
subpairs589 <- pairs589[ pairs589$sample %in% rownames(md589), ]
subpairs589[,c("donorId","studyGroup","stimulation")]  <- md589[ subpairs589$sample, c("donorId","studyGroup","stimulation")]

subanno589 <- anno589[ anno589$barcode %in% rownames(md589)[md589$cellType != "Other"], ]
subanno589[,c("donorId","studyGroup","stimulation","cellType")]  <- md589[ subanno589$barcode, c("donorId","studyGroup","stimulation","cellType")]

removeDups <- function(mat){
  uniques <- which(!duplicated(rownames(mat)))
  mat <- mat[uniques,uniques]
  rownames(mat) <- colnames(mat)
  return(mat)
}
alphaFile <- "../../data/2025-05-13/P589_10X_TCR_Data/alphaCDR3s.txt"
# alphaFile <- "../../data/2025-05-13/P589_10X_TCR_Data/P589_P390_sparse_alphaCDR3s.txt"

#alphaDistmat <- removeDups( ReadMtx("../../data/2025-05-13/P589_10X_TCR_Data/P589_P390_sparse_alphaMat.mtx", alphaFile, alphaFile, cell.column=1, feature.column=1) )
alphaDistmat <- removeDups( ReadMtx("../../data/2025-05-13/P589_10X_TCR_Data/P589_sparse_alphaMat.mtx", alphaFile, alphaFile, cell.column=1, feature.column=1) )

betaFile <- "../../data/2025-05-13/P589_10X_TCR_Data/betaCDR3s.txt"
betaDistmat <- removeDups( ReadMtx("../../data/2025-05-13/P589_10X_TCR_Data/P589_sparse_betaMat.mtx", betaFile, betaFile, cell.column=1, feature.column=1) )
# betaDistmat <- removeDups( ReadMtx("../../data/2025-05-13/P589_10X_TCR_Data/P589_P390_sparse_betaMat.mtx", betaFile, betaFile, cell.column=1, feature.column=1) )


### Combine P390 data with subpairs and subanno
#addedP390 <- tcrs[ tcrs$junction %in% c( rownames(alphaDistmat), rownames(betaDistmat)), ] 

## Turn the distance matrices into a graph adjacency matrix
pruneDmatSparse <- function(dmat,thresh,removeSingletons=TRUE){
  # Threshold: set entries <= thresh & > 0 to 1, else 0 (keep as sparse)
  dmat@x <- ifelse(dmat@x <= thresh & dmat@x > 0, 1, 0)
  # Remove diagonal
  diag(dmat) <- 0
  # Remove singletons if requested
  if (removeSingletons) {
    rows <- Matrix::rowSums(dmat) > 0
  } else {
    rows <- rep(TRUE, nrow(dmat))
  }
  # Subset rows and columns
  return( dmat[rows, rows, drop = FALSE] )
}

thresh <- 24
amat <- pruneDmatSparse( alphaDistmat, 24, removeSingletons = TRUE) 
bmat <- pruneDmatSparse( betaDistmat, 24, removeSingletons = TRUE) 

# bmat <- pruneDmatSparse( betaDistmat, 24, removeSingletons = TRUE) )
#### count donors per junction
pasteCollapse <- function(s){
  s <- s[order(s)]
  paste( s[!duplicated(s)], collapse=",")
}
donorsByAlpha <- aggregate( subpairs589$donorId,by=list(subpairs589$cdr3_a_aa),FUN=pasteCollapse)
donorsByBeta <- aggregate( subpairs589$donorId,by=list(subpairs589$cdr3_b_aa),FUN=pasteCollapse);
donorsByJunction <- rbind(donorsByAlpha, donorsByBeta)
colnames(donorsByJunction) <- c("junction","donorId")
rownames(donorsByJunction) <- donorsByJunction$junction
junctionDonorTab <- rbind(table(subpairs589$cdr3_a_aa, subpairs589$donorId),table(subpairs589$cdr3_b_aa, subpairs589$donorId))

```

```{r 2025-06-03 Network Plots}
addedP390 <- tcrs[ tcrs$junction %in% c( rownames(alphaDistmat), rownames(betaDistmat)), ] 
addedP390 <- addedP390[ addedP390$libid %in% soFiltered$libid, ]
addedP390$cellType <- ifelse( addedP390$libid %in% soTregs$libid, "Treg","Tconv")
addedP390$cdr3 <- addedP390$junction
addedP390$stimulation <- "Islet"
common <- intersect( colnames(subanno589), colnames(addedP390))
comboAnno <- rbind( subanno589[,common], addedP390[,common])
comboAnno <- subanno589

pairs[,c("cdr3_a_aa","cdr3_b_aa")] <- pairs[,c("CDR3a","CDR3b")]
common <- intersect( colnames(subpairs589), colnames(pairs))
#comboPairs <- rbind( subpairs589[ subpairs589$sample %in% md589$barcode[ md589$cellType %in% c("Tconv","Treg")],common], pairs[pairs$libid %in% soFiltered$libid,common])
comboPairs <- rbind( subpairs589[ subpairs589$sample %in% md589$barcode[ md589$cellType %in% c("Tconv","Treg")],common])

junctionDonorTab <- rbind(table(comboPairs$cdr3_a_aa, comboPairs$donorId),table(comboPairs$cdr3_b_aa, comboPairs$donorId))

## Network Plots
junctionTable <- table(comboAnno$cdr3[comboAnno$cellType != "Other"])
junctionTable <- table(subanno589$cdr3)
# chain <- "Alpha"
chain <- "Beta"
if( chain == "Beta" ){
  junctions <- unique(comboPairs$cdr3_b_aa)
  bDmat <- bmat
  junctions <- junctions[ junctions %in% rownames(bDmat)]
# Only use junctions that are connected to other ones
  junctions <- junctions[ rowSums(bDmat[junctions,junctions])>0]
  bDmat <- bDmat[junctions,junctions]
} else{
  junctions <- unique(comboPairs$cdr3_a_aa)
  bDmat <- amat
  junctions <- junctions[ junctions %in% rownames(bDmat)]
# Only use junctions that are connected to other ones
  junctions <- junctions[ rowSums(bDmat[junctions,junctions])>0]
  bDmat <- bDmat[junctions,junctions]
}
vertexCols <-gg_color_hue( ncol( junctionDonorTab) ); names( vertexCols) <- colnames(junctionDonorTab)

bgraph <- graph_from_adjacency_matrix(
  bDmat[junctions,junctions],
  mode = c("max"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NA
)

bcomps <- igraph::components( bgraph )$membership
# Only show components with more than 2 members
if(TRUE){
  comptab <- table(bcomps)
  comps <- names(comptab)[ comptab > 4 ]
  junctions <- names(bcomps)[bcomps %in% comps]
  bgraph <- graph_from_adjacency_matrix(
  bDmat[junctions,junctions],
  mode = c("max"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NA)
  bcomps <- igraph::components( bgraph )$membership
}
toShow <- junctions[!duplicated(bcomps[junctions])]
labels <- ifelse( junctions %in% toShow, bcomps[junctions], "")

### Break down large networks with 20 or more nodes into smaller ones with 
## Louvain Clustering
splitComponent <- function( compId ){
  js <- names(bcomps[bcomps == as.numeric(compId)])
  subgraph <- graph_from_adjacency_matrix(
  bDmat[js,js],
  mode = c("max"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NA)
  clouvain <- cluster_louvain( subgraph )

  membs <- igraph::groups(clouvain ) %>%
  lapply(function(x) data.frame(junction = x)) %>%
  bind_rows(.id = "clusterLouvain") %>%
  mutate(
    clusterLouvain = 
      factor(clusterLouvain,
  levels = sort(unique(clusterLouvain))))
memberships <- paste0(compId,"_",membs$clusterLouvain)
names(memberships) <- membs$junction
  return(memberships)

}
tab <- table( bcomps )
bigComps <- names(tab)[tab >= 20]
splitComps <- do.call(c,lapply(bigComps, splitComponent))
splitComps <- c(splitComps,bcomps[!names(bcomps) %in% names(splitComps)])

## Plot the top components
tab <- table( splitComps )
tab <- tab[rev(order(tab))]
for( n in c(20,25,30,35,40,45,50 ) ){
  toShow <- names(tab)[1:n]
  junctions <- names(splitComps)[ splitComps %in% toShow]
  print(n)
  subgraph <- graph_from_adjacency_matrix(
  bDmat[junctions,junctions],
  mode = c("max"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NA)
  
  smallcomps <- igraph::components(subgraph)$membership
  smallcompNames <- unique(smallcomps)
  cols <- make_colors( toShow )
  vcols <- cols[smallcomps]
  
  piecols <- lapply( junctions, function(j) junctionDonorTab[j,] )
  #p <- plot(bgraph, vertex.size=3, vertex.label="",main="Beta Junctions\nTCRDist Threshold: 12")
  #p <- 
  #plot(bgraph, vertex.size=junctionTable[junctions]+4, vertex.label=labels,main= paste0(chain," Junctions\nTCRDist Threshold: ",thresh,"\nMultiple Epitopes"), vertex.color=vcols,vertex.label.dist=2 )
  if(FALSE){
    filename <- paste0( "../../data/2025-06-10/P589_",chain,"_",n,"_igraph_kk.pdf" )
    pdf( filename, width=6,height=6 )
    jsToShow <- junctions[!duplicated(splitComps[junctions])]
    labels <- ifelse( junctions %in%jsToShow, splitComps[junctions], "")
    p <- plot(subgraph, vertex.size=junctionTable[junctions]+2, vertex.label=labels,main= paste0("Top ",n," ", chain, " Metaclusters\nTCRDist Threshold: ",thresh), vertex.pie.color= list(vertexCols), vertex.pie = piecols, vertex.label.dist=2, vertex.shape="pie",layout = layout_with_kk )
    print(p)
    dev.off()
    
    filename <- paste0( "../../data/2025-06-10/P589_",chain,"_",n,"_igraph_kk.png" )
    png( filename, width=500,height=500 )
    p <- plot(subgraph, vertex.size=junctionTable[junctions]+2, vertex.label=labels,main= paste0("Top ",n," ", chain, " Metaclusters\nTCRDist Threshold: ",thresh), vertex.pie.color= list(vertexCols), vertex.pie = piecols, vertex.label.dist=2, vertex.shape="pie",layout = layout_with_kk )
  
    print(p)
    dev.off()
  }
  
  layout_fixed <- layout_with_fr(subgraph) 
  
  filename <- paste0( "../../data/2025-06-10/P589_",chain,"_",n,"_igraph.pdf" )
  pdf( filename, width=6,height=6 )
  jsToShow <- junctions[!duplicated(splitComps[junctions])]
  labels <- ifelse( junctions %in%jsToShow, splitComps[junctions], "")
  p <- plot(subgraph, vertex.size=junctionTable[junctions]+2, vertex.label=labels,main= paste0("Top ",n," ", chain, " Metaclusters\nTCRDist Threshold: ",thresh), vertex.pie.color= list(vertexCols), vertex.pie = piecols, vertex.label.dist=2, vertex.shape="pie", layout = layout_fixed )
  print(p)
  dev.off()
  
  filename <- paste0( "../../data/2025-06-10/P589_",chain,"_",n,"_igraph.png" )
  png( filename, width=500,height=500 )
  p <- plot(subgraph, vertex.size=junctionTable[junctions]+2, vertex.label=labels,main= paste0("Top ",n," ", chain, " Metaclusters\nTCRDist Threshold: ",thresh), vertex.pie.color= list(vertexCols), vertex.pie = piecols, vertex.label.dist=2, vertex.shape="pie", layout = layout_fixed )
  print(p)
  dev.off()
}



ccols <- make_colors(unique(splitComps[junctions]))
### Plot top 2 components
comps <- bcomps
comptab <- table( comps ); comptab <- comptab[rev(order(comptab))]
vcols <- c("Tconventional"="red","Treg"="blue","Tconventional,Treg"="purple")
bigcomps <- c("62","79","48")
plotdir <- "../../data/2025-05-13/P589_10X_TCR_Data/TCRDistPlots/"
# for( comp in names(comptab)[1:2] ){
# for( comp in pvalDf$component[ pvalDf$adj.P.Val <= 0.2] ){
  
df <- comboAnno[comboAnno$cellType != "Other",]
junctionTypeDf <- aggregate( df$cellType,by=list(df$cdr3),FUN=pasteCollapse)
junctionTypes <- junctionTypeDf$x; names(junctionTypes) <- junctionTypeDf$Group.1
if(FALSE){
  junctions <- names(comps)[ comps == comp]
  junctions <- names(comps)[ comps  %in% bigcomps]
  clust <- "3_6"
  junctions <- names(splitComps)[ splitComps == clust ]
  #junctions <- names(splitComps)[ grepl("132_",splitComps) ]

  print(clust)
  bgraph <- graph_from_adjacency_matrix(
  bDmat[junctions,junctions],
  mode = c("max"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NA)

  smallcomps <- igraph::components(bgraph)$membership
  smallcompNames <- unique(smallcomps)
  cols <- c("darkgreen","orange","purple"); names(cols) <- smallcompNames
  vcols <- cols[smallcomps]
  # png( paste0(plotdir,"TopAlphaComponents24.png"),width=800,height=800)
  p <- plot(bgraph, vertex.label="", vertex.size=3 , vertex.color=ccols[splitComps[junctions]], main="P589 Alpha Chains, Thresh: 24\nTop 3 Components")
  print(p)
  # dev.off()
  
  plotdir <- "../../data/2025-06-30/P390P589TCRDist/"
  # png( paste0(plotdir,chain,"Igraph",thresh,"_component",comp,suffix,".png"),width=800,height=800)
  png( paste0(plotdir,chain,"Igraph",thresh,"_component",clust,suffix,"_TregTconvColor.png"),width=800,height=800)

  #p <- plot(bgraph, vertex.size=3, vertex.label="",main="Beta Junctions\nTCRDist Threshold: 12")
  #p <- plot(bgraph, vertex.size=junctionTable[junctions]+5,main= paste0(chain," Junctions, component ",comp,"\nTCRDist Threshold: ",thresh), vertex.pie.color= list(vertexCols), vertex.pie = piecols,vertex.label.dist=2,vertex.shape="pie" )
  vcols <- c("Tconv"="red","Treg"="blue","Tconv,Treg"="purple")
  p <- plot(bgraph, vertex.size=junctionTable[junctions]+5,main= paste0(chain," Junctions, component ",clust,"\nTCRDist Threshold: ",thresh), vertex.pie.color= list(vertexCols), vertex.color = vcols[ junctionTypes[junctions] ] ,vertex.label.dist=2 )

  print(p)
  dev.off()
  
  alignedJunctions <- msa( junctions,type="protein")
  logoplot <- ggseqlogo( data = as.character(alignedJunctions) ) + labs(title=paste0(length(junctions), " ", chain," chains"))
  png( paste0(plotdir,chain,"Logo",thresh,"_component",clust,suffix,".png"),width=500,height=200)
  print(logoplot)
  dev.off()

}

### Count how many cells in each project exist in each component
## Pick top 50 components by size
tab <- table(splitComps); tab <- tab[rev(order(tab))]
comps <- names(tab)
complist <- lapply(comps, function(comp) names(splitComps)[ splitComps == comp] ); names(complist) <- comps
comboAnno$group <- paste(comboAnno$donorId,comboAnno$cellType,comboAnno$studyGroup, comboAnno$stimulation,sep="_")
groups <- unique(comboAnno$group)
caByGroup <- lapply( groups, function(group) comboAnno[ comboAnno$group == group,]); names(caByGroup) <- groups
componentProjectCount <- sapply(caByGroup, function(l) sapply(complist, function(clist) sum( l$cdr3 %in% clist)  ))

sampleCounts <- rowSums( componentProjectCount > 0)
sampleCounts <- sampleCounts[rev(order(sampleCounts))]
toShow <- names(sampleCounts)[1:50]

if(FALSE){
  isletCounts <- rowSums( componentProjectCount[,grepl("Islet",colnames(componentProjectCount))] > 0)
  otherCounts <- rowSums( componentProjectCount[,!grepl("Islet",colnames(componentProjectCount))] > 0)
  ratio <- (isletCounts+1)/(otherCounts+1)
  ratio <- ratio[ isletCounts != 0]
  ratio <- ratio[rev(order(ratio ))]
  toShow <- names(ratio)[1:46]
}

d <- data.frame(t(sapply( colnames(componentProjectCount),function(s) strsplit(s,"_")[[1]])))
colnames(d) <- c("donorId","CD4Type","studyGroup","stim")
d <- d[ d$CD4Type != "Other", ]
d$sortGroupStim <- paste0(d$CD4Type, ", ", d$studyGroup,", ",d$stim)
d <- d[order(d$stim,d$CD4Type,d$studyGroup),]
t1dcols <- c("Control"="lightblue","T1D"="orange")
sortcols <- c("Treg"="blue","Tconv"="red","Tconventional"="red","Other"="grey")
stimcols <- setNames(paletteer::paletteer_d("PrettyCols::Bold", n = 3), c("Polyclonal", "IAR", "Microbial"))
d$stim <- c("CEFX"="Microbial","Islet"="IAR","CD3CD28"="Polyclonal")[d$stim]
# Revmove polyclonal
d <- d[ d$stim != "Polyclonal",]
ha <- HeatmapAnnotation(df=d[,c("CD4Type","studyGroup","stim")], col=list(studyGroup=t1dcols,CD4Type=sortcols,stim=stimcols))
# png(paste0("../../data/2025-05-13/P589_10X_TCR_Data/TCRDistPlots/Top50MetaclonotypeHeatmap_",chain,".png"),width=800,height=800)
pdf(paste0("../../data/2025-06-10/Top50MetaclonotypeHeatmap_",chain,"_CEFXIsletOnly2.pdf"),width=6.6,height=9)
#png(paste0("../../data/2025-06-10/Top50MetaclonotypeHeatmap_",chain,"_CEFXIsletOnly2.png"),width=520,height=750)

tp <- componentProjectCount[toShow,rownames(d)]
tp[tp>=20] <- 20
p <- Heatmap(tp,show_row_names=TRUE,show_column_names=FALSE,top_annotation=ha,name="cell count", column_title=paste0("P589 Cell Counts in each ",chain," TCR Metaclonotype\nTop 50 Metaclonotypes "),cluster_columns=FALSE,show_row_dend=FALSE)
dev.off()

```

```{r 05/23/25 P589 Permuting treg/tconv labels to compare component occupancy by Treg/Tconv}
chain <- "TRB"
stim <- "CEFX"
for( stim in c("CEFX","Islet") ){
  print(stim)
  subTcrs <- subanno589[subanno589$chain == chain & subanno589$stimulation == stim & subanno589$cellType != "Other",]
  subTcrs[,c("junction","CD4Type","donorID")] <- subTcrs[,c("cdr3","cellType","donorId")]
  
  ### Look at Inv. Simpson's Diversity
  ## Cells in metaclonotypes
  #subTcrs$group <- paste0(subTcrs$donorId, subTcrs$cellType)
  #invsimpA <- sapply( libsByProject, function(libs) repDiversity(df[ df$libid %in% libs & df$chain == "TRA",], .method='inv.simp', .quant='read.count') )

  
  ## Clonotypes in metaclonotypes
  
  
  junctionTypeDf <- aggregate( subTcrs$CD4Type,by=list(subTcrs$junction),FUN=pasteCollapse)
  junctionTypes <- junctionTypeDf$x; names(junctionTypes) <- junctionTypeDf$Group.1
  donorTypeJunctionTab <- table( paste0(subTcrs$donorID,"_",subTcrs$CD4Type,"_",subTcrs$junction,"_",subTcrs$studyGroup))
  tcrCountDf <- data.frame( t(sapply( names(donorTypeJunctionTab ), function(s) strsplit(s,"_")[[1]] ))); colnames(tcrCountDf) <- c("donorID","CD4Type","junction","studyGroup")
  tcrCountDf$count <- donorTypeJunctionTab
  tcrCountDf$component <- splitComps[tcrCountDf$junction]; tcrCountDf$component[is.na(tcrCountDf$component)] <- 'other'
  # Filter out components that don't have at least 6 projects contributing
  clonDonorTab <- table( tcrCountDf$component[!duplicated(paste(tcrCountDf$donorID,tcrCountDf$CD4Type,tcrCountDf$component))])
  print(table(clonDonorTab))
  toTest <- names(clonDonorTab)[clonDonorTab >= 4]

  # tcrCountDf <- tcrCountDf[!is.na(tcrCountDf$component),]
  
  compCountDf <- tcrCountDf[!duplicated( paste(tcrCountDf$donorID,tcrCountDf$CD4Type,tcrCountDf$junction)),]
  compCountDf$count <- table( paste(tcrCountDf$donorID,tcrCountDf$CD4Type,tcrCountDf$junction) )[ paste(compCountDf$donorID,compCountDf$CD4Type,compCountDf$junction) ]
  # clonotype counts
  tab <- table(compCountDf$component)
  if( stim == "Islet" ){
    toTest <- names(tab)[tab >= 5]
  } else{
    toTest <- names(tab)[tab >= 10]
  }
  
  toTest <- toTest[toTest != "other"]
  
  comps <- unique(compCountDf$component)
  fisherPvals <- sapply(toTest, function(comp) fisher.test( table(compCountDf$component == comp, compCountDf$CD4Type))$p.value )
  fisherPvals <- data.frame(component=toTest, P.Value=fisherPvals, adj.P.Val= p.adjust(fisherPvals,method="BH"))
  fisherPvals[,c("tconvClonotypes","tregClonotypes")] <- t(sapply(toTest, function(comp) table(compCountDf$component == comp, compCountDf$CD4Type)["TRUE",] ))
  fisherPvals  <- fisherPvals[order(fisherPvals$P.Value),]
  print(head(fisherPvals))
  write.table( fisherPvals,paste0("../../data/2025-06-30/P390P589TCRDist/TregvTconvFishers_",chain,"_",stim,".txt"), quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE )
  
  maxval <- max( c(fisherPvals$tregClonotypes, fisherPvals$tconvClonotypes)) + 1

  ## Expected slope of line
  slope <- sum(tcrCountDf$CD4Type== "Treg")/sum(tcrCountDf$CD4Type == "Tconv")
  fisherPvals$FDR <- ifelse( fisherPvals$adj.P.Val <= 0.1, "<=10%",">10%") 
  p <- ggplot(fisherPvals, aes(x=tconvClonotypes,y=tregClonotypes,color=FDR)) + geom_point() + geom_abline( slope=slope,linetype="dashed",color="grey") + labs(x="Tconv clonotypes in metaclonotype",y="Treg clonotypes in metaclonotype",title=paste0(chain," Metaclonotypes (>= 5 sequences)\nwith at least 10 clonotypes"),color="Fisher\n Test\nFDR") + ylim( c(0,maxval)) + xlim( c(0,maxval)) + scale_color_manual(values=c("<=10%"="red",">10%"="black")) + geom_text_repel(data=fisherPvals,fontface="bold", label=fisherPvals$component, size=4, color="black") 
  png( paste0("../../data/2025-06-30/P390P589TCRDist/TregvTconvFishers_",chain,"_",stim,".png"), width=600,height=500)
  print(p)
  dev.off()
}


##### Now do the same, but for T1D vs. HC
#####
#####
##### 
chain <- ifelse( chain %in% c("Alpha","TRA"), "TRA","TRB")
for( stim in c("CEFX","Islet") ){
  print(stim)
  subTcrs <- comboAnno[comboAnno$chain == chain & comboAnno$stimulation == stim & comboAnno$cellType != "Other",]
  subTcrs[,c("junction","CD4Type","donorID")] <- subTcrs[,c("cdr3","cellType","donorId")]
  donorJunctionTab <- table( paste0(subTcrs$donorID,"_",subTcrs$junction,"_",subTcrs$studyGroup))
  tcrCountDf <- data.frame( t(sapply( names(donorJunctionTab ), function(s) strsplit(s,"_")[[1]] ))); colnames(tcrCountDf) <- c("donorID","junction","studyGroup")
  tcrCountDf$count <- donorJunctionTab
  tcrCountDf$component <- splitComps[tcrCountDf$junction]; tcrCountDf$component[is.na(tcrCountDf$component)] <- 'other'
  # Filter out components that don't have at least 6 projects contributing
  clonDonorTab <- table( tcrCountDf$component[!duplicated(paste(tcrCountDf$donorID,tcrCountDf$component))])
  print(table(clonDonorTab))
  #toTest <- names(clonDonorTab)[clonDonorTab >= 4]

  # tcrCountDf <- tcrCountDf[!is.na(tcrCountDf$component),]
  
  compCountDf <- tcrCountDf[!duplicated( paste(tcrCountDf$donorID,tcrCountDf$junction)),]
  compCountDf$count <- table( paste(tcrCountDf$donorID,tcrCountDf$junction) )[ paste(compCountDf$donorID,compCountDf$junction) ]
  # clonotype counts
  tab <- table(compCountDf$component)
  if( stim == "Islet" ){
    toTest <- names(tab)[tab >= 3]
  } else{
    toTest <- names(tab)[tab >= 10]
  }

  
  toTest <- toTest[toTest != "other"]
  comps <- unique(compCountDf$component)
  fisherPvals <- sapply(toTest, function(comp) fisher.test( table(compCountDf$component == comp, compCountDf$studyGroup))$p.value )
  fisherPvals <- data.frame(component=toTest, P.Value=fisherPvals, adj.P.Val= p.adjust(fisherPvals,method="BH"))
  fisherPvals[,c("HCClonotypes","T1DClonotypes")] <- t(sapply(toTest, function(comp) table(compCountDf$component == comp, compCountDf$studyGroup)["TRUE",] ))
  fisherPvals  <- fisherPvals[order(fisherPvals$P.Value),]
  print(head(fisherPvals))
  write.table( fisherPvals,paste0("../../data/2025-06-30/P390P589TCRDist/T1DvHCFishers_",chain,"_",stim,".txt"), quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE )
  
    maxval <- max( c(fisherPvals$HCClonotypes, fisherPvals$T1DClonotypes)) + 1

  
    ## Expected slope of line
  slope <- sum(tcrCountDf$studyGroup== "T1D")/sum(tcrCountDf$studyGroup == "Control")
  fisherPvals$FDR <- ifelse( fisherPvals$adj.P.Val <= 0.1, "<=10%",">10%") 
  p <- ggplot(fisherPvals, aes(x=HCClonotypes,y=T1DClonotypes,color=FDR)) + geom_point() + geom_abline( slope=slope,linetype="dashed",color="grey") + labs(x="HC clonotypes in metaclonotype",y="T1D clonotypes in metaclonotype",title=paste0(chain," Metaclonotypes (>= 5 sequences)\nwith at least 10 clonotypes"),color="Fisher\n Test\nFDR") + ylim( c(0,maxval)) + xlim( c(0,maxval)) + scale_color_manual(values=c("<=10%"="red",">10%"="black")) + geom_text_repel(data=fisherPvals,fontface="bold", label=fisherPvals$component, size=4, color="black") 
  png( paste0("../../data/2025-06-30/P390P589TCRDist/T1DvHCFishers_",chain,"_",stim,".png"), width=600,height=500)
  print(p)
  dev.off()
  
}

##### Now do the same, but for CEFX vs Islet
#####
subTcrs <- comboAnno[comboAnno$chain == chain & comboAnno$stimulation %in% c("CEFX","Islet") & comboAnno$cellType != "Other",]
subTcrs[,c("junction","stimulation","donorID")] <- subTcrs[,c("cdr3","stimulation","donorId")]
junctionTypeDf <- aggregate( subTcrs$stimulation,by=list(subTcrs$junction),FUN=pasteCollapse)
junctionTypes <- junctionTypeDf$x; names(junctionTypes) <- junctionTypeDf$Group.1
donorTypeJunctionTab <- table( paste0(subTcrs$donorID,"_",subTcrs$stimulation,"_",subTcrs$junction,"_",subTcrs$studyGroup))
tcrCountDf <- data.frame( t(sapply( names(donorTypeJunctionTab ), function(s) strsplit(s,"_")[[1]] ))); colnames(tcrCountDf) <- c("donorID","stimulation","junction","studyGroup")
tcrCountDf$count <- donorTypeJunctionTab
tcrCountDf$component <- splitComps[tcrCountDf$junction]; tcrCountDf$component[is.na(tcrCountDf$component)] <- 'other'
# Filter out components that don't have at least 6 projects contributing
clonDonorTab <- table( tcrCountDf$component[!duplicated(paste(tcrCountDf$donorID,tcrCountDf$stimulation,tcrCountDf$component))])
print(table(clonDonorTab))
toTest <- names(clonDonorTab)[clonDonorTab >= 10]

# tcrCountDf <- tcrCountDf[!is.na(tcrCountDf$component),]

compCountDf <- tcrCountDf[!duplicated( paste(tcrCountDf$donorID,tcrCountDf$stimulation,tcrCountDf$junction)),]
compCountDf$count <- table( paste(tcrCountDf$donorID,tcrCountDf$stimulation,tcrCountDf$junction) )[ paste(compCountDf$donorID,compCountDf$stimulation,compCountDf$junction) ]
# clonotype counts
tab <- table(compCountDf$component)
toTest <- names(tab)[tab >= 10]


toTest <- toTest[toTest != "other"]

comps <- unique(compCountDf$component)
fisherPvals <- sapply(toTest, function(comp) fisher.test( table(compCountDf$component == comp, compCountDf$stimulation))$p.value )
fisherPvals <- data.frame(component=toTest, P.Value=fisherPvals, adj.P.Val= p.adjust(fisherPvals,method="BH"))
fisherPvals[,c("CEFXClonotypes","IsletClonotypes")] <- t(sapply(toTest, function(comp) table(compCountDf$component == comp, compCountDf$stimulation)["TRUE",] ))
fisherPvals  <- fisherPvals[order(fisherPvals$P.Value),]
print(head(fisherPvals))
write.table( fisherPvals,paste0("../../data/2025-05-13/P589_10X_TCR_Data/TCRDistPlots/CEFXIsletFishers_",chain,"_",stim,".txt"), quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE )

## Expected slope of line
slope <- sum(tcrCountDf$stimulation =="Islet")/sum(tcrCountDf$stimulation == "CEFX")
fisherPvals$FDR <- ifelse( fisherPvals$adj.P.Val <= 0.1, "<=10%",">10%") 
p <- ggplot(fisherPvals, aes(x=CEFXClonotypes,y=IsletClonotypes,color=FDR)) + geom_point() + geom_abline( slope=slope,linetype="dashed",color="grey") + labs(x="CEFX clonotypes in metaclonotype",y="Islet clonotypes in metaclonotype",title=paste0(chain," Metaclonotypes (>= 5 sequences)\nwith at least 10 clonotypes"),color="Fisher\n Test\nFDR") + ylim( c(0,maxval)) + xlim( c(0,maxval)) + scale_color_manual(values=c("<=10%"="red",">10%"="black")) + geom_text_repel(data=fisherPvals,fontface="bold", label=fisherPvals$component, size=4, color="black") 
png( paste0("../../data/2025-06-30/P390P589TCRDist/IsletvCEFXFishers_",chain,"_",stim,".png"), width=600,height=500)
print(p)
dev.off()


```

```{r 06/03/25 Output sequences for p-gen}

alphaForPgen <- anno589$full_nt_sequence[ !duplicated(anno589$full_nt_sequence) & anno589$chain == "TRA"]
write.table( alphaForPgen,"../../data/2025-05-13/P589AlphaSeqsForPgen.txt",quote=FALSE,sep="\t",col.names=FALSE,row.names=FALSE)
betaForPgen <- anno589$full_nt_sequence[ !duplicated(anno589$full_nt_sequence) & anno589$chain == "TRB"]
write.table( betaForPgen,"../../data/2025-05-13/P589BetaSeqsForPgen.txt",quote=FALSE,sep="\t",col.names=FALSE,row.names=FALSE)

alphaForPgen <- tcrs$full_nt_sequence[ !duplicated(tcrs$full_nt_sequence) & tcrs$chain == "TRA"]
write.table( alphaForPgen,"../../data/2025-05-13/P390AlphaSeqsForPgen.txt",quote=FALSE,sep="\t",col.names=FALSE,row.names=FALSE)
betaForPgen <- tcrs$full_nt_sequence[ !duplicated(tcrs$full_nt_sequence) & tcrs$chain == "TRB"]
write.table( betaForPgen,"../../data/2025-05-13/P390BetaSeqsForPgen.txt",quote=FALSE,sep="\t",col.names=FALSE,row.names=FALSE)

# Read in p-gen
pgenA <- read.table("../../data/2025-05-13/P390AlphaPgen.txt",header=TRUE,sep=",")
pgenB <- read.table("../../data/2025-05-13/P390BetaPgen.txt",header=TRUE,sep=",")
pgenA$chain <- "TRA"; pgenB$chain <- "TRB"
pgenDf <- rbind(pgenA,pgenB); rownames(pgenDf) <- pgenDf$sequence

pgenA <- read.table("../../data/2025-05-13/P589_10X_TCR_Data/P589AlphaPgen.txt",header=TRUE,sep=",")
pgenB <- read.table("../../data/2025-05-13/P589_10X_TCR_Data/P589BetaPgen.txt",header=TRUE,sep=",")
pgenA$chain <- "TRA"; pgenB$chain <- "TRB"
pgen589 <- rbind(pgenA,pgenB)

```

```{r 05/23/25 Compare CDR3 Lengths}
library(alakazam)

pairs$pairDonor <- paste( pairs$CDR3ant, pairs$CDR3bnt, pairs$donorId )
expandedPairs <- unique( pairs$pairDonor[ duplicated( pairs$pairDonor)] )
expandedLibs <- pairs$sample[ pairs$pairDonor %in% expandedPairs]

tcrs$donorSeq <- paste(tcrs$donorID, tcrs$full_nt_sequence)
expandedSeqs <- unique(tcrs$donorSeq[ duplicated(tcrs$donorSeq)])
tcrs$expanded <- ifelse( tcrs$donorSeq %in% expandedSeqs, "expChain","single")
tcrs$expanded[ tcrs$libid%in% expandedLibs ] <- "expPair"
tcrs[,c("age","sex")] <- demo[ tcrs$project, c("Age","Sex")]

# Non-naive only
subTcrs <- tcrs[ tcrs$libid %in% combinedDf$libid,]
subTcrs <- subTcrs[ !subTcrs$libid %in% naivelibs,]
subTcrs$len <- nchar(subTcrs$junction)
subTcrs$CD4Type <- gsub("Tconventional","Tconv",subTcrs$CD4Type)

lenMeans <- aggregate(len ~ donorID + studyGroup + CD4Type + chain + expanded + sex, data = subTcrs[subTcrs$chain %in% c("TRA","TRB"),], FUN = mean)
subTcrs$donorChainType <- paste0( subTcrs$donorID,"_",subTcrs$chain,"_",gsub("Tconventional","Tconv",subTcrs$CD4Type),"_",subTcrs$expanded)
lenMeans$CD4Type <- gsub("Tconventional","Tconv",lenMeans$CD4Type)
lenMeans$typeGroup <- paste0( lenMeans$CD4Type,"\n", lenMeans$studyGroup,"\n",lenMeans$expanded)
fname <- "../../data/2025-06-10/P390_CDR3LenByDonor.pdf"
title <- "Mean Memory CDR3 Lengths by Donor"
if(expanded){ fname <- gsub(".pdf","_expandedOnly.pdf",fname); title = paste0(title,"\nExpanded Chains")}
#pdf(fname,width=7,height=6)
fname <- gsub("pdf","png",fname);png(fname,width=900,height=700)
ggplot(lenMeans, aes(x=typeGroup,y=len,color=studyGroup)) + facet_wrap(~chain,nrow=2,scales="free") + geom_boxplot(outlier.color=NA) + geom_quasirandom()+ labs( y= "Mean CDR3 Amino Acid Length", x =NULL,title=title,color="") + scale_color_manual( values=groupCols) + theme(legend.position="bottom")
dev.off()
lenMeans$donorChainType <- paste0( lenMeans$donorID,"_",lenMeans$chain,"_",lenMeans$CD4Type,"_",lenMeans$expanded)
lenMeans$count <- table( subTcrs$donorChainType)[ lenMeans$donorChainType]
ggplot(lenMeans[lenMeans$chain == "TRA",], aes(x=count,y=len, color=studyGroup)) + geom_point() + scale_color_manual( values=groupCols) + facet_wrap(~CD4Type+expanded)

chains <- c("TRA","TRB")
types <- c("Tconv","Treg")
msums <- lapply(chains, function(chain) summary(lm( len ~ CD4Type*studyGroup, data = lenMeans[lenMeans$chain == chain,]) ) )

sapply(chains, function(chain) oneway.test( len ~ typeGroup, data=lenMeans[ lenMeans$chain == chain,])$p.value )

sapply(chains, function(chain) sapply( types, function(ctype) oneway.test( len ~ studyGroup, data=lenMeans[ lenMeans$chain == chain & lenMeans$CD4Type == ctype,])$p.value  ) )

sapply(chains, function(chain) sapply( types, function(ctype) wilcox.test( len ~ studyGroup, data=lenMeans[ lenMeans$chain == chain & lenMeans$CD4Type == ctype,])$p.value  ) )

subTcrs$CD4Type <- gsub("Tconventional","Tconv",subTcrs$CD4Type)
nodups <- subTcrs[ !duplicated( paste( subTcrs$full_nt_sequence, subTcrs$CD4Type, subTcrs$studyGroup) ),]

tp <- nodups[nodups$chain %in% c("TRA") & nodups$CD4Type == "Tconv" & nodups$len <= 30,]
ggplot(tp, aes(x=len,fill=studyGroup,group=donorID)) + geom_histogram(binwdith=1) + scale_fill_manual( values=groupCols) + geom_vline( xintercept = 14, linetype="dashed",color="grey")  + facet_wrap(~donorId)

nodups$group <- paste( nodups$studyGroup,nodups$chain,nodups$CD4Type,nodups$expanded)
tp <- data.frame( table(nodups$len, nodups$studyGroup,nodups$chain,nodups$CD4Type,nodups$expanded))
colnames(tp) <- c("len","studyGroup","chain","CD4Type","expanded","count")
tp$group <- paste( tp$studyGroup,tp$chain,tp$CD4Type,tp$expanded)
tab <- table(nodups$group)
tp$prop <- tp$count/as.numeric( tab[tp$group] )
fname <- "../../data/2025-05-13/P390_cdr3length_bySequence.pdf"
title <- "Unique Memory CDR3 AA Sequence Lengths"
if(expanded){ fname <- gsub(".pdf","_expandedOnly.pdf",fname); title <- paste0( title,"\nExpanded Only") }
pdf(fname,width=12,height=7)
#png(fname,width=1200,height=600)
a <- tp[tp$chain %in% c("TRA") & as.numeric(as.character(tp$len)) <30,]
ggplot(a, aes(x=len,fill=studyGroup,y=prop)) + facet_wrap(~chain+CD4Type+expanded) + geom_bar(alpha=0.4,stat="identity",position="identity") + labs(x="CDR3 Amino Acid Length",y="proportion",title=title) + scale_fill_manual(values= groupCols) + theme( legend.position = "bottom")
dev.off()

df <- nodups[nodups$chain %in% c("TRA","TRB"),]
df$group <- paste( df$chain, df$CD4Type)
groups <- unique(df$group)
df$len <- as.numeric(df$len)
sapply(groups, function(group) ks.test( df$len[ df$group == group & df$studyGroup == "Control"], df$len[ df$group == group & df$studyGroup == "T1D"])$p.value )

### Now do hydrophobicity or whatever
properties <- c("gravy","bulk","polarity","aliphatic","charge")
db_props <- aminoAcidProperties(subTcrs, property = properties, seq="full_nt_sequence", trim=TRUE, label="cdr3")
db_props$cdr3_aa_charge_abs <- abs(db_props$cdr3_aa_charge)
db_props$logPgen <- log10(pgenDf[ db_props$full_nt_sequence,"pgen"])
for( prop in c("logPgen",paste0("cdr3_aa_", c(properties,"charge_abs")) ) ){
  print(prop)
  db_props$prop <- db_props[,prop]
  df <- db_props[db_props$chain %in% c("TRA","TRB") & !duplicated(paste(db_props$donorID, db_props$full_nt_sequence)),]

  if(TRUE){ # don't split by expansion 
    gravyMeans <- aggregate( prop ~ donorID + studyGroup + CD4Type + chain + sex, data = df , FUN = mean)
    gravyMeans$CD4Type <- gsub("Tconventional","Tconv", gravyMeans$CD4Type)
    gravyMeans$typeGroup <- paste0( gravyMeans$CD4Type,"\n", gravyMeans$studyGroup)
  } else{ # Split by expansion
    gravyMeans <- aggregate( prop ~ donorID + studyGroup + CD4Type + chain + expanded + sex, data = df , FUN = mean)
    gravyMeans$CD4Type <- gsub("Tconventional","Tconv", gravyMeans$CD4Type)
    gravyMeans$typeGroup <- paste0( gravyMeans$CD4Type,"\n", gravyMeans$studyGroup,"\n",gravyMeans$expanded)
  }
  if( grepl("Pgen",prop) ){
    p <- ggplot( gravyMeans, aes(x=typeGroup,y=prop, color=studyGroup)) + facet_wrap(~chain, scales="free") + geom_boxplot(outlier.color=NA) + geom_quasirandom()+ labs( y= paste0("mean ",gsub("cdr3_aa_","",prop)), x = "CD4 Type and T1D Status",title=paste0("Average ",gsub("cdr3_aa_","",prop)," by Donor") ) + scale_color_manual( values=groupCols)
    demoByDonor <- demo[!duplicated(demo$Donor.ID),]; rownames(demoByDonor) <- demoByDonor$Donor.ID
    gravyMeans$age <- demoByDonor[ gravyMeans$donorID, "Age"]
    ggplot( gravyMeans, aes(x=age,y=prop, color=studyGroup)) + facet_wrap(~chain + CD4Type, scales="free") + geom_point() + scale_color_manual( values=groupCols) + labs(y=prop) + theme(legend.position="bottom")
  } else{
    p <- ggplot( gravyMeans, aes(x=typeGroup,y=prop, color=studyGroup)) + facet_wrap(~chain) + geom_boxplot(outlier.color=NA) + geom_quasirandom()+ labs( y= paste0("mean ",gsub("cdr3_aa_","",prop)), x = "CD4 Type and T1D Status",title=paste0("Average ",gsub("cdr3_aa_","",prop)," by Donor") ) + scale_color_manual( values=groupCols)
  }
  fname <- paste0("../../data/2025-05-13/P390_", gsub("cdr3_aa_","",prop),"_byDonor_expandedOnly.png" )
  if(!expanded){ fname <- gsub("_expandedOnly","",fname)}
  png( fname,width=550,height=400 )
  print(p)
  dev.off()
  anovaA <- oneway.test( prop ~ typeGroup, data = gravyMeans[gravyMeans$chain == "TRA",] )$p.value
  anovaB <- oneway.test( prop ~ typeGroup, data = gravyMeans[gravyMeans$chain == "TRB",] )$p.value
  print( paste0("-TRA: ", anovaA) )
  print( paste0("-TRB: ", anovaB) )
  
  print( "Tukey B")
  TukeyHSD(aov(  prop ~ typeGroup, gravyMeans[gravyMeans$chain == "TRB",] ) )[[1]]
  print( "Tukey A")
  TukeyHSD(aov(  prop ~ typeGroup, gravyMeans[gravyMeans$chain == "TRA",] ) )[[1]]
  
  
  print("")
  m <- lm( prop ~ studyGroup*CD4Type, data=gravyMeans[gravyMeans$chain == "TRA",]  )
  print(summary(m)$coefficients)
  m <- lm( prop ~ studyGroup*CD4Type+chain, data= gravyMeans  )
  print(summary(m)$coefficients)
  print("")
}

ggplot( db_props[db_props$chain %in% c("TRA","TRB"),], aes(x=cdr3_aa_gravy,fill=studyGroup)) + geom_density( alpha=0.3) + facet_wrap(~chain + CD4Type) + labs(x="hydrophobicity",y="density",title="Hydrophobicity by Cell") + scale_fill_manual( values=groupCols)

for( prop in c("logPgen",paste0("cdr3_aa_", c("gravy","charge")) ) ){
  print(prop)
  suffix <- ifelse(expanded,"_expandedOnly","")
  titleSuffix <- ifelse(expanded," Expanded","")

  ## KS kolmogorov smirnov test of hydrophobicity
  df <- db_props[db_props$chain %in% c("TRA","TRB"),]
  df$group <- paste(df$chain, df$CD4Type)
  df <- df[!duplicated(paste(df$group, df$studyGroup, df$full_nt_sequence)),]
  groups <- unique(df$group)
  df$prop <- df[,prop]
  sapply(groups, function(group) ks.test( df$prop[ df$group == group & df$studyGroup == "Control"], df$prop[ df$group == group & df$studyGroup == "T1D"])$p.value )
  pdf( paste0("../../data/2025-05-13/",prop,"ByClonotype",suffix,"_density.pdf"),width=9,height=6)
  p <- ggplot( df, aes(x=prop,fill=studyGroup)) + geom_density( alpha=0.3) + facet_wrap(~chain + CD4Type) + labs(x=prop,y="density",title=paste0(prop," by Unique", titleSuffix," Clonotype"), fill="") + scale_fill_manual( values=groupCols)
  print(p)
  dev.off()
  ### hydrophobicity histogram
  pdf( paste0("../../data/2025-05-13/",prop,"ByClonotype",suffix,"_histogram.pdf"),width=9,height=6)
  p <- ggplot( df, aes(x=prop,fill=studyGroup,y=..density..)) + geom_histogram( alpha=0.6, position="identity",bins=30) + facet_wrap(~chain + CD4Type) + labs(x=prop,y="density",title=paste0(prop," by Unique", titleSuffix," Clonotype"), fill="") + scale_fill_manual( values=groupCols) 
  if( prop == "cdr3_aa_charge" ){ p <- p + geom_vline(linetype="dashed",color="grey",xintercept = 0)}
  print(p)
  dev.off()
}


### charge
pdf("../../data/2025-05-13/ChargeByClonotype_expandedOnly_density.pdf",width=9,height=6)
ggplot( df, aes(x=cdr3_aa_charge,fill=studyGroup)) + geom_density( alpha=0.3) + facet_wrap(~chain + CD4Type) + labs(x="hydrophobicity",y="density",title="Charge by Unique Expanded Clonotype", fill="") + scale_fill_manual( values=groupCols) + geom_vline(linetype="dashed",color="grey",xintercept = 0)
dev.off()
### charge histogram
pdf("../../data/2025-05-13/ChargeByClonotype_expandedOnly_histogram.pdf",width=9,height=6)
ggplot( df, aes(x=cdr3_aa_charge,fill=studyGroup,y=..density..)) + geom_histogram( alpha=0.75, position="identity",binwidth=1) + facet_wrap(~chain + CD4Type) + labs(x="charge",y="density",title="Charge by Unique Expanded Clonotype", fill="") + scale_fill_manual( values=groupCols) + geom_vline(linetype="dashed",color="grey",xintercept = 0)
dev.off()

ggplot( db_props[db_props$chain %in% c("TRA","TRB"),], aes(x=cdr3_aa_charge_abs,fill=studyGroup)) + geom_density( alpha=0.3) + facet_wrap(~chain + CD4Type) + labs(x="abs(charge)",y="density",title="Absolute Value Charge by Cell") + scale_fill_manual( values=groupCols)

```

```{r Old code for the above}
library(alakazam)

pairs$pairDonor <- paste( pairs$CDR3ant, pairs$CDR3bnt, pairs$donorId )
expandedPairs <- unique( pairs$pairDonor[ duplicated( pairs$pairDonor)] )
expandedLibs <- pairs$sample[ pairs$pairDonor %in% expandedPairs]


expanded <- FALSE
naiveLibs <- design$libid[ design$TNaive == 1]
if(expanded){
  subTcrs <- tcrs[ tcrs$libid %in% combinedDf$libid,]
  subTcrs$donorNt <- paste0( subTcrs$donorId,"_",subTcrs$full_nt_sequence)
  expandedNts <- unique( subTcrs$donorNt[ duplicated(subTcrs$donorNt) ] )
  subTcrs <- subTcrs[ subTcrs$libid %in% expandedLibs,]
} else{
  subTcrs <- tcrs[ tcrs$libid %in% combinedDf$libid,]
  subTcrs <- subTcrs[ !subTcrs$libid %in% naiveLibs,]
}
subTcrs$len <- nchar(subTcrs$junction)

lenMeans <- aggregate(len ~ donorID + studyGroup + CD4Type + chain, data = subTcrs[subTcrs$chain %in% c("TRA","TRB"),], FUN = mean)
subTcrs$donorChainType <- paste0( subTcrs$donorID,"_",subTcrs$chain,"_",gsub("Tconventional","Tconv",subTcrs$CD4Type))
lenMeans$CD4Type <- gsub("Tconventional","Tconv",lenMeans$CD4Type)
lenMeans$typeGroup <- paste0( lenMeans$CD4Type,"\n", lenMeans$studyGroup)
fname <- "../../data/2025-06-10/P390_CDR3LenByDonor_nonNaive.pdf"
title <- "Mean Memory CDR3 Lengths by Donor"
#if(expanded){ fname <- gsub(".pdf","_expandedOnly.pdf",fname); title = paste0(title,"\nExpanded Chains")}
pdf(fname,width=7,height=6)
#png(gsub("pdf","png",fname),width=600,height=500)
ggplot(lenMeans, aes(x=typeGroup,y=len,color=studyGroup)) + facet_wrap(~chain) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=2)+ labs( y= "Mean CDR3 Amino Acid Length", x =NULL,title=title,color="") + scale_color_manual( values=groupCols) + theme(legend.position="bottom")
dev.off()
lenMeans$donorChainType <- paste0( lenMeans$donorID,"_",lenMeans$chain,"_",lenMeans$CD4Type)
lenMeans$count <- table( subTcrs$donorChainType)[ lenMeans$donorChainType]
ggplot(lenMeans, aes(x=count,y=len, color=studyGroup)) + geom_point() + scale_color_manual( values=groupCols) + facet_wrap(~CD4Type+chain,nrow=2)



chains <- c("TRA","TRB")
types <- c("Tconv","Treg")
msums <- lapply(chains, function(chain) summary(lm( len ~ CD4Type*studyGroup, data = lenMeans[lenMeans$chain == chain,]) ) ); names(msums) <- chains

sapply(chains, function(chain) oneway.test( len ~ typeGroup, data=lenMeans[ lenMeans$chain == chain,])$p.value )


sapply(chains, function(chain) sapply( types, function(ctype) oneway.test( len ~ studyGroup, data=lenMeans[ lenMeans$chain == chain & lenMeans$CD4Type == ctype,])$p.value  ) )

sapply(chains, function(chain) sapply( types, function(ctype) wilcox.test( len ~ studyGroup, data=lenMeans[ lenMeans$chain == chain & lenMeans$CD4Type == ctype,])$p.value  ) )

subTcrs$CD4Type <- gsub("Tconventional","Tconv",subTcrs$CD4Type)
nodups <- subTcrs[ !duplicated( paste( subTcrs$junction, subTcrs$CD4Type, subTcrs$studyGroup) ),]

tp <- nodups[nodups$chain %in% c("TRA") & nodups$CD4Type == "Tconv" & nodups$len <= 30,]
ggplot(tp, aes(x=len,fill=studyGroup,group=donorID)) + geom_histogram(binwdith=1) + scale_fill_manual( values=groupCols) + geom_vline( xintercept = 14, linetype="dashed",color="grey")  + facet_wrap(~donorId)





nodups$group <- paste( nodups$studyGroup,nodups$chain,nodups$CD4Type)
tp <- data.frame( table(nodups$len, nodups$studyGroup,nodups$chain,nodups$CD4Type))
colnames(tp) <- c("len","studyGroup","chain","CD4Type","count")
tp$group <- paste( tp$studyGroup,tp$chain,tp$CD4Type)
tab <- table(nodups$group)
tp$prop <- tp$count/as.numeric( tab[tp$group] )
fname <- "../../data/2025-06-10/P390_cdr3length_bySequence_nonNaive.pdf"
title <- "Unique Memory CDR3 AA Sequence Lengths"
if(expanded){ fname <- gsub(".pdf","_expandedOnly.pdf",fname); title <- paste0( title,"\nExpanded Only") }
pdf(fname,width=12,height=7)
#png(fname,width=1200,height=600)
ggplot(tp[tp$chain %in% c("TRA","TRB") & as.numeric(as.character(tp$len)) <30,], aes(x=len,fill=studyGroup,y=prop)) + facet_wrap(~chain+CD4Type) + geom_bar(alpha=0.4,stat="identity",position="identity") + labs(x="CDR3 Amino Acid Length",y="proportion",title=title) + scale_fill_manual(values= groupCols) + theme( legend.position = "bottom")
dev.off()

df <- nodups[nodups$chain %in% c("TRA","TRB"),]
df$group <- paste( df$chain, df$CD4Type)
groups <- unique(df$group)
df$len <- as.numeric(df$len)
sapply(groups, function(group) ks.test( df$len[ df$group == group & df$studyGroup == "Control"], df$len[ df$group == group & df$studyGroup == "T1D"])$p.value )

### Now do hydrophobicity or whatever
properties <- c("gravy","bulk","polarity","aliphatic","charge")
db_props <- aminoAcidProperties(subTcrs, property = properties, seq="full_nt_sequence", trim=TRUE, label="cdr3")
db_props$cdr3_aa_charge_abs <- abs(db_props$cdr3_aa_charge)
db_props$logPgen <- log10(pgenDf[ db_props$full_nt_sequence,"pgen"])
for( prop in c("logPgen",paste0("cdr3_aa_", c(properties,"charge_abs")) ) ){
  print(prop)
  db_props$prop <- db_props[,prop]
  df <- db_props[db_props$chain %in% c("TRA","TRB") & !duplicated(paste(db_props$donorID, db_props$full_nt_sequence)),]

  gravyMeans <- aggregate( prop ~ donorID + studyGroup + CD4Type + chain, data = df , FUN = mean)
  gravyMeans$CD4Type <- gsub("Tconventional","Tconv", gravyMeans$CD4Type)
  gravyMeans$typeGroup <- paste0( gravyMeans$CD4Type,"\n", gravyMeans$studyGroup)
  if( grepl("Pgen",prop) ){
    p <- ggplot( gravyMeans, aes(x=typeGroup,y=prop, color=studyGroup)) + facet_wrap(~chain, scales="free") + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=2)+ labs( y= paste0("mean ",gsub("cdr3_aa_","",prop)), x = "CD4 Type and T1D Status",title=paste0("Average ",gsub("cdr3_aa_","",prop)," by Donor") ) + scale_color_manual( values=groupCols)  + guides(color="none")
  } else{
    p <- ggplot( gravyMeans, aes(x=typeGroup,y=prop,color=studyGroup)) + facet_wrap(~chain) + geom_boxplot(outlier.color=NA) + geom_quasirandom(size=2)+ labs( y= paste0("mean ",gsub("cdr3_aa_","",prop)), x = "CD4 Type and T1D Status",title=paste0("Average ",gsub("cdr3_aa_","",prop)," by Donor") ) + scale_color_manual( values=groupCols) + guides(color="none")
  }
  fname <- paste0("../../data/2025-06-10/P390_", gsub("cdr3_aa_","",prop),"_byDonor_nonNaive_expandedOnly.png" )
  fname <- gsub("png","pdf",fname)
  if(!expanded){ fname <- gsub("_expandedOnly","",fname)}
  #png( fname,width=550,height=400 )
  pdf( fname,width=7,height=5)
  print(p)
  dev.off()
  anovaA <- oneway.test( prop ~ typeGroup, data = gravyMeans[gravyMeans$chain == "TRA",] )$p.value
  anovaB <- oneway.test( prop ~ typeGroup, data = gravyMeans[gravyMeans$chain == "TRB",] )$p.value
  print( paste0("-TRA: ", anovaA) )
  print( paste0("-TRB: ", anovaB) )
  
  print( "Tukey B")
  TukeyHSD(aov(  prop ~ typeGroup, gravyMeans[gravyMeans$chain == "TRB",] ) )[[1]]
  print( "Tukey A")
  TukeyHSD(aov(  prop ~ typeGroup, gravyMeans[gravyMeans$chain == "TRA",] ) )[[1]]
  
  
  print("LM TRA")
  m <- lm( prop ~ studyGroup*CD4Type, data=gravyMeans[gravyMeans$chain == "TRA",]  )
  print(summary(m)$coefficients[2:4,] )
  print( p.adjust( summary(m)$coefficients[2:4,"Pr(>|t|)"], method="BH") )
  print("LM TRB")
  m <- lm( prop ~ studyGroup*CD4Type, data=gravyMeans[gravyMeans$chain == "TRB",]  )
  print(summary(m)$coefficients[2:4,] )
  print( p.adjust( summary(m)$coefficients[2:4,"Pr(>|t|)"], method="BH") )
  m <- lm( prop ~ studyGroup*CD4Type+chain, data= gravyMeans  )
  print(summary(m)$coefficients)
  print("")
}

ggplot( db_props[db_props$chain %in% c("TRA","TRB"),], aes(x=cdr3_aa_gravy,fill=studyGroup)) + geom_density( alpha=0.3) + facet_wrap(~chain + CD4Type) + labs(x="hydrophobicity",y="density",title="Hydrophobicity by Cell") + scale_fill_manual( values=groupCols)

# These are distribution plots per sequence, not a mean by donor
for( prop in c("logPgen",paste0("cdr3_aa_", c("gravy","charge")) ) ){
  print(prop)
  suffix <- ifelse(expanded,"_expandedOnly","")
  titleSuffix <- ifelse(expanded," Expanded","")

  ## KS kolmogorov smirnov test of hydrophobicity
  df <- db_props[db_props$chain %in% c("TRA","TRB"),]
  df$group <- paste(df$chain, df$CD4Type)
  df <- df[!duplicated(paste(df$group, df$studyGroup, df$full_nt_sequence)),]
  groups <- unique(df$group)
  df$prop <- df[,prop]
  sapply(groups, function(group) ks.test( df$prop[ df$group == group & df$studyGroup == "Control"], df$prop[ df$group == group & df$studyGroup == "T1D"])$p.value )
  pdf( paste0("../../data/2025-06-10/",prop,"ByClonotype",suffix,"_nonNaive_density.pdf"),width=9,height=6)
  p <- ggplot( df, aes(x=prop,fill=studyGroup)) + geom_density( alpha=0.3) + facet_wrap(~chain + CD4Type) + labs(x=prop,y="density",title=paste0(prop," by Unique", titleSuffix," Clonotype"), fill="") + scale_fill_manual( values=groupCols)
  print(p)
  dev.off()
  ### hydrophobicity histogram
  pdf( paste0("../../data/2025-06-10/",prop,"ByClonotype",suffix,"_nonNaive_histogram.pdf"),width=9,height=6)
  p <- ggplot( df, aes(x=prop,fill=studyGroup,y=..density..)) + geom_histogram( alpha=0.6, position="identity",bins=30) + facet_wrap(~chain + CD4Type) + labs(x=prop,y="density",title=paste0(prop," by Unique", titleSuffix," Clonotype"), fill="") + scale_fill_manual( values=groupCols) 
  if( prop == "cdr3_aa_charge" ){ p <- p + geom_vline(linetype="dashed",color="grey",xintercept = 0)}
  print(p)
  dev.off()
}


### charge
pdf("../../data/2025-05-13/ChargeByClonotype_expandedOnly_density.pdf",width=9,height=6)
ggplot( df, aes(x=cdr3_aa_charge,fill=studyGroup)) + geom_density( alpha=0.3) + facet_wrap(~chain + CD4Type) + labs(x="hydrophobicity",y="density",title="Charge by Unique Expanded Clonotype", fill="") + scale_fill_manual( values=groupCols) + geom_vline(linetype="dashed",color="grey",xintercept = 0)
dev.off()
### charge histogram
pdf("../../data/2025-06-10/ChargeByClonotype_expandedOnly_histogram.pdf",width=9,height=6)
ggplot( df, aes(x=cdr3_aa_charge,fill=studyGroup,y=..density..)) + geom_histogram( alpha=0.75, position="identity",binwidth=1) + facet_wrap(~chain + CD4Type) + labs(x="charge",y="density",title="Charge by Unique Expanded Clonotype", fill="") + scale_fill_manual( values=groupCols) + geom_vline(linetype="dashed",color="grey",xintercept = 0)
dev.off()

ggplot( db_props[db_props$chain %in% c("TRA","TRB"),], aes(x=cdr3_aa_charge_abs,fill=studyGroup)) + geom_density( alpha=0.3) + facet_wrap(~chain + CD4Type) + labs(x="abs(charge)",y="density",title="Absolute Value Charge by Cell") + scale_fill_manual( values=groupCols)

ggplot( db_props[db_props$chain %in% c("TRA","TRB"),], aes(x=cdr3_aa_charge,fill=studyGroup)) + geom_density( alpha=0.3) + facet_wrap(~chain + CD4Type) + labs(x="abs(charge)",y="density",title="Charge by Cell") + scale_fill_manual( values=groupCols)

```

```{r 06/05/25 Pgen analysis for P589}

rownames(pgen589) <- pgen589$sequence
subanno589 <- anno589[ anno589$full_nt_sequence %in% rownames(pgen589),]
subanno589[,c("CD4Type","donorId","stim","studyGroup")] <- md589[ subanno589$barcode, c("cellType","donorId","stimulation","studyGroup")]
subanno589$pgen <- log10( pgen589[ subanno589$full_nt_sequence, "pgen"] )

### Define expanded by expanded pairs
pairs589$donorId <- md589[ pairs589$sample,"donorId"]
pairs589$pairNtDonor <- paste( pairs589$cdr3_a_nt, pairs589$cdr3_b_nt, pairs589$donorId)
expandedPairs589 <- unique(pairs589$pairNtDonor)[ duplicated(pairs589$pairNtDonor)]
expandedBarcodes <- pairs589$sample[ pairs589$pairNtDonor %in% expandedPairs589]

subanno589$donorSeq <- paste(subanno589$donorId, subanno589$full_nt_sequence)
expandedSeqs <- unique(subanno589$donorSeq[ duplicated(subanno589$donorSeq)])
subanno589$expanded <- ifelse( subanno589$donorSeq %in% expandedSeqs, "eChain","Single")
subanno589$expanded[ subanno589$barcode %in% expandedBarcodes ] <- "ePair"


meanPgen589 <- aggregate( pgen ~ donorId + studyGroup + stim + CD4Type + chain, data = subanno589, FUN = mean)
meanPgen589$count <- aggregate( pgen ~ donorId + studyGroup + stim + CD4Type + chain, data = subanno589, FUN = length)$pgen

meanPgen589$group <- paste0( meanPgen589$CD4Type,"\n",meanPgen589$studyGroup)
meanPgen589$sample <- paste(meanPgen589$donorId,meanPgen589$stim, meanPgen589$CD4Type)  


for( stim in unique(meanPgen589$stim ) ){
  print(stim)
  p <- ggplot( meanPgen589[meanPgen589$stim == stim & meanPgen589$CD4Type != "Other",], aes(x=group,y=pgen)) + geom_boxplot(outlier.color=NA) + geom_point() + geom_line(aes(group=paste(donorId,CD4Type))) + facet_wrap(~chain,nrow=2,scale="free") + labs(title=stim)
  png( paste0("../../data/2025-06-10/PgenBoxplots_",stim,".png"),width=900,height=700 )
  print(p)
  dev.off()
}
## All three... 
ggplot( meanPgen589[ meanPgen589$CD4Type != "Other",], aes(x=group,y=pgen)) + geom_boxplot(outlier.color=NA) + geom_point() + facet_wrap(~chain+stim,nrow=2,scale="free") + labs(title=stim)

subanno589$group <- paste( subanno589$CD4Type,"\n", subanno589$studyGroup) 
tab <- table(paste(subanno589$donorId,subanno589$stim, subanno589$CD4Type))
meanPgen589$group <- paste0( meanPgen589$CD4Type,"\n",meanPgen589$studyGroup)
meanPgen589$sample <- paste(meanPgen589$donorId,meanPgen589$stim, meanPgen589$CD4Type)
meanPgen589$count <- tab[ meanPgen589$sample]

png("../../data/2025-06-10/MeanPgenByCellCount.png",width=700,height=670)
ggplot(meanPgen589, aes(x=count,y=pgen,color=studyGroup)) + geom_point() + scale_color_manual( values=groupCols) + facet_wrap(~chain+CD4Type,scales="free") + theme(legend.position="bottom") + labs(y="log10 p-gen",title="Mean Pgen and Number of Cells\nBy Donor, Celltype, and Chain")
dev.off()

ggplot( meanPgen589[meanPgen589$CD4Type != "Other" & meanPgen589$chain == "TRB",], aes(x=group,y=pgen, color=studyGroup)) + geom_boxplot(outlier.color=NA) + geom_point() + facet_wrap(~stim,ncol=3) + labs(x="",y="mean log10 p-gen") + scale_color_manual( values=groupCols) 

# pgen
ggplot( meanPgen589[meanPgen589$CD4Type != "Other",], aes(x=group,y=pgen, color=studyGroup)) + geom_boxplot(outlier.color=NA) + geom_point() + facet_wrap(~chain+stim,ncol=3) + labs(x="",y="mean log10 p-gen") + scale_color_manual( values=groupCols)
pvals <- c()
for( chain in c("TRA","TRB") ){
  p <- ggplot( meanPgen589[meanPgen589$CD4Type != "Other" & meanPgen589$chain == chain,], aes(x=group,y=pgen, color=studyGroup)) + geom_boxplot(outlier.color=NA) + geom_point() + facet_wrap(~chain+stim,ncol=3) + labs(x="T1D status and Cell Type",y="mean log10 p-gen",title=paste0("P589 10X ", chain),color="") + scale_color_manual( values=groupCols) + theme( legend.position = "bottom")
  pdf(paste0("../../data/2025-06-10/P589_",chain,"_pgenByStim.pdf"),width=10,height=7 )
  print(p)
  dev.off()
  stims <- unique(meanPgen589$stim)
  p <- sapply( stims, function(stim) summary( lm( pgen ~ CD4Type+studyGroup, data=meanPgen589[meanPgen589$stim == stim & meanPgen589$chain == chain & meanPgen589$CD4Type != "Other",]))$coefficients["studyGroupT1D","Pr(>|t|)"] );
  e <- sapply( stims, function(stim) summary( lm( pgen ~ CD4Type+studyGroup, data=meanPgen589[meanPgen589$stim == stim & meanPgen589$chain == chain & meanPgen589$CD4Type != "Other",]))$coefficients["studyGroupT1D","Estimate"] )

  pvals <- rbind(pvals, data.frame("stim"=stims,"P.Value"=p,"estimate"=e,"chain"=chain)) 
}
pvals$adj.P.Val <- p.adjust( pvals$P.Value, method="BH"); pvals <- pvals[order(pvals$P.Value),]
print(pvals)


# count
ggplot( meanPgen589[meanPgen589$CD4Type != "Other",], aes(x=group,y=count)) + geom_boxplot(outlier.color=NA) + geom_point() + facet_wrap(~stim + chain) + labs(x="",y="count")
# distributions
ggplot( subanno589[!is.na(subanno589$studyGroup) & subanno589$CD4Type != "Other",], aes(x=pgen,fill=studyGroup,y=..density..)) + geom_histogram( alpha=0.6, position="identity",bins=60) + facet_wrap(~ CD4Type+stim, ncol=3) + labs(x="log10 generation probability",y="density", fill="") + scale_fill_manual( values=groupCols) 

ggplot( subanno589[!is.na(subanno589$studyGroup) & subanno589$CD4Type != "Other",], aes(x=pgen,color=studyGroup,group=donorId)) + geom_density() + facet_wrap(~ CD4Type+stim, ncol=3) + labs(x="log10 generation probability",y="density", fill="") + scale_fill_manual( values=groupCols) 


### Now split by expanded or not
meanPgen589 <- aggregate( pgen ~ donorId + studyGroup + stim + CD4Type + chain + expanded, data = subanno589, FUN = mean)
meanPgen589$group <- paste0(meanPgen589$CD4Type,"\n",meanPgen589$studyGroup,"\n",meanPgen589$expanded)
meanPgen589$group2 <- paste0(meanPgen589$studyGroup,"\n",meanPgen589$expanded)

meanPgen589$sample <- paste(meanPgen589$donorId,meanPgen589$stim, meanPgen589$CD4Type)
for( chain in c("TRA","TRB") ){
  p <- ggplot( meanPgen589[meanPgen589$CD4Type != "Other" & meanPgen589$chain == chain & meanPgen589$stim == "CEFX",], aes(x=group2,y=pgen, color=studyGroup)) + geom_boxplot(outlier.color=NA) + geom_point() + facet_wrap(~chain+stim,ncol=3) + labs(x="T1D status and Cell Type",y="mean log10 p-gen",title=paste0("P589 10X ", chain),color="") + scale_color_manual( values=groupCols) + theme( legend.position = "bottom") + facet_wrap(~CD4Type)
  pdf(paste0("../../data/2025-06-10/P589_",chain,"_pgenByStimExpansion.pdf"),width=10,height=7 )
  print(p)
  dev.off()
  stims <- unique(meanPgen589$stim)
  p <- sapply( stims, function(stim) summary( lm( pgen ~ CD4Type+studyGroup, data=meanPgen589[meanPgen589$stim == stim & meanPgen589$chain == chain & meanPgen589$CD4Type != "Other",]))$coefficients["studyGroupT1D","Pr(>|t|)"] );
  e <- sapply( stims, function(stim) summary( lm( pgen ~ CD4Type+studyGroup, data=meanPgen589[meanPgen589$stim == stim & meanPgen589$chain == chain & meanPgen589$CD4Type != "Other",]))$coefficients["studyGroupT1D","Estimate"] )
  pvals <- rbind(pvals, data.frame("stim"=stims,"P.Value"=p,"estimate"=e,"chain"=chain)) 
}
```

```{r 07/18/25 Output TCRs for paper}
tcrs$length <- nchar(tcrs$full_nt_sequence)
tcrs$multiplet <- tcrs$libid %in% betaDoublets
tcrs$isMAIT <- tcrs$libid %in% MAIT_summary$libid
tcrs$isINKT <- tcrs$libid %in% iNKT_summary$libid

col <- c("libid","donorId","studyGroup","CD4Type","length","v_gene","j_gene","productive","full_nt_sequence","multiplet","isMAIT","isINKT")
df <- tcrs[ tcrs$libid %in% design$libid[ design$qc_pass] & df$chain %in% c("TRA","TRB"),col]

write.table( df, "../../data/2025-06-30/P390TCRTable.txt",quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE)

### 08/11/25 Questions from Karen
# Total # TCR pairs per cell type: 2700 Tconv, 1010 Treg
# Expanded TCR pairs per cell type: 310 Tconv, 293 Treg
# unique expanded TCR pairs per cell type 90, 82
pairs$pairNt <- paste( pairs$CDR3ant, pairs$CDR3bnt) 
subPairs <- pairs[ pairs$libid %in% soFiltered$libid,]
subPairs$CD4Type <- ifelse( subPairs$libid %in% soTregs$libid, "Treg","Tconventional")
print(table(subPairs$CD4Type))
expandedPairs <- unique(subPairs$pairNt[duplicated(subPairs$pairNt)])
print(table(subPairs$CD4Type[subPairs$pairNt %in% expandedPairs]))
subPairs$CD4TypePair <- paste( subPairs$CD4Type, subPairs$pairNt)
print(table(subPairs$CD4Type[subPairs$pairNt %in% expandedPairs & ! duplicated( subPairs$CD4TypePair)]))


```

```{r 08/13/2025 Checking for Sequencing Errors in TCR full nucleotide sequences}

## Alpha Doublets
subpairs <- pairs[ pairs$libid %in% soFiltered$libid & !pairs$libid %in% betaDoublets,]
subpairs <- subpairs[ subpairs$libid %in% subpairs$libid[ duplicated(subpairs$libid)],]

subpairs <- subpairs[ subpairs$libid %in% subpairs$libid[ duplicated( paste( subpairs$CDR3a, subpairs$libid))],]

libs <- unique(subpairs$libid )
i <- 1
df <- c()
for( lib in libs ){
  p <- subpairs[subpairs$libid == lib,]
  as <- unique( p$cdr3_a_aa )
  for( a in as ){
    nts <- unique(p$CDR3ant[ p$CDR3a == a])
    if( length(nts) == 1 ){
      next
    }
    nc1 <- nchar(nts[1])
    nc2 <- nchar(nts[2])
    
    if(nc1 != nc2 ){
      print( paste(i,lib,a,abs(nc1-nc2),"length difference"))
      df <- rbind(df,c(lib,a,abs(nc1-nc2),"indel"))
    }else{
      mismatches <- sum( strsplit( nts[1], "")[[1]] != strsplit( nts[2], "")[[1]] )
      df <- rbind(df,c(lib,a,mismatches,"mismatches"))
    }
    i <- i+1
  }
}
a <- subpairs[subpairs$libid == "lib81299",]

```

