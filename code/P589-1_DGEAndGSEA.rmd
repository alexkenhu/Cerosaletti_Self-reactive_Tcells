---
title: "10x of foreign Ag specific Tconv and Treg in T1D"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
setwd("/Users/tedwards/Documents/projects/P589-1_Cerosaletti_Chen_foreign_autoreactive_CD4_Tcell_10X")

library(knitr)
library(dplyr)
library(tibble)
library(ggplot2)
library(GGally)
theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_rect(colour = "black", fill = NA, size = 1),
      axis.text = element_text(colour = "black"),
      axis.ticks = element_line(colour = "black"),
      legend.key = element_blank(),
      strip.text.x = element_text(size = 14, margin = margin(b = 2, t = 2)),
      strip.background = element_rect(fill = "white", colour = "black")))

library(ggthemes)
library(ggforce)
library(ggbeeswarm)
library(ggvenn)
library(viridis)
library(stringr)
library(readxl)
library(openxlsx)
library(kableExtra)
library(RColorBrewer)
library(plotly)
library(tidyr)
library(gtools)
library(data.table)
library(miscHelpers)
library(tcrGraph)
library(edgeR)
library(limma)
library(ggrepel)
library(ComplexHeatmap)
library(egg) # For ggarrange
library(ggpubr) # Also for ggarrange
library(umap)
library(igraph)
library(forcats)
library(Seurat)
library(apird)
library(randomcoloR)
library(rcartocolor)
library(paletteer)
library(circlize)
library(gridExtra)
library(ggpointdensity)
library(cowplot)
library(clusterSim) # for cluster-evaluation metrics
library(foreach) # for parallel for-loops
library(TCRtools) # for making circos plots with Matt D's code
library(scDEED)
library(dsb)
library(monocle3)
library(rstatix)
library(SeuratData)
library(SeuratWrappers)
library(magrittr)
library(purrr)
library(msigdbr)
library(clusterProfiler)
library(enrichplot)
library(patchwork)
library(alphahull) # for boundary curves around clusters
library(MASS) # for contour plots with density (provides kernal)
library(ggh4x)
opts_chunk$set(fig.width = 6, fig.height = 4.0, cache = TRUE, echo = FALSE, warning = FALSE, message = FALSE, cache.lazy = FALSE, results = "hide")
opts_knit$set(root.dir = "/Users/tedwards/Documents/projects/P589-1_Cerosaletti_Chen_foreign_autoreactive_CD4_Tcell_10X")

options(stringsAsFactors = FALSE)

options(future.globals.maxSize = 1591289600)
```

```{r setUpDirectories, cache = TRUE}
baseDir <- "/Users/tedwards/Documents/projects/P589-1_Cerosaletti_Chen_foreign_autoreactive_CD4_Tcell_10X"
dataInputDir <- file.path(baseDir, "data/input")
plotDir <- file.path(baseDir, "figures")
dataOutputDir <- file.path(baseDir, "data/output")
dataDate <- "2025-06-20"
filenameSuffix <- paste0("P589-1_autoreactive_CD4_Tcell_10X.", dataDate, "_")

P589_1Samples <- c("pool589-1_1",
  "pool589-1_2")
# /mnt/bioinformatics/pipeline/Illumina/240604_VH01513_10_222337NNX/Project_P589-1Processed_bri_240605/
P589_1Files <- paste0("/Volumes/Bioinformatics/pipeline/Illumina/240604_VH01513_10_222337NNX/Project_P589-1Processed_bri_240605/",
  P589_1Samples,
  "/outs/per_sample_outs/",
  P589_1Samples,
  "/count/sample_filtered_feature_bc_matrix.h5")

P589_1RawFiles <- paste0("/Volumes/Bioinformatics/pipeline/Illumina/240604_VH01513_10_222337NNX/Project_P589-1Processed_bri_240605/",
  P589_1Samples,
  "/outs/multi/count/",
  "raw_feature_bc_matrix.h5")

poolOrder <- c("1", "2")

# load the saved image
load(file.path(dataOutputDir, "20250522_preprocData.RData"))
```

```{r setupFunctions}
# function for saving plots as both pdf and png
savePlot <- function(
    plot,
    plotDir,
    filename,
    height,
    width,
    units = "in",
    dpi = 600,
    formats = c("pdf", "png")
    ) {
  # Ensure plotDir exists
  if (!dir.exists(plotDir)) dir.create(plotDir, recursive = TRUE)

  # Save as PDF
  if ("pdf" %in% formats) {
    pdf(file.path(plotDir, paste0(filenameSuffix, "_", filename, ".pdf")), height = height, width = width)
    print(plot)
    dev.off()
  }

  # Save as PNG
  if ("png" %in% formats) {
    png(
      file.path(plotDir, paste0(filenameSuffix, "_", filename, ".png")),
      height = height,
      width = width,
      units = units,
      res = dpi
    )
    print(plot)
    dev.off()
  }
}
```

```{r pseudobulkDGEStimulationCellType_harmonizeWithAHu}
# Fetch the raw counts from the Seurat object
counts.tmp <- GetAssayData(seuratAgSpecific, assay = "RNA", layer = "counts")

# Filter genes: keep only those expressed (count > 0) in at least 30% of cells
cellCount <- ncol(counts.tmp)
geneFilter <- rowSums(counts.tmp > 0) >= 0.3 * cellCount
counts.tmp <- counts.tmp[geneFilter, ]

# Fetch metadata required for grouping
metadata.tmp <- seuratAgSpecific@meta.data[, c("stimulationFigures", "donorIdFigures", "cellType")]

# Create a new column for groupDGE with a consistent separator (e.g., "_")
# Use donorIdFigures (not donorId)
metadata.tmp$groupDGE <- paste(metadata.tmp$donorIdFigures, metadata.tmp$stimulationFigures, metadata.tmp$cellType, sep = "_")

# Calculate nCells per pseudobulk group
nCellsPerGroup <- as.data.frame(table(metadata.tmp$groupDGE))
colnames(nCellsPerGroup) <- c("groupDGE", "nCells")

# Merge nCells into metadata
metadata.tmp <- left_join(metadata.tmp, nCellsPerGroup, by = "groupDGE")

# Verify the new groupDGE column
head(metadata.tmp$groupDGE)

# Aggregate counts by groupDGE
counts.df.tmp <- as.data.frame(t(counts.tmp))
counts.df.tmp$groupDGE <- metadata.tmp$groupDGE

pseudobulkCounts.tmp <- counts.df.tmp %>%
  group_by(groupDGE) %>%
  summarise(across(all_of(setdiff(names(counts.df.tmp), "groupDGE")), sum), .groups = "drop")

# Convert to a matrix with genes as rows and groups as columns
countMatrixAggregated.tmp <- as.data.frame(pseudobulkCounts.tmp)
rownames(countMatrixAggregated.tmp) <- countMatrixAggregated.tmp$groupDGE
countMatrixAggregated.tmp <- countMatrixAggregated.tmp[, -1]
countMatrixAggregated.tmp <- as.matrix(t(countMatrixAggregated.tmp))

# Prepare designBulk dataframe for model.matrix
# Get unique group info for each pseudobulk sample (column)
designBulk <- metadata.tmp %>%
  distinct(groupDGE, .keep_all = TRUE) %>%
  select(groupDGE, stimulationFigures, cellType, nCells)
designBulk <- designBulk[match(colnames(countMatrixAggregated.tmp), designBulk$groupDGE), ]

# Create DGEList object
dgeAggregated.tmp <- DGEList(counts = countMatrixAggregated.tmp)

# Filter out lowly expressed genes
keep <- filterByExpr(dgeAggregated.tmp)
dgeAggregated.tmp <- dgeAggregated.tmp[keep, , keep.lib.sizes = FALSE]

# Normalize the data using TMM normalization
dgeAggregated.tmp <- calcNormFactors(dgeAggregated.tmp, method = "TMM")

# Construct design matrix as in your colleague's code
design_mat <- model.matrix(~ 0 + stimulationFigures:cellType + nCells, data = designBulk)
colnames(design_mat) <- gsub("\\:", "_", colnames(design_mat)) # replace : with _
colnames(design_mat) <- gsub("stimulationFigures", "", colnames(design_mat)) # remove the 'stimulationFigures' pre-append
colnames(design_mat) <- gsub("cellType", "", colnames(design_mat)) # remove the 'cellType' pre-append

# Verify the design matrix
print(design_mat)

# Apply voom transformation
v <- voom(dgeAggregated.tmp, design_mat, plot = TRUE)

# Fit the linear model
fit <- lmFit(v, design_mat)

# Define contrasts as in your colleague's code
cont.matrix <- makeContrasts(
  Microbial_TregVTconv = Microbial_Treg - Microbial_Tconv,
  IAR_TregVTconv = IAR_Treg - IAR_Tconv,
  Polyclonal_TregVTconv = Polyclonal_Treg - Polyclonal_Tconv,
  Combined_TregVTconv = ((Microbial_Treg - Microbial_Tconv) + (IAR_Treg - IAR_Tconv) + (Polyclonal_Treg - Polyclonal_Tconv)) / 3,
  Treg_IARVMicrobial = IAR_Treg - Microbial_Treg,
  Tconv_IARVMicrobial = IAR_Tconv - Microbial_Tconv,
  levels = design_mat
)

# Apply contrasts to the fitted model
fit2 <- contrasts.fit(fit, cont.matrix)

# Apply empirical Bayes moderation
fit2 <- eBayes(fit2)

# Extract results for each contrast
results_Microbial_TregVTconv <- topTable(fit2, coef = "Microbial_TregVTconv", adjust.method = "BH", sort.by = "P", number = Inf)
results_Microbial_TregVTconv$gene <- rownames(results_Microbial_TregVTconv)
results_IAR_TregVTconv <- topTable(fit2, coef = "IAR_TregVTconv", adjust.method = "BH", sort.by = "P", number = Inf)
results_IAR_TregVTconv$gene <- rownames(results_IAR_TregVTconv)
results_Polyclonal_TregVTconv <- topTable(fit2, coef = "Polyclonal_TregVTconv", adjust.method = "BH", sort.by = "P", number = Inf)
results_Polyclonal_TregVTconv$gene <- rownames(results_Polyclonal_TregVTconv)
results_Combined_TregVTconv <- topTable(fit2, coef = "Combined_TregVTconv", adjust.method = "BH", sort.by = "P", number = Inf)
results_Combined_TregVTconv$gene <- rownames(results_Combined_TregVTconv)
results_Treg_IARVMicrobial <- topTable(fit2, coef = "Treg_IARVMicrobial", adjust.method = "BH", sort.by = "P", number = Inf)
results_Treg_IARVMicrobial$gene <- rownames(results_Treg_IARVMicrobial)
results_Tconv_IARVMicrobial <- topTable(fit2, coef = "Tconv_IARVMicrobial", adjust.method = "BH", sort.by = "P", number = Inf)
results_Tconv_IARVMicrobial$gene <- rownames(results_Tconv_IARVMicrobial)

# Add Ensembl gene IDs to all results tables
library(biomaRt)
library(geneSynonym)

# Connect to Ensembl human database (using recent stable version)
ensembl <- useMart("ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl")

# Function to add Ensembl IDs to results table
add_ensembl_ids <- function(results_df) {
  # Get mapping from HGNC symbols to Ensembl IDs
  gene_mapping <- getBM(
    attributes = c("hgnc_symbol", "ensembl_gene_id"),
    filters = "hgnc_symbol",
    values = results_df$gene,
    mart = ensembl
  )

  # Remove duplicates - keep only first Ensembl ID per gene symbol
  gene_mapping <- gene_mapping %>%
    dplyr::filter(!is.na(ensembl_gene_id) & ensembl_gene_id != "") %>%
    dplyr::group_by(hgnc_symbol) %>%
    dplyr::slice(1) %>%
    dplyr::ungroup()

  # Add ensembl_gene_id column to results_df, initialized as NA
  results_with_ensembl <- results_df
  results_with_ensembl$ensembl_gene_id <- NA_character_

  # Update with mapped IDs
  for (i in 1:nrow(gene_mapping)) {
    gene_name <- gene_mapping$hgnc_symbol[i]
    ensembl_id <- gene_mapping$ensembl_gene_id[i]
    results_with_ensembl$ensembl_gene_id[results_with_ensembl$gene == gene_name] <- ensembl_id
  }

  # Find genes with NA Ensembl IDs
  na_genes <- results_with_ensembl$gene[is.na(results_with_ensembl$ensembl_gene_id)]

  if (length(na_genes) > 0) {
    cat("Attempting to resolve", length(na_genes), "genes with NA Ensembl IDs using gene synonyms...\n")

    # Try to resolve NAs using gene synonyms
    for (gene in na_genes) {
      tryCatch(
        {
          # Get synonyms for this gene
          synonyms_list <- humanSyno(gene)

          if (length(synonyms_list) > 0 && length(synonyms_list[[1]]) > 0) {
            synonyms <- synonyms_list[[1]][[1]]  # Extract the vector of synonyms

            # Try each synonym until we get a match
            for (synonym in synonyms) {
              if (synonym != gene) {  # Skip the original gene name
                synonym_mapping <- getBM(
                  attributes = c("hgnc_symbol", "ensembl_gene_id"),
                  filters = "hgnc_symbol",
                  values = synonym,
                  mart = ensembl
                )

                if (nrow(synonym_mapping) > 0 && !is.na(synonym_mapping$ensembl_gene_id[1]) && synonym_mapping$ensembl_gene_id[1] != "") {
                  # Update the NA value with the found Ensembl ID
                  results_with_ensembl$ensembl_gene_id[results_with_ensembl$gene == gene] <- synonym_mapping$ensembl_gene_id[1]
                  cat("Resolved", gene, "->", synonym, "->", synonym_mapping$ensembl_gene_id[1], "\n")
                  break  # Stop trying synonyms for this gene
                }
              }
            }
          }
        },
        error = function(e) {
          # Silently continue if there's an error with this gene
        })
    }
  }

  # Reorder columns to put ensembl_gene_id after gene
  col_order <- c("gene", "ensembl_gene_id",
    setdiff(names(results_with_ensembl), c("gene", "ensembl_gene_id")))
  results_with_ensembl <- results_with_ensembl[, col_order]

  return(results_with_ensembl)
}

# Add Ensembl IDs to all results tables
cat("Adding Ensembl gene IDs to DGE results...\n")
results_Microbial_TregVTconv <- add_ensembl_ids(results_Microbial_TregVTconv)
results_IAR_TregVTconv <- add_ensembl_ids(results_IAR_TregVTconv)
results_Polyclonal_TregVTconv <- add_ensembl_ids(results_Polyclonal_TregVTconv)
results_Combined_TregVTconv <- add_ensembl_ids(results_Combined_TregVTconv)
results_Treg_IARVMicrobial <- add_ensembl_ids(results_Treg_IARVMicrobial)
results_Tconv_IARVMicrobial <- add_ensembl_ids(results_Tconv_IARVMicrobial)
cat("Ensembl gene IDs added successfully.\n")

# write all results to .csv files
write.csv(results_Microbial_TregVTconv,
  file = file.path(dataOutputDir, paste0(filenameSuffix, "DGE_Microbial_TregVTconv.csv")),
  row.names = TRUE)

write.csv(results_IAR_TregVTconv,
  file = file.path(dataOutputDir, paste0(filenameSuffix, "DGE_IAR_TregVTconv.csv")),
  row.names = TRUE)

write.csv(results_Polyclonal_TregVTconv,
  file = file.path(dataOutputDir, paste0(filenameSuffix, "DGE_Polyclonal_TregVTconv.csv")),
  row.names = TRUE)

write.csv(results_Combined_TregVTconv,
  file = file.path(dataOutputDir, paste0(filenameSuffix, "DGE_Combined_TregVTconv.csv")),
  row.names = TRUE)

write.csv(results_Treg_IARVMicrobial,
  file = file.path(dataOutputDir, paste0(filenameSuffix, "DGE_Treg_IARVMicrobial.csv")),
  row.names = TRUE)

write.csv(results_Tconv_IARVMicrobial,
  file = file.path(dataOutputDir, paste0(filenameSuffix, "DGE_Tconv_IARVMicrobial.csv")),
  row.names = TRUE)

# rm_tmp(ask = FALSE)
```

```{r GSEAIARVsCEFX_geneRatioHorizontalAxis}
# Get hallmark, C2, and C5 gene sets
hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
  dplyr::select(gs_name, gene_symbol)

c7_sets <- msigdbr(species = "Homo sapiens", category = "C7") %>%
  dplyr::select(gs_name, gene_symbol)

c5_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
  dplyr::select(gs_name, gene_symbol)

c2_sets <- msigdbr(species = "Homo sapiens", category = "C2") %>%
  dplyr::select(gs_name, gene_symbol)

# Define which categories to run
categories <- c("H", "C2", "C5", "C7")

comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Create lists to store GSEA results and dotplots
gsea_results <- list()

for (comp in names(comparisons)) {
  # Get DE results for this contrast and filter for significant genes
  df <- comparisons[[comp]]
  df_sig <- df %>% filter(adj.P.Val <= 0.1)
  cat(nrow(df_sig), " significant genes for ", comp, "\n")

  if (nrow(df_sig) < 10) {
    message("Not enough significant genes for ", comp, ", skipping GSEA.")
    next
  }

  # Split significant genes into "Up" and "Down" based on logFC sign
  df_up <- df_sig %>% filter(logFC > 0)
  df_down <- df_sig %>% filter(logFC < 0)

  # Create a list to iterate over "Up" and "Down" groups
  directions <- list("Up" = df_up, "Down" = df_down)

  for (direction in names(directions)) {
    df_dir <- directions[[direction]]
    if (nrow(df_dir) < 10) {
      message("Not enough significant genes for ", comp, " (", direction, "), skipping GSEA.")
      next
    }

    # Create a ranked gene list using logFC (for significant genes in this direction)
    geneList <- df_dir$logFC
    names(geneList) <- df_dir$gene
    geneList <- sort(geneList, decreasing = TRUE)

    gsea_results[[comp]][[direction]] <- list()

    # Run GSEA for each gene set collection (H, C2, C5, C7)
    for (cat in categories) {
      if (cat == "H") {
        term2gene <- hs_sets
      } else if (cat == "C5") {
        term2gene <- c5_sets
      } else if (cat == "C2") {
        term2gene <- c2_sets
      } else if (cat == "C7") {
        term2gene <- c7_sets
      }

      gsea_obj <- GSEA(geneList, TERM2GENE = term2gene,
        minGSSize = 10, maxGSSize = 1000,
        pvalueCutoff = 0.05)

      gsea_results[[comp]][[direction]][[cat]] <- gsea_obj

      # Check if any term is enriched
      if (nrow(gsea_obj@result) == 0) {
        message("No enriched terms for ", comp, " (", direction, ") with category ", cat, ", skipping dotplot.")
        next
      }

      # Produce a dotplot for the top enriched pathways (up to 15 categories)
      dp <- dotplot(gsea_obj, showCategory = 15) +
        ggtitle(paste(comp, "(", direction, " - ", cat, ")"))

      # Save the dotplot as a PDF
      pdf_filename <- file.path(plotDir, paste0(comp, "_GSEA_dotplot_", direction, "_", cat, ".pdf"))
      pdf(file = pdf_filename, width = 9, height = 9)
      print(dp)
      dev.off()
    }
  }
}
```

```{r GSEAIARVsCEFXDirectionSplit_enrichmentScoreHorizontalAxis}
fontSize <- 12

# Get hallmark, C2, and C5 gene sets
hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
  dplyr::select(gs_name, gene_symbol)

c7_sets <- msigdbr(species = "Homo sapiens", category = "C7") %>%
  dplyr::select(gs_name, gene_symbol)

c5_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
  dplyr::select(gs_name, gene_symbol)

c2_sets <- msigdbr(species = "Homo sapiens", category = "C2") %>%
  dplyr::select(gs_name, gene_symbol)

# Define which categories to run
categories <- c("H", "C2", "C5", "C7")

comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Mapping for comparisons
comparison_titles <- c(
  "results_Treg_IARVMicrobial" = "Treg: IAR - Microbial",
  "results_Tconv_IARVMicrobial" = "Tconv: IAR - Microbial"
)

# Mapping for gene set categories
category_titles <- c(
  "H" = "Hallmark",
  "C2" = "Curated",
  "C5" = "GO",
  "C7" = "Immunologic"
)

# Create lists to store GSEA results and dotplots
gsea_results <- list()

for (comp in names(comparisons)) {
  # Get DE results for this contrast and filter for significant genes
  df <- comparisons[[comp]]
  df_sig <- df %>% filter(adj.P.Val <= 0.1)
  cat(nrow(df_sig), " significant genes for ", comp, "\n")

  if (nrow(df_sig) < 10) {
    message("Not enough significant genes for ", comp, ", skipping GSEA.")
    next
  }

  # Split significant genes into "Up" and "Down" based on logFC sign
  df_up <- df_sig %>% filter(logFC > 0)
  df_down <- df_sig %>% filter(logFC < 0)

  # Create a list to iterate over "Up" and "Down" groups
  directions <- list("Up" = df_up, "Down" = df_down)

  for (direction in names(directions)) {
    df_dir <- directions[[direction]]
    if (nrow(df_dir) < 10) {
      message("Not enough significant genes for ", comp, " (", direction, "), skipping GSEA.")
      next
    }

    # Create a ranked gene list using logFC (for significant genes in this direction)
    geneList <- df_dir$logFC
    names(geneList) <- df_dir$gene
    geneList <- sort(geneList, decreasing = TRUE)

    gsea_results[[comp]][[direction]] <- list()

    # Run GSEA for each gene set collection (H, C2, C5, C7)
    for (cat in categories) {
      if (cat == "H") {
        term2gene <- hs_sets
      } else if (cat == "C5") {
        term2gene <- c5_sets
      } else if (cat == "C2") {
        term2gene <- c2_sets
      } else if (cat == "C7") {
        term2gene <- c7_sets
      }

      gsea_obj <- GSEA(geneList, TERM2GENE = term2gene,
        minGSSize = 10, maxGSSize = 1000,
        pvalueCutoff = 0.05)

      gsea_results[[comp]][[direction]][[cat]] <- gsea_obj

      # Check if any term is enriched
      if (nrow(gsea_obj@result) == 0) {
        message("No enriched terms for ", comp, " (", direction, ") with category ", cat, ", skipping dotplot.")
        next
      }

      # Filter for modules with gene count > 10
      gsea_res_filt <- gsea_obj@result %>% dplyr::filter(setSize > 10)

      if (nrow(gsea_res_filt) == 0) {
        message("No enriched terms with gene count > 10 for ", comp, " (", direction, ") with category ", cat, ", skipping dotplot.")
        next
      }


      # Dotplot: x-axis is NES (signed enrichment score), color by p.adjust (red=low, blue=high), size by gene count
      gsea_res_filt_top <- gsea_res_filt %>% head(15)
      pvals <- gsea_res_filt_top$p.adjust

      if (length(unique(pvals)) == 1) {
        # All p-values are the same, use a single color
        dp.tmp <- ggplot(gsea_res_filt_top, aes(x = NES, y = reorder(Description, NES))) +
          geom_point(aes(size = setSize), color = "red") +
          labs(title = paste0(comparison_titles[comp], " (", category_titles[cat], ", ", direction, ")"),
            x = "Normalized Enrichment Score (NES)",
            y = "Gene Set",
            size = "Gene Count",
            color = "Adj. p-value"
          ) +
          theme_minimal(base_size = fontSize)
      } else {
        dp.tmp <- ggplot(gsea_res_filt_top, aes(x = NES, y = reorder(Description, NES))) +
          geom_point(aes(size = setSize, color = p.adjust)) +
          scale_color_gradient(
            low = "red", high = "blue",
            name = "Adj. p-value",
            guide = guide_colorbar(reverse = TRUE)
          ) +
          labs(
            title = paste(comp, "(", direction, "-", cat, ")"),
            x = "Normalized Enrichment Score (NES)",
            y = "Gene Set",
            size = "Gene Count"
          ) +
          theme_minimal(base_size = fontSize)
      }

      # Save the dotplot
      savePlot(
        plot = dp.tmp,
        plotDir = plotDir,
        filename = paste0(comp, "_GSEA_dotplot_ES", direction, "_", cat),
        height = 9,
        width = 9,
        units = "in",
        dpi = 600,
        formats = c("pdf", "png")
      )

    }
  }
}

rm_tmp(ask = FALSE)
```

```{r GSEAIARVsCEFX_enrichmentScoreHorizontalAxis}
fontSize <- 12

# Get hallmark, C2, C5, and C7 gene sets
hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
  dplyr::select(gs_name, gene_symbol)
c7_sets <- msigdbr(species = "Homo sapiens", category = "C7") %>%
  dplyr::select(gs_name, gene_symbol)
c5_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
  dplyr::select(gs_name, gene_symbol)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2") %>%
  dplyr::select(gs_name, gene_symbol)

# Define which categories to run
categories <- c("H", "C2", "C5", "C7")

comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Mapping for comparisons
comparison_titles <- c(
  "results_Treg_IARVMicrobial" = "Treg: IAR - Microbial",
  "results_Tconv_IARVMicrobial" = "Tconv: IAR - Microbial"
)

# Mapping for gene set categories
category_titles <- c(
  "H" = "Hallmark",
  "C2" = "Curated",
  "C5" = "GO",
  "C7" = "Immunologic"
)

# Create lists to store GSEA results and dotplots
gsea_results <- list()

for (comp in names(comparisons)) {
  # Get DE results for this contrast and filter for significant genes
  df <- comparisons[[comp]]
  df_sig <- df %>% filter(adj.P.Val <= 0.1)
  cat(nrow(df_sig), " significant genes for ", comp, "\n")

  if (nrow(df_sig) < 10) {
    message("Not enough significant genes for ", comp, ", skipping GSEA.")
    next
  }

  # Split significant genes into "Up" and "Down" based on logFC sign
  df_up <- df_sig %>% filter(logFC > 0)
  df_down <- df_sig %>% filter(logFC < 0)

  # Create a list to iterate over "Up" and "Down" groups
  directions <- list("Up" = df_up, "Down" = df_down)

  for (direction in names(directions)) {
    df_dir <- directions[[direction]]
    if (nrow(df_dir) < 10) {
      message("Not enough significant genes for ", comp, " (", direction, "), skipping GSEA.")
      next
    }

    # Create a ranked gene list using logFC (for significant genes in this direction)
    geneList <- df_dir$logFC
    names(geneList) <- df_dir$gene
    geneList <- sort(geneList, decreasing = TRUE)

    gsea_results[[comp]][[direction]] <- list()

    # Run GSEA for each gene set collection (H, C2, C5, C7)
    for (cat in categories) {
      if (cat == "H") {
        term2gene <- hs_sets
      } else if (cat == "C5") {
        term2gene <- c5_sets
      } else if (cat == "C2") {
        term2gene <- c2_sets
      } else if (cat == "C7") {
        term2gene <- c7_sets
      }

      gsea_obj <- GSEA(geneList, TERM2GENE = term2gene,
        minGSSize = 10, maxGSSize = 1000,
        pvalueCutoff = 0.05)

      gsea_results[[comp]][[direction]][[cat]] <- gsea_obj

      # Check if any term is enriched
      if (nrow(gsea_obj@result) == 0) {
        message("No enriched terms for ", comp, " (", direction, ") with category ", cat, ", skipping dotplot.")
        next
      }

      # Filter for modules with gene count > 10
      gsea_res_filt <- gsea_obj@result %>% dplyr::filter(setSize > 10)

      if (nrow(gsea_res_filt) == 0) {
        message("No enriched terms with gene count > 10 for ", comp, " (", direction, ") with category ", cat, ", skipping dotplot.")
        next
      }

      # Dotplot: x-axis is NES (signed enrichment score), color by p.adjust (red=low, blue=high), size by gene count
      gsea_res_filt_top <- gsea_res_filt %>% head(15)
      pvals <- gsea_res_filt_top$p.adjust

      if (length(unique(pvals)) == 1) {
        # All p-values are the same, use a single color
        dp.tmp <- ggplot(gsea_res_filt_top, aes(x = NES, y = reorder(Description, NES))) +
          geom_point(aes(size = setSize), color = "red") +
          labs(title = paste0(comparison_titles[comp], " (", category_titles[cat], ", ", direction, ")"),
            x = "Normalized Enrichment Score (NES)",
            y = "Gene Set",
            size = "Gene Count",
            color = "Adj. p-value"
          ) +
          theme_minimal(base_size = fontSize)
      } else {
        dp.tmp <- ggplot(gsea_res_filt_top, aes(x = NES, y = reorder(Description, NES))) +
          geom_point(aes(size = setSize, color = p.adjust)) +
          scale_color_gradient(
            low = "red", high = "blue",
            name = "Adj. p-value",
            guide = guide_colorbar(reverse = TRUE)
          ) +
          labs(
            title = paste(comp, "(", direction, "-", cat, ")"),
            x = "Normalized Enrichment Score (NES)",
            y = "Gene Set",
            size = "Gene Count"
          ) +
          theme_minimal(base_size = fontSize)
      }

      # Save the dotplot
      savePlot(
        plot = dp.tmp,
        plotDir = plotDir,
        filename = paste0(comp, "_GSEA_dotplot_ES", direction, "_", cat),
        height = 9,
        width = 9,
        units = "in",
        dpi = 600,
        formats = c("pdf", "png")
      )

    }
  }
}

rm_tmp(ask = FALSE)
```

```{r GSEAHorizontalAxis}
fontSize <- 12

# Get hallmark, C2, C5, and C7 gene sets
hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
  dplyr::select(gs_name, gene_symbol)
c7_sets <- msigdbr(species = "Homo sapiens", category = "C7") %>%
  dplyr::select(gs_name, gene_symbol)
c5_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
  dplyr::select(gs_name, gene_symbol)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2") %>%
  dplyr::select(gs_name, gene_symbol)

categories <- c("H", "C2", "C5", "C7")

comparisons <- list(
  "results_Treg_IARVMicrobial" = results_Treg_IARVMicrobial,
  "results_Tconv_IARVMicrobial" = results_Tconv_IARVMicrobial
)

comparison_titles <- c(
  "results_Treg_IARVMicrobial" = "Treg: IAR - Microbial",
  "results_Tconv_IARVMicrobial" = "Tconv: IAR - Microbial"
)

category_titles <- c(
  "H" = "Hallmark",
  "C2" = "Curated",
  "C5" = "GO",
  "C7" = "Immunologic"
)

gsea_results <- list()

for (comp in names(comparisons)) {
  df <- comparisons[[comp]]
  df_sig <- df %>% filter(adj.P.Val <= 0.1)
  cat(nrow(df_sig), " significant genes for ", comp, "\n")

  if (nrow(df_sig) < 10) {
    message("Not enough significant genes for ", comp, ", skipping GSEA.")
    next
  }

  geneList <- df_sig$logFC
  names(geneList) <- df_sig$gene
  geneList <- sort(geneList, decreasing = TRUE)

  gsea_results[[comp]] <- list()

  for (cat in categories) {
    term2gene <- switch(cat,
      "H" = hs_sets,
      "C2" = c2_sets,
      "C5" = c5_sets,
      "C7" = c7_sets
    )

    # DEBUG: Print gene list info
    cat("DEBUG - comp:", comp, "cat:", cat, "\n")
    cat("DEBUG - geneList length:", length(geneList), "\n")
    cat("DEBUG - geneList range:", range(geneList), "\n")
    cat("DEBUG - term2gene nrow:", nrow(term2gene), "\n")

    gsea_obj <- GSEA(geneList, TERM2GENE = term2gene,
      minGSSize = 10, maxGSSize = 1000,
      pvalueCutoff = 0.05)

    # DEBUG: Print GSEA results info
    cat("DEBUG - gsea_obj@result nrow:", nrow(gsea_obj@result), "\n")
    if (nrow(gsea_obj@result) > 0) {
      cat("DEBUG - p.adjust range:", range(gsea_obj@result$p.adjust), "\n")
    }

    gsea_results[[comp]][[cat]] <- gsea_obj

    if (nrow(gsea_obj@result) == 0) {
      message("No enriched terms for ", comp, " with category ", cat, ", skipping dotplot.")
      next
    }

    gsea_res_filt <- gsea_obj@result %>% dplyr::filter(setSize > 10)

    if (nrow(gsea_res_filt) == 0) {
      message("No enriched terms with gene count > 10 for ", comp, " with category ", cat, ", skipping dotplot.")
      next
    }

    gsea_res_filt_top <- gsea_res_filt %>% head(15)
    pvals <- gsea_res_filt_top$p.adjust
    print(comp)
    print(cat)
    print(length(pvals))

    dp.tmp <- ggplot(gsea_res_filt_top, aes(x = NES, y = reorder(Description, NES))) +
      geom_point(aes(size = setSize, color = p.adjust)) +
      scale_color_gradient(
        low = "red", high = "blue",
        name = "Adj. p-value",
        guide = guide_colorbar(reverse = TRUE)
      ) +
      labs(
        title = paste0(comparison_titles[comp], " (", category_titles[cat], ")"),
        x = "Normalized Enrichment Score (NES)",
        y = "Gene Set",
        size = "Gene Count"
      ) +
      theme_minimal(base_size = fontSize)

    savePlot(
      plot = dp.tmp,
      plotDir = plotDir,
      filename = paste0(comp, "_GSEA_dotplot_", cat),
      height = 9,
      width = 9,
      units = "in",
      dpi = 600,
      formats = c("pdf", "png")
    )
  }
}
```

```{r Figure2CNareshStyleEnrichmentPlotHallmark}
comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Mapping for comparisons
comparison_titles <- c(
  "results_Treg_IARVMicrobial" = "Treg: IAR - Microbial",
  "results_Tconv_IARVMicrobial" = "Tconv: IAR - Microbial"
)

create_hallmark_gsea_comparison <- function(comparisons) {
  # Get Hallmark gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  # 1. SINGLE COMPREHENSIVE GSEA RUN: Get all pathways with correct multiple-testing adjustment

  # Get gene lists for each cell type
  treg_df <- comparisons[["results_Treg_IARVMicrobial"]]
  treg_df <- treg_df %>% dplyr::filter(adj.P.Val <= 0.1)
  treg_geneList <- treg_df$logFC
  names(treg_geneList) <- treg_df$gene
  treg_geneList <- sort(treg_geneList, decreasing = TRUE)

  tconv_df <- comparisons[["results_Tconv_IARVMicrobial"]]
  tconv_df <- tconv_df %>% dplyr::filter(adj.P.Val <= 0.1)
  tconv_geneList <- tconv_df$logFC
  names(tconv_geneList) <- tconv_df$gene
  tconv_geneList <- sort(tconv_geneList, decreasing = TRUE)

  # Run GSEA ONCE with p-value=1.0 to get ALL pathways with properly adjusted p-values
  treg_gsea <- GSEA(treg_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)  # Get ALL pathways

  tconv_gsea <- GSEA(tconv_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)  # Get ALL pathways

  # 2. SELECT TERMS using the properly adjusted p-values from the comprehensive analysis

  # Find significantly enriched terms (p.adjust < 0.05) in each cell type
  treg_significant <- treg_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust)

  tconv_significant <- tconv_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust)

  # Print counts of significant terms for debugging
  cat("Significant HALLMARK pathways in Treg:", nrow(treg_significant), "\n")
  cat("Significant HALLMARK pathways in Tconv:", nrow(tconv_significant), "\n")

  # Get top 3 from Treg (or all if fewer)
  treg_top <- treg_significant %>%
    dplyr::slice(1:min(10, nrow(.)))

  # Get top 7 from Tconv that don't overlap with Treg
  tconv_nonoverlap <- tconv_significant %>%
    dplyr::filter(!(ID %in% treg_top$ID)) %>%
    dplyr::slice(1:min(10, nrow(.)))

  # List of terms to display
  display_terms <- c(treg_top$ID, tconv_nonoverlap$ID)

  # Print for debugging
  cat("Selected", length(treg_top$ID), "terms from Treg and",
    length(tconv_nonoverlap$ID), "terms from Tconv\n")

  # 3. PREPARE DATA: Extract selected terms from each cell type's results

  # Get results for these terms from Treg data
  treg_results <- treg_gsea@result %>%
    dplyr::filter(ID %in% display_terms) %>%
    dplyr::mutate(CellType = "Treg",
      # Mark if this term is significant in THIS cell type
      is_significant = ID %in% treg_significant$ID,
      # Also mark if this is one of the selected top terms for THIS cell type
      is_selected_top = ID %in% treg_top$ID)

  # Get results for these terms from Tconv data
  tconv_results <- tconv_gsea@result %>%
    dplyr::filter(ID %in% display_terms) %>%
    dplyr::mutate(CellType = "Tconv",
      # Mark if this term is significant in THIS cell type
      is_significant = ID %in% tconv_significant$ID,
      # Also mark if this is one of the selected top terms for THIS cell type
      is_selected_top = ID %in% tconv_nonoverlap$ID)

  # Handle any missing terms by adding with placeholder values
  missing_in_treg <- setdiff(display_terms, treg_results$ID)
  missing_in_tconv <- setdiff(display_terms, tconv_results$ID)

  if (length(missing_in_treg) > 0) {
    for (term in missing_in_treg) {
      term_desc <- tconv_results$Description[tconv_results$ID == term]
      if (length(term_desc) > 0) {
        treg_results <- rbind(treg_results,
          data.frame(ID = term,
            Description = term_desc[1],
            setSize = NA,
            enrichmentScore = 0,
            NES = 0,
            pvalue = 1,
            p.adjust = 1,
            qvalue = 1,
            rank = NA,
            leading_edge = NA,
            core_enrichment = NA,
            CellType = "Treg",
            is_significant = FALSE,
            is_selected_top = FALSE))
      }
    }
  }

  if (length(missing_in_tconv) > 0) {
    for (term in missing_in_tconv) {
      term_desc <- treg_results$Description[treg_results$ID == term]
      if (length(term_desc) > 0) {
        tconv_results <- rbind(tconv_results,
          data.frame(ID = term,
            Description = term_desc[1],
            setSize = NA,
            enrichmentScore = 0,
            NES = 0,
            pvalue = 1,
            p.adjust = 1,
            qvalue = 1,
            rank = NA,
            leading_edge = NA,
            core_enrichment = NA,
            CellType = "Tconv",
            is_significant = FALSE,
            is_selected_top = FALSE))
      }
    }
  }

  # 4. COMBINE AND FORMAT: Merge results for plotting

  # Combine the results
  combined_results <- rbind(treg_results, tconv_results)

  # Clean up pathway names
  combined_results$Description <- gsub("HALLMARK_", "", combined_results$Description)

  # Sort pathways by average NES magnitude
  description_order <- combined_results %>%
    dplyr::group_by(Description) %>%
    dplyr::summarize(mean_abs_NES = mean(abs(NES), na.rm = TRUE)) %>%
    dplyr::arrange(desc(mean_abs_NES)) %>%
    dplyr::pull(Description)

  combined_results$Description <- factor(combined_results$Description,
    levels = description_order)

  # 5. CREATE PLOT: Using selected top terms for coloring
  p <- ggplot(combined_results, aes(x = NES, y = Description)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description, yend = Description, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      # Size based on -log10(p.adjust)
      size = -log10(p.adjust),
      # Only color the originally selected top terms as significant
      fill = ifelse(is_selected_top, "Significant", "Not Significant")
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_wrap(~CellType, nrow = 1) +
    scale_fill_manual(
      values = c("Significant" = "red", "Not Significant" = "lightblue"),
      name = "Significance"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "Hallmark Gene Sets: IAR vs Microbial"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white"),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 14),
      axis.text.x = element_text(size = 14),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank()
    )

  # Return the plot and data
  return(list(plot = p, data = combined_results))
}

# Run the function and save the plot
result <- create_hallmark_gsea_comparison(comparisons)

# Save the plot
savePlot(
  plot = result$plot,
  plotDir = plotDir,
  filename = "Hallmark_GSEA_Comparison_TregTconv",
  height = 8,
  width = 12,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)

# Save the data for reference
# write.csv(result$data, file = file.path(dataOutputDir, "Hallmark_GSEA_Comparison_Data.csv"),
#           row.names = FALSE)
```

```{r Figure2DNareshStyleEnrichmentPlotGO}
comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Mapping for comparisons
comparison_titles <- c(
  "results_Treg_IARVMicrobial" = "Treg: IAR - Microbial",
  "results_Tconv_IARVMicrobial" = "Tconv: IAR - Microbial"
)

create_GO_gsea_comparison <- function(comparisons) {
  # Get Hallmark gene sets
  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # 1. SINGLE COMPREHENSIVE GSEA RUN: Get all pathways with correct multiple-testing adjustment

  # Get gene lists for each cell type
  treg_df <- comparisons[["results_Treg_IARVMicrobial"]]
  treg_df <- treg_df %>% dplyr::filter(adj.P.Val <= 0.05)
  treg_geneList <- treg_df$logFC
  names(treg_geneList) <- treg_df$gene
  treg_geneList <- sort(treg_geneList, decreasing = TRUE)

  tconv_df <- comparisons[["results_Tconv_IARVMicrobial"]]
  tconv_df <- tconv_df %>% dplyr::filter(adj.P.Val <= 0.05)
  tconv_geneList <- tconv_df$logFC
  names(tconv_geneList) <- tconv_df$gene
  tconv_geneList <- sort(tconv_geneList, decreasing = TRUE)

  # Run GSEA ONCE with p-value=1.0 to get ALL pathways with properly adjusted p-values
  treg_gsea <- GSEA(treg_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)  # Get ALL pathways

  tconv_gsea <- GSEA(tconv_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)  # Get ALL pathways

  # 2. SELECT TERMS using the properly adjusted p-values from the comprehensive analysis

  # Find significantly enriched terms (p.adjust < 0.05) in each cell type
  treg_significant <- treg_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust)

  tconv_significant <- tconv_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust)

  # Print counts of significant terms for debugging
  cat("Significant HALLMARK pathways in Treg:", nrow(treg_significant), "\n")
  cat("Significant HALLMARK pathways in Tconv:", nrow(tconv_significant), "\n")

  # Get top 8 from Treg (or all if fewer)
  treg_top <- treg_significant %>%
    dplyr::slice(1:min(8, nrow(.)))

  # Get top 8 from Tconv that don't overlap with Treg
  tconv_nonoverlap <- tconv_significant %>%
    dplyr::filter(!(ID %in% treg_top$ID)) %>%
    dplyr::slice(1:min(8, nrow(.)))

  # List of terms to display
  display_terms <- c(treg_top$ID, tconv_nonoverlap$ID)

  # Print for debugging
  cat("Selected", length(treg_top$ID), "terms from Treg and",
    length(tconv_nonoverlap$ID), "terms from Tconv\n")

  # 3. PREPARE DATA: Extract selected terms from each cell type's results

  # Get results for these terms from Treg data
  treg_results <- treg_gsea@result %>%
    dplyr::filter(ID %in% display_terms) %>%
    dplyr::mutate(CellType = "Treg",
      # Mark if this term is significant in THIS cell type
      is_significant = ID %in% treg_significant$ID,
      # Also mark if this is one of the selected top terms for THIS cell type
      is_selected_top = ID %in% treg_top$ID)

  # Get results for these terms from Tconv data
  tconv_results <- tconv_gsea@result %>%
    dplyr::filter(ID %in% display_terms) %>%
    dplyr::mutate(CellType = "Tconv",
      # Mark if this term is significant in THIS cell type
      is_significant = ID %in% tconv_significant$ID,
      # Also mark if this is one of the selected top terms for THIS cell type
      is_selected_top = ID %in% tconv_nonoverlap$ID)

  # Handle any missing terms by adding with placeholder values
  missing_in_treg <- setdiff(display_terms, treg_results$ID)
  missing_in_tconv <- setdiff(display_terms, tconv_results$ID)

  if (length(missing_in_treg) > 0) {
    for (term in missing_in_treg) {
      term_desc <- tconv_results$Description[tconv_results$ID == term]
      if (length(term_desc) > 0) {
        treg_results <- rbind(treg_results,
          data.frame(ID = term,
            Description = term_desc[1],
            setSize = NA,
            enrichmentScore = 0,
            NES = 0,
            pvalue = 1,
            p.adjust = 1,
            qvalue = 1,
            rank = NA,
            leading_edge = NA,
            core_enrichment = NA,
            CellType = "Treg",
            is_significant = FALSE,
            is_selected_top = FALSE))
      }
    }
  }

  if (length(missing_in_tconv) > 0) {
    for (term in missing_in_tconv) {
      term_desc <- treg_results$Description[treg_results$ID == term]
      if (length(term_desc) > 0) {
        tconv_results <- rbind(tconv_results,
          data.frame(ID = term,
            Description = term_desc[1],
            setSize = NA,
            enrichmentScore = 0,
            NES = 0,
            pvalue = 1,
            p.adjust = 1,
            qvalue = 1,
            rank = NA,
            leading_edge = NA,
            core_enrichment = NA,
            CellType = "Tconv",
            is_significant = FALSE,
            is_selected_top = FALSE))
      }
    }
  }

  # 4. COMBINE AND FORMAT: Merge results for plotting

  # Combine the results
  combined_results <- rbind(treg_results, tconv_results)

  # Clean up pathway names
  combined_results$Description <- gsub("GOCC_", "", combined_results$Description)
  combined_results$Description <- gsub("GOBP_", "", combined_results$Description)
  combined_results$Description <- gsub("GOMF_", "", combined_results$Description)

  # Sort pathways by average NES magnitude
  description_order <- combined_results %>%
    dplyr::group_by(Description) %>%
    dplyr::summarize(mean_abs_NES = mean(abs(NES), na.rm = TRUE)) %>%
    dplyr::arrange(desc(mean_abs_NES)) %>%
    dplyr::pull(Description)

  combined_results$Description <- factor(combined_results$Description,
    levels = description_order)

  # 5. CREATE PLOT: Using selected top terms for coloring
  p <- ggplot(combined_results, aes(x = NES, y = Description)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description, yend = Description, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      # Size based on -log10(p.adjust)
      size = -log10(p.adjust),
      # Only color the originally selected top terms as significant
      fill = ifelse(is_selected_top, "Significant", "Not Significant")
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_wrap(~CellType, nrow = 1) +
    scale_fill_manual(
      values = c("Significant" = "red", "Not Significant" = "lightblue"),
      name = "Significance"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "GO Gene Sets: IAR vs Microbial"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white"),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 14),
      axis.text.x = element_text(size = 14),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank()
    )

  # Return the plot and data
  return(list(plot = p, data = combined_results))
}

# Run the function and save the plot
result <- create_GO_gsea_comparison(comparisons)

# Save the plot
savePlot(
  plot = result$plot,
  plotDir = plotDir,
  filename = "Hallmark_GO_Comparison_TregTconv",
  height = 8,
  width = 12,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)

# Save the data for reference
# write.csv(result$data, file = file.path(dataOutputDir, "GO_GSEA_Comparison_Data.csv"),
#           row.names = FALSE)
```

```{r Figure2ECombinedTregHallmarkGO}
nTerms <- 15 # number of terms to include in the plots

comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
# comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Combined Treg figure with Hallmark on left and GO on right
create_combined_treg_gsea <- function(comparisons) {
  # Get gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # Get Treg gene list
  treg_df <- comparisons[["results_Treg_IARVMicrobial"]]
  treg_df <- treg_df %>% dplyr::filter(adj.P.Val <= 0.1)
  treg_geneList <- treg_df$logFC
  names(treg_geneList) <- treg_df$gene
  treg_geneList <- sort(treg_geneList, decreasing = TRUE)

  # Run GSEA for both gene sets
  treg_hallmark_gsea <- GSEA(treg_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1)  # Get ALL pathways with proper FDR correction

  treg_go_gsea <- GSEA(treg_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1)  # Get ALL pathways with proper FDR correction

  # Export GSEA results to Excel
  gsea_data_list <- list(
    "Treg_Hallmark" = treg_hallmark_gsea@result,
    "Treg_GO" = treg_go_gsea@result
  )

  output_filename <- file.path(dataOutputDir, paste0(filenameSuffix, "GSEA_results_Treg_IARVMicrobial.xlsx"))
  write.xlsx(gsea_data_list, file = output_filename, overwrite = TRUE)
  cat("GSEA results exported to:", output_filename, "\n")

  # Select significant terms
  hallmark_significant <- treg_hallmark_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  go_significant <- treg_go_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  # Print debugging info
  cat("Treg Hallmark significant terms (p.adjust < 0.05):", nrow(hallmark_significant), "\n")
  cat("Treg GO significant terms (p.adjust < 0.05):", nrow(go_significant), "\n")

  # Check if we have any significant terms at all
  if (nrow(hallmark_significant) == 0 && nrow(go_significant) == 0) {
    cat("No significant terms found for Treg. Returning empty plot.\n")
    empty_plot <- ggplot() +
      geom_text(aes(x = 0, y = 0, label = "No significant terms found"), size = 6) +
      theme_void() +
      ggtitle("Treg: No Significant Terms (IAR vs Microbial)")
    return(list(plot = empty_plot, data = data.frame()))
  }

  # Prepare Hallmark data
  hallmark_data <- hallmark_significant %>%
    dplyr::mutate(
      GeneSet = "Hallmark",
      Description_clean = gsub("HALLMARK_", "", Description)
    )

  # Prepare GO data
  go_data <- go_significant %>%
    dplyr::mutate(
      GeneSet = "GO",
      Description_clean = gsub("GOCC_|GOBP_|GOMF_", "", Description)
    )

  # Combine data
  combined_data <- rbind(
    hallmark_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet),
    go_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet)
  )

  # Order terms by NES magnitude within each gene set
  hallmark_order <- hallmark_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  go_order <- go_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  combined_data$Description_clean <- factor(combined_data$Description_clean,
    levels = c(hallmark_order, go_order))

  # Create the plot
  p <- ggplot(combined_data, aes(x = NES, y = Description_clean)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description_clean, yend = Description_clean, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      size = -log10(p.adjust),
      fill = -log10(p.adjust)
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_wrap(~GeneSet, scales = "free_y", nrow = 1) +
    scale_fill_gradient(
      low = "lightblue", high = "red",
      name = "-log10(Adj.P)"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "Treg: Hallmark and GO Gene Sets (IAR vs Microbial)"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white", color = "black", linewidth = 1),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(size = 12),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    ) +
    ggh4x::facetted_pos_scales(
      y = list(
        scale_y_discrete(position = "left"),   # GO on left
        scale_y_discrete(position = "right")   # Hallmark on right
      )
    )

  return(list(plot = p, data = combined_data))
}

# Run the function and save the plot
treg_result <- create_combined_treg_gsea(comparisons)

# Save the plot
savePlot(
  plot = treg_result$plot,
  plotDir = plotDir,
  filename = "Combined_Treg_Hallmark_GO_GSEA",
  height = 8,
  width = 18,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)
```

```{r Figure2FCombinedTconvHallmarkGO}
nTerms <- 15 # number of terms to include in the plots

comparisons <- list()
# comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Combined Tconv figure with Hallmark on left and GO on right
create_combined_tconv_gsea <- function(comparisons) {
  # Get gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # Get Tconv gene list
  tconv_df <- comparisons[["results_Tconv_IARVMicrobial"]]
  tconv_df <- tconv_df %>% dplyr::filter(adj.P.Val <= 0.1)
  tconv_geneList <- tconv_df$logFC
  names(tconv_geneList) <- tconv_df$gene
  tconv_geneList <- sort(tconv_geneList, decreasing = TRUE)

  # Run GSEA for both gene sets
  tconv_hallmark_gsea <- GSEA(tconv_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1)  # Get ALL pathways with proper FDR correction

  tconv_go_gsea <- GSEA(tconv_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1)  # Get ALL pathways with proper FDR correction

  # Export GSEA results to Excel
  gsea_data_list <- list(
    "Tconv_Hallmark" = tconv_hallmark_gsea@result,
    "Tconv_GO" = tconv_go_gsea@result
  )

  output_filename <- file.path(dataOutputDir, paste0(filenameSuffix, "GSEA_results_Tconv_IARVMicrobial.xlsx"))
  write.xlsx(gsea_data_list, file = output_filename, overwrite = TRUE)
  cat("GSEA results exported to:", output_filename, "\n")

  # Select significant terms
  hallmark_significant <- tconv_hallmark_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  go_significant <- tconv_go_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  # Print debugging info
  cat("Tconv Hallmark significant terms (p.adjust < 0.05):", nrow(hallmark_significant), "\n")
  cat("Tconv GO significant terms (p.adjust < 0.05):", nrow(go_significant), "\n")

  # Check if we have any significant terms at all
  if (nrow(hallmark_significant) == 0 && nrow(go_significant) == 0) {
    cat("No significant terms found for Tconv. Returning empty plot.\n")
    empty_plot <- ggplot() +
      geom_text(aes(x = 0, y = 0, label = "No significant terms found"), size = 6) +
      theme_void() +
      ggtitle("Tconv: No Significant Terms (IAR vs Microbial)")
    return(list(plot = empty_plot, data = data.frame()))
  }

  # Prepare Hallmark data
  hallmark_data <- hallmark_significant %>%
    dplyr::mutate(
      GeneSet = "Hallmark",
      Description_clean = gsub("HALLMARK_", "", Description)
    )

  # Prepare GO data
  go_data <- go_significant %>%
    dplyr::mutate(
      GeneSet = "GO",
      Description_clean = gsub("GOCC_|GOBP_|GOMF_", "", Description)
    )

  # Combine data
  combined_data <- rbind(
    hallmark_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet),
    go_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet)
  )

  # Order terms by NES magnitude within each gene set
  hallmark_order <- hallmark_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  go_order <- go_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  combined_data$Description_clean <- factor(combined_data$Description_clean,
    levels = c(hallmark_order, go_order))

  # Create the plot
  p <- ggplot(combined_data, aes(x = NES, y = Description_clean)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description_clean, yend = Description_clean, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      size = -log10(p.adjust),
      fill = -log10(p.adjust)
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_wrap(~GeneSet, scales = "free_y", nrow = 1) +
    scale_fill_gradient(
      low = "lightblue", high = "red",
      name = "-log10(Adj.P)"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "Tconv: Hallmark and GO Gene Sets (IAR vs Microbial)"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white", color = "black", linewidth = 1),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(size = 12),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    ) +
    ggh4x::facetted_pos_scales(
      y = list(
        scale_y_discrete(position = "left"),   # GO on left
        scale_y_discrete(position = "right")   # Hallmark on right
      )
    )

  return(list(plot = p, data = combined_data))
}

# Run the function and save the plot
tconv_result <- create_combined_tconv_gsea(comparisons)

# Save the plot
savePlot(
  plot = tconv_result$plot,
  plotDir = plotDir,
  filename = "Combined_Tconv_Hallmark_GO_GSEA",
  height = 8,
  width = 18,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)
```

```{r Figure2EStackedTregHallmarkGO}
nTerms <- 15 # number of terms to include in the plots

comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial

# Combined Treg figure with Hallmark on top and GO on bottom (stacked)
create_stacked_treg_gsea <- function(comparisons) {
  # Get gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # Get Treg gene list
  treg_df <- comparisons[["results_Treg_IARVMicrobial"]]
  treg_df <- treg_df %>% dplyr::filter(adj.P.Val <= 0.1)
  treg_geneList <- treg_df$logFC
  names(treg_geneList) <- treg_df$gene
  treg_geneList <- sort(treg_geneList, decreasing = TRUE)

  # Run GSEA for both gene sets
  treg_hallmark_gsea <- GSEA(treg_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  treg_go_gsea <- GSEA(treg_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  # Select significant terms
  hallmark_significant <- treg_hallmark_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  go_significant <- treg_go_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  # Check if we have any significant terms at all
  if (nrow(hallmark_significant) == 0 && nrow(go_significant) == 0) {
    cat("No significant terms found for Treg. Returning empty plot.\n")
    empty_plot <- ggplot() +
      geom_text(aes(x = 0, y = 0, label = "No significant terms found"), size = 6) +
      theme_void() +
      ggtitle("Treg: No Significant Terms (IAR vs Microbial) - Stacked")
    return(list(plot = empty_plot, data = data.frame()))
  }

  # Prepare Hallmark data
  hallmark_data <- hallmark_significant %>%
    dplyr::mutate(
      GeneSet = "Hallmark",
      Description_clean = gsub("HALLMARK_", "", Description)
    )

  # Prepare GO data
  go_data <- go_significant %>%
    dplyr::mutate(
      GeneSet = "GO",
      Description_clean = gsub("GOCC_|GOBP_|GOMF_", "", Description)
    )

  # Combine data
  combined_data <- rbind(
    hallmark_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet),
    go_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet)
  )

  # Order terms by NES magnitude within each gene set
  hallmark_order <- hallmark_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  go_order <- go_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  combined_data$Description_clean <- factor(combined_data$Description_clean,
    levels = c(hallmark_order, go_order))

  # Create the plot with proportional panel heights using facet_grid
  p <- ggplot(combined_data, aes(x = NES, y = Description_clean)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description_clean, yend = Description_clean, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      size = -log10(p.adjust),
      fill = -log10(p.adjust)
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_grid(GeneSet ~ ., scales = "free_y", space = "free_y") +
    scale_fill_gradient(
      low = "lightblue", high = "red",
      name = "-log10(Adj.P)"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "Treg: Hallmark and GO Gene Sets (IAR vs Microbial) - Stacked"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white", color = "black", linewidth = 1),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(size = 12),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    )

  return(list(plot = p, data = combined_data))
}

# Run the function and save the plot
treg_stacked_result <- create_stacked_treg_gsea(comparisons)

# Save the plot
savePlot(
  plot = treg_stacked_result$plot,
  plotDir = plotDir,
  filename = "Stacked_Treg_Hallmark_GO_GSEA",
  height = 14,
  width = 16,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)
```


## Stacked Tconv Plot
```{r Figure2FStackedTconvHallmarkGO}
nTerms <- 15 # number of terms to include in the plots

comparisons <- list()
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Combined Tconv figure with Hallmark on top and GO on bottom (stacked)
create_stacked_tconv_gsea <- function(comparisons) {
  # Get gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # Get Tconv gene list
  tconv_df <- comparisons[["results_Tconv_IARVMicrobial"]]
  tconv_df <- tconv_df %>% dplyr::filter(adj.P.Val <= 0.1)
  tconv_geneList <- tconv_df$logFC
  names(tconv_geneList) <- tconv_df$gene
  tconv_geneList <- sort(tconv_geneList, decreasing = TRUE)

  # Run GSEA for both gene sets
  tconv_hallmark_gsea <- GSEA(tconv_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  tconv_go_gsea <- GSEA(tconv_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  # Select significant terms
  hallmark_significant <- tconv_hallmark_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  go_significant <- tconv_go_gsea@result %>%
    dplyr::filter(p.adjust < 0.05) %>%
    dplyr::arrange(p.adjust) %>%
    dplyr::slice(1:min(nTerms, nrow(.)))

  # Check if we have any significant terms at all
  if (nrow(hallmark_significant) == 0 && nrow(go_significant) == 0) {
    cat("No significant terms found for Tconv. Returning empty plot.\n")
    empty_plot <- ggplot() +
      geom_text(aes(x = 0, y = 0, label = "No significant terms found"), size = 6) +
      theme_void() +
      ggtitle("Tconv: No Significant Terms (IAR vs Microbial) - Stacked")
    return(list(plot = empty_plot, data = data.frame()))
  }

  # Prepare Hallmark data
  hallmark_data <- hallmark_significant %>%
    dplyr::mutate(
      GeneSet = "Hallmark",
      Description_clean = gsub("HALLMARK_", "", Description)
    )

  # Prepare GO data
  go_data <- go_significant %>%
    dplyr::mutate(
      GeneSet = "GO",
      Description_clean = gsub("GOCC_|GOBP_|GOMF_", "", Description)
    )

  # Combine data
  combined_data <- rbind(
    hallmark_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet),
    go_data %>% dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet)
  )

  # Order terms by NES magnitude within each gene set
  hallmark_order <- hallmark_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  go_order <- go_data %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  combined_data$Description_clean <- factor(combined_data$Description_clean,
    levels = c(hallmark_order, go_order))

  # Create the plot with proportional panel heights using facet_grid
  p <- ggplot(combined_data, aes(x = NES, y = Description_clean)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description_clean, yend = Description_clean, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      size = -log10(p.adjust),
      fill = -log10(p.adjust)
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_grid(GeneSet ~ ., scales = "free_y", space = "free_y") +
    scale_fill_gradient(
      low = "lightblue", high = "red",
      name = "-log10(Adj.P)"
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "-log10(Adj.P)",
      title = "Tconv: Hallmark and GO Gene Sets (IAR vs Microbial) - Stacked"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white", color = "black", linewidth = 1),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(size = 12),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    )

  return(list(plot = p, data = combined_data))
}

# Run the function and save the plot
tconv_stacked_result <- create_stacked_tconv_gsea(comparisons)

# Save the plot
savePlot(
  plot = tconv_stacked_result$plot,
  plotDir = plotDir,
  filename = "Stacked_Tconv_Hallmark_GO_GSEA",
  height = 14,
  width = 16,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)
```

## Stacked Treg Plot - curated terms

```{r Figure2EStackedTregHallmarkGOCuratedTerms}
# GO terms:
#   Innate immune response: INNATE_IMMUNE_RESPONSE
#   Immune response: IMMUNE_RESPONSE
#   Defense response: DEFENSE_RESPONSE
#   Cytoplasmic translation: CYTOPLASMIC_TRANSLATION
#   Ribonucleoprotein complex: RIBONUCLEOPROTEIN_COMPLEX
# Hallmark terms:
#   IFN alpha response: INTERFERON_ALPHA_RESPONSE
#   IFN gamma response: INTERFERON_GAMMA_RESPONSE
#   Myc Targets v1: MYC_TARGETS_V1

comparisons <- list()
comparisons[["results_Treg_IARVMicrobial"]] <- results_Treg_IARVMicrobial

# Combined Treg figure with selected/curated terms - stacked with readable names
create_curated_stacked_treg_gsea <- function(comparisons) {
  # Get gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # Get Treg gene list
  treg_df <- comparisons[["results_Treg_IARVMicrobial"]]
  treg_df <- treg_df %>% dplyr::filter(adj.P.Val <= 0.1)
  treg_geneList <- treg_df$logFC
  names(treg_geneList) <- treg_df$gene
  treg_geneList <- sort(treg_geneList, decreasing = TRUE)

  # Run GSEA for both gene sets
  treg_hallmark_gsea <- GSEA(treg_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  treg_go_gsea <- GSEA(treg_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  # Define curated terms with readable names
  curated_go_terms <- c(
    "INNATE_IMMUNE_RESPONSE" = "Innate immune response",
    "IMMUNE_RESPONSE" = "Immune response",
    "DEFENSE_RESPONSE" = "Defense response",
    "CYTOPLASMIC_TRANSLATION" = "Cytoplasmic translation",
    "RIBONUCLEOPROTEIN_COMPLEX" = "Ribonucleoprotein complex"
  )

  curated_hallmark_terms <- c(
    "INTERFERON_ALPHA_RESPONSE" = "IFN alpha response",
    "INTERFERON_GAMMA_RESPONSE" = "IFN gamma response",
    "MYC_TARGETS_V1" = "Myc Targets v1"
  )

  # Filter for curated terms
  hallmark_curated <- treg_hallmark_gsea@result %>%
    dplyr::filter(ID %in% paste0("HALLMARK_", names(curated_hallmark_terms))) %>%
    dplyr::mutate(
      GeneSet = "Hallmark",
      term_key = gsub("HALLMARK_", "", ID),
      Description_clean = curated_hallmark_terms[term_key]
    ) %>%
    dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet, setSize)

  go_curated <- treg_go_gsea@result %>%
    dplyr::filter(ID %in% paste0("GOBP_", names(curated_go_terms)) |
      ID %in% paste0("GOCC_", names(curated_go_terms)) |
      ID %in% paste0("GOMF_", names(curated_go_terms))) %>%
    dplyr::mutate(
      GeneSet = "GO",
      term_key = gsub("GOBP_|GOCC_|GOMF_", "", ID),
      Description_clean = curated_go_terms[term_key]
    ) %>%
    dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet, setSize)

  # Combine curated data
  combined_data <- rbind(hallmark_curated, go_curated)

  # Check if we have any curated terms
  if (nrow(combined_data) == 0) {
    cat("No curated terms found for Treg. Returning empty plot.\n")
    empty_plot <- ggplot() +
      geom_text(aes(x = 0, y = 0, label = "No curated terms found"), size = 6) +
      theme_void() +
      ggtitle("Treg: Curated Hallmark and GO Gene Sets (IAR vs Microbial)")
    return(list(plot = empty_plot, data = data.frame()))
  }

  # Order terms by NES magnitude within each gene set
  hallmark_order <- hallmark_curated %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  go_order <- go_curated %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  combined_data$Description_clean <- factor(combined_data$Description_clean,
    levels = c(hallmark_order, go_order))

  # Calculate custom size scale breaks with more robust logic
  size_range <- range(combined_data$setSize)
  # Ensure we get 4 distinct values by creating a wider range
  range_width <- size_range[2] - size_range[1]
  if (range_width < 15) {
    # If range is too narrow, expand it significantly
    size_min <- floor((size_range[1] - 15) / 5) * 5
    size_max <- ceiling((size_range[2] + 15) / 5) * 5
  } else {
    # Normal expansion
    size_min <- floor((size_range[1] - 5) / 5) * 5
    size_max <- ceiling((size_range[2] + 5) / 5) * 5
  }

  # Create exactly 4 breaks
  size_breaks <- seq(size_min, size_max, length.out = 4)
  size_breaks <- round(size_breaks / 5) * 5  # Round to multiples of 5
  size_breaks <- unique(size_breaks)  # Remove duplicates

  # If we still don't have 4, force create them
  if (length(size_breaks) < 4) {
    size_breaks <- seq(size_min, size_max, length.out = 4)
    size_breaks <- round(size_breaks / 5) * 5
    # Manually adjust to ensure 4 unique values
    while (length(unique(size_breaks)) < 4) {
      size_max <- size_max + 5
      size_breaks <- seq(size_min, size_max, length.out = 4)
      size_breaks <- round(size_breaks / 5) * 5
    }
    size_breaks <- unique(size_breaks)
  }

  # Create the plot with proportional panel heights
  # For true area scaling, we need to take square root of size values
  # since ggplot2's size aesthetic scales by radius, not area
  p <- ggplot(combined_data, aes(x = NES, y = Description_clean)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description_clean, yend = Description_clean, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      size = setSize,
      fill = -log10(p.adjust)
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_grid(GeneSet ~ ., scales = "free_y", space = "free_y") +
    scale_fill_gradient(
      low = "lightblue", high = "red",
      name = "-log10(Adj.P)"
    ) +
    scale_size_area(
      breaks = size_breaks,
      limits = c(min(size_breaks), max(size_breaks)),
      max_size = 8,
      guide = guide_legend(override.aes = list(fill = NA, color = "black"))
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "Gene Set Size",
      title = "Treg: Curated Hallmark and GO Gene Sets (IAR vs Microbial)"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white", color = "black", linewidth = 1),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(size = 12),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    )

  return(list(plot = p, data = combined_data))
}

# Run the function and save the plot
treg_curated_result <- create_curated_stacked_treg_gsea(comparisons)

# Save the plot
savePlot(
  plot = treg_curated_result$plot,
  plotDir = plotDir,
  filename = "Curated_Stacked_Treg_Hallmark_GO_GSEA",
  height = 8,
  width = 10,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)
```


## Stacked Tconv Plot - curated terms
```{r Figure2FStackedTconvHallmarkGOCuratedTerms}
# GO terms:
#   Cytokine response: RESPONSE_TO_CYTOKINE
#   Defense response: DEFENSE_RESPONSE
#   Pre-ribosome: PRERIBOSOME
#   Mitochondrial complex: MITOCHONDRIAL_GENE_EXPRESSION
# Hallmark terms:
#   IL-6-JAK-STAT3 signaling: IL6_JAK_STAT3_SIGNALING
#   IL-2-STAT5 signaling: IL2_STAT5_SIGNALING
#   IFN alpha response: INTERFERON_ALPHA_RESPONSE
#   IFN gamma response: INTERFERON_GAMMA_RESPONSE
#   E2F targets: E2F_TARGETS
#   Myc targets v2: MYC_TARGETS_V2
comparisons <- list()
comparisons[["results_Tconv_IARVMicrobial"]] <- results_Tconv_IARVMicrobial

# Combined Tconv figure with selected/curated terms - stacked with readable names
create_curated_stacked_tconv_gsea <- function(comparisons) {
  # Get gene sets
  hs_sets <- msigdbr(species = "Homo sapiens", category = "H") %>%
    dplyr::select(gs_name, gene_symbol)

  GO_sets <- msigdbr(species = "Homo sapiens", category = "C5") %>%
    dplyr::select(gs_name, gene_symbol)

  # Get Tconv gene list
  tconv_df <- comparisons[["results_Tconv_IARVMicrobial"]]
  tconv_df <- tconv_df %>% dplyr::filter(adj.P.Val <= 0.1)
  tconv_geneList <- tconv_df$logFC
  names(tconv_geneList) <- tconv_df$gene
  tconv_geneList <- sort(tconv_geneList, decreasing = TRUE)

  # Run GSEA for both gene sets
  tconv_hallmark_gsea <- GSEA(tconv_geneList,
    TERM2GENE = hs_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  tconv_go_gsea <- GSEA(tconv_geneList,
    TERM2GENE = GO_sets,
    minGSSize = 10,
    maxGSSize = 1000,
    pvalueCutoff = 1.0)

  # Define curated terms with readable names
  curated_go_terms <- c(
    "RESPONSE_TO_CYTOKINE" = "Cytokine response",
    "DEFENSE_RESPONSE" = "Defense response",
    "PRERIBOSOME" = "Pre-ribosome",
    "MITOCHONDRIAL_GENE_EXPRESSION" = "Mitochondrial complex"
  )

  curated_hallmark_terms <- c(
    "IL6_JAK_STAT3_SIGNALING" = "IL-6-JAK-STAT3 signaling",
    "IL2_STAT5_SIGNALING" = "IL-2-STAT5 signaling",
    "INTERFERON_ALPHA_RESPONSE" = "IFN alpha response",
    "INTERFERON_GAMMA_RESPONSE" = "IFN gamma response",
    "E2F_TARGETS" = "E2F targets",
    "MYC_TARGETS_V2" = "Myc targets v2"
  )

  # Filter for curated terms
  hallmark_curated <- tconv_hallmark_gsea@result %>%
    dplyr::filter(ID %in% paste0("HALLMARK_", names(curated_hallmark_terms))) %>%
    dplyr::mutate(
      GeneSet = "Hallmark",
      term_key = gsub("HALLMARK_", "", ID),
      Description_clean = curated_hallmark_terms[term_key]
    ) %>%
    dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet, setSize)

  go_curated <- tconv_go_gsea@result %>%
    dplyr::filter(ID %in% paste0("GOBP_", names(curated_go_terms)) |
      ID %in% paste0("GOCC_", names(curated_go_terms)) |
      ID %in% paste0("GOMF_", names(curated_go_terms))) %>%
    dplyr::mutate(
      GeneSet = "GO",
      term_key = gsub("GOBP_|GOCC_|GOMF_", "", ID),
      Description_clean = curated_go_terms[term_key]
    ) %>%
    dplyr::select(ID, Description_clean, NES, p.adjust, GeneSet, setSize)

  # Combine curated data
  combined_data <- rbind(hallmark_curated, go_curated)

  # Check if we have any curated terms
  if (nrow(combined_data) == 0) {
    cat("No curated terms found for Tconv. Returning empty plot.\n")
    empty_plot <- ggplot() +
      geom_text(aes(x = 0, y = 0, label = "No curated terms found"), size = 6) +
      theme_void() +
      ggtitle("Tconv: Curated Hallmark and GO Gene Sets (IAR vs Microbial)")
    return(list(plot = empty_plot, data = data.frame()))
  }

  # Order terms by NES magnitude within each gene set
  hallmark_order <- hallmark_curated %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  go_order <- go_curated %>%
    dplyr::arrange(desc(abs(NES))) %>%
    dplyr::pull(Description_clean)

  combined_data$Description_clean <- factor(combined_data$Description_clean,
    levels = c(hallmark_order, go_order))

  # Calculate custom size scale breaks with more robust logic
  size_range <- range(combined_data$setSize)
  # Ensure we get 4 distinct values by creating a wider range
  range_width <- size_range[2] - size_range[1]
  if (range_width < 15) {
    # If range is too narrow, expand it significantly
    size_min <- floor((size_range[1] - 15) / 5) * 5
    size_max <- ceiling((size_range[2] + 15) / 5) * 5
  } else {
    # Normal expansion
    size_min <- floor((size_range[1] - 5) / 5) * 5
    size_max <- ceiling((size_range[2] + 5) / 5) * 5
  }

  # Create exactly 4 breaks
  size_breaks <- seq(size_min, size_max, length.out = 4)
  size_breaks <- round(size_breaks / 5) * 5  # Round to multiples of 5
  size_breaks <- unique(size_breaks)  # Remove duplicates

  # If we still don't have 4, force create them
  if (length(size_breaks) < 4) {
    size_breaks <- seq(size_min, size_max, length.out = 4)
    size_breaks <- round(size_breaks / 5) * 5
    # Manually adjust to ensure 4 unique values
    while (length(unique(size_breaks)) < 4) {
      size_max <- size_max + 5
      size_breaks <- seq(size_min, size_max, length.out = 4)
      size_breaks <- round(size_breaks / 5) * 5
    }
    size_breaks <- unique(size_breaks)
  }

  # Create the plot with proportional panel heights
  # For true area scaling, we need to take square root of size values
  # since ggplot2's size aesthetic scales by radius, not area
  p <- ggplot(combined_data, aes(x = NES, y = Description_clean)) +
    geom_vline(xintercept = 0, linetype = "solid", color = "gray80") +
    geom_segment(aes(y = Description_clean, yend = Description_clean, x = 0, xend = NES),
      color = "black", linewidth = 0.5) +
    geom_point(aes(
      size = setSize,
      fill = -log10(p.adjust)
    ),
    shape = 21,
    color = "black",
    stroke = 0.5) +
    facet_grid(GeneSet ~ ., scales = "free_y", space = "free_y") +
    scale_fill_gradient(
      low = "lightblue", high = "red",
      name = "-log10(Adj.P)"
    ) +
    scale_size_area(
      breaks = size_breaks,
      limits = c(min(size_breaks), max(size_breaks)),
      max_size = 8,
      guide = guide_legend(override.aes = list(fill = NA, color = "black"))
    ) +
    labs(
      x = "Normalized Enrichment Score (NES)",
      y = "",
      size = "Gene Set Size",
      title = "Tconv: Curated Hallmark and GO Gene Sets (IAR vs Microbial)"
    ) +
    theme_bw() +
    theme(
      strip.background = element_rect(fill = "white", color = "black", linewidth = 1),
      strip.text = element_text(face = "bold", size = 14),
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(size = 12),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = "gray95"),
      panel.grid.major.y = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 1)
    )

  return(list(plot = p, data = combined_data))
}

# Run the function and save the plot
tconv_curated_result <- create_curated_stacked_tconv_gsea(comparisons)

# Save the plot
savePlot(
  plot = tconv_curated_result$plot,
  plotDir = plotDir,
  filename = "Curated_Stacked_Tconv_Hallmark_GO_GSEA",
  height = 8,
  width = 10,
  units = "in",
  dpi = 600,
  formats = c("pdf", "png")
)
```